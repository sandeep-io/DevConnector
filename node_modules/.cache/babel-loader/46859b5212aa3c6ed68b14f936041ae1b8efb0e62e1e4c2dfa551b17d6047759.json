{"ast":null,"code":"'use strict';\n\n/**\n * Create a new instance\n */\nfunction Kareem() {\n  this._pres = new Map();\n  this._posts = new Map();\n}\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\n    return new Kareem.skipWrappedFunction(...arguments);\n  }\n  this.args = [...arguments];\n};\nKareem.overwriteResult = function overwriteResult() {\n  if (!(this instanceof Kareem.overwriteResult)) {\n    return new Kareem.overwriteResult(...arguments);\n  }\n  this.args = [...arguments];\n};\nKareem.overwriteArguments = function overwriteArguments() {\n  if (!(this instanceof Kareem.overwriteArguments)) {\n    return new Kareem.overwriteArguments(...arguments);\n  }\n  this.args = [...arguments];\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args arguments passed to the pre hooks\n * @returns {Array} The potentially modified arguments\n */\nKareem.prototype.execPre = async function execPre(name, context, args) {\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  let $args = args;\n  let skipWrappedFunction = null;\n  if (!numPres) {\n    return $args;\n  }\n  for (const pre of pres) {\n    const args = [];\n    const _args = [null].concat($args);\n    for (let i = 1; i < _args.length; ++i) {\n      if (i === _args.length - 1 && typeof _args[i] === 'function') {\n        continue; // skip callbacks to avoid accidentally calling the callback from a hook\n      }\n      args.push(_args[i]);\n    }\n    try {\n      const maybePromiseLike = pre.fn.apply(context, args);\n      if (isPromiseLike(maybePromiseLike)) {\n        const result = await maybePromiseLike;\n        if (result instanceof Kareem.overwriteArguments) {\n          $args = result.args;\n        }\n      } else if (maybePromiseLike instanceof Kareem.overwriteArguments) {\n        $args = maybePromiseLike.args;\n      }\n    } catch (error) {\n      if (error instanceof Kareem.skipWrappedFunction) {\n        skipWrappedFunction = error;\n        continue;\n      }\n      if (error instanceof Kareem.overwriteArguments) {\n        $args = error.args;\n        continue;\n      }\n      throw error;\n    }\n  }\n  if (skipWrappedFunction) {\n    throw skipWrappedFunction;\n  }\n  return $args;\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} [args] Apply custom arguments to the hook\n * @returns {Array} The potentially modified arguments\n */\nKareem.prototype.execPreSync = function (name, context, args) {\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  let $args = args || [];\n  for (let i = 0; i < numPres; ++i) {\n    const result = pres[i].fn.apply(context, $args);\n    if (result instanceof Kareem.overwriteArguments) {\n      $args = result.args;\n    }\n  }\n  return $args;\n};\n\n/**\n * Execute all \"post\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {*} options Optional options or directly the callback\n * @returns {void}\n */\nKareem.prototype.execPost = async function execPost(name, context, args, options) {\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n  let firstError = null;\n  if (options && options.error) {\n    firstError = options.error;\n  }\n  if (!numPosts) {\n    if (firstError != null) {\n      throw firstError;\n    }\n    return args;\n  }\n  for (const currentPost of posts) {\n    const post = currentPost.fn;\n    let numArgs = 0;\n    const newArgs = [];\n    const argLength = args.length;\n    for (let i = 0; i < argLength; ++i) {\n      if (!args[i] || !args[i]._kareemIgnore) {\n        numArgs += 1;\n        newArgs.push(args[i]);\n      }\n    }\n    // If numCallbackParams set, fill in the rest with null to enforce consistent number of args\n    if (options?.numCallbackParams != null) {\n      numArgs = options.numCallbackParams;\n      for (let i = newArgs.length; i < numArgs; ++i) {\n        newArgs.push(null);\n      }\n    }\n    let resolve;\n    let reject;\n    const cbPromise = new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n    newArgs.push(function nextCallback(err) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n    if (firstError) {\n      if (isErrorHandlingMiddleware(currentPost, numArgs)) {\n        try {\n          const res = post.apply(context, [firstError].concat(newArgs));\n          if (isPromiseLike(res)) {\n            await res;\n          } else if (post.length === numArgs + 2) {\n            // `numArgs + 2` because we added the error and the callback\n            await cbPromise;\n          }\n        } catch (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            continue;\n          }\n          firstError = error;\n        }\n      } else {\n        continue;\n      }\n    } else {\n      if (isErrorHandlingMiddleware(currentPost, numArgs)) {\n        // Skip error handlers if no error\n        continue;\n      } else {\n        let res = null;\n        try {\n          res = post.apply(context, newArgs);\n          if (isPromiseLike(res)) {\n            res = await res;\n          } else if (post.length === numArgs + 1) {\n            // If post function takes a callback, wait for the post function to call the callback\n            res = await cbPromise;\n          }\n        } catch (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            continue;\n          }\n          firstError = error;\n          continue;\n        }\n        if (res instanceof Kareem.overwriteResult) {\n          args = res.args;\n          continue;\n        }\n      }\n    }\n  }\n  if (firstError != null) {\n    throw firstError;\n  }\n  return args;\n};\n\n/**\n * Execute all \"post\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @returns {Array} The used arguments\n */\nKareem.prototype.execPostSync = function (name, context, args) {\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n  for (let i = 0; i < numPosts; ++i) {\n    const res = posts[i].fn.apply(context, args || []);\n    if (res instanceof Kareem.overwriteResult) {\n      args = res.args;\n    }\n  }\n  return args;\n};\n\n/**\n * Create a synchronous wrapper for \"fn\"\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapperSync = function (name, fn) {\n  const _this = this;\n  return function syncWrapper() {\n    const modifiedArgs = _this.execPreSync(name, this, Array.from(arguments));\n    const toReturn = fn.apply(this, modifiedArgs);\n    const result = _this.execPostSync(name, this, [toReturn]);\n    return result[0];\n  };\n};\n\n/**\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\n * @param {String} name The name of the hook\n * @param {Function} fn The function for the hook\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} options Additional options for the hook\n * @returns {void}\n */\nKareem.prototype.wrap = async function wrap(name, fn, context, args, options) {\n  let ret;\n  let skipWrappedFunction = false;\n  let modifiedArgs = args;\n  try {\n    modifiedArgs = await this.execPre(name, context, args);\n  } catch (error) {\n    if (error instanceof Kareem.skipWrappedFunction) {\n      ret = error.args;\n      skipWrappedFunction = true;\n    } else {\n      await this.execPost(name, context, args, {\n        ...options,\n        error\n      });\n    }\n  }\n  if (!skipWrappedFunction) {\n    ret = await fn.apply(context, modifiedArgs);\n  }\n  ret = await this.execPost(name, context, [ret], options);\n  return ret[0];\n};\n\n/**\n * Filter current instance for something specific and return the filtered clone\n * @param {Function} fn The filter function\n * @returns {Kareem} The cloned and filtered instance\n */\nKareem.prototype.filter = function (fn) {\n  const clone = this.clone();\n  const pres = Array.from(clone._pres.keys());\n  for (const name of pres) {\n    const hooks = this._pres.get(name).map(h => Object.assign({}, h, {\n      name: name\n    })).filter(fn);\n    if (hooks.length === 0) {\n      clone._pres.delete(name);\n      continue;\n    }\n    clone._pres.set(name, hooks);\n  }\n  const posts = Array.from(clone._posts.keys());\n  for (const name of posts) {\n    const hooks = this._posts.get(name).map(h => Object.assign({}, h, {\n      name: name\n    })).filter(fn);\n    if (hooks.length === 0) {\n      clone._posts.delete(name);\n      continue;\n    }\n    clone._posts.set(name, hooks);\n  }\n  return clone;\n};\n\n/**\n * Check for a \"name\" to exist either in pre or post hooks\n * @param {String} name The name of the hook\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\n */\nKareem.prototype.hasHooks = function (name) {\n  return this._pres.has(name) || this._posts.has(name);\n};\n\n/**\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Object} [options]\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapper = function (name, fn, context, options) {\n  const _this = this;\n  if (!this.hasHooks(name)) {\n    // Fast path: if there's no hooks for this function, just return the function\n    return fn;\n  }\n  return function kareemWrappedFunction() {\n    const _context = context || this;\n    return _this.wrap(name, fn, _context, Array.from(arguments), options);\n  };\n};\n\n/**\n * Register a new hook for \"pre\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {never} error Unused\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.pre = function (name, options, fn, error, unshift) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  } else if (options == null) {\n    options = {};\n  }\n  const pres = this._pres.get(name) || [];\n  this._pres.set(name, pres);\n  if (typeof fn !== 'function') {\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n  }\n  if (unshift) {\n    pres.unshift(Object.assign({}, options, {\n      fn: fn\n    }));\n  } else {\n    pres.push(Object.assign({}, options, {\n      fn: fn\n    }));\n  }\n  return this;\n};\n\n/**\n * Register a new hook for \"post\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Boolean} [options.errorHandler] Whether this is an error handler\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.post = function (name, options, fn, unshift) {\n  const posts = this._posts.get(name) || [];\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n  if (typeof fn !== 'function') {\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n  }\n  if (unshift) {\n    posts.unshift(Object.assign({}, options, {\n      fn: fn\n    }));\n  } else {\n    posts.push(Object.assign({}, options, {\n      fn: fn\n    }));\n  }\n  this._posts.set(name, posts);\n  return this;\n};\n\n/**\n * Register a new error handler for \"name\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\n\nKareem.prototype.postError = function postError(name, options, fn, unshift) {\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n  return this.post(name, {\n    ...options,\n    errorHandler: true\n  }, fn, unshift);\n};\n\n/**\n * Clone the current instance\n * @returns {Kareem} The cloned instance\n */\nKareem.prototype.clone = function () {\n  const n = new Kareem();\n  for (const key of this._pres.keys()) {\n    const clone = this._pres.get(key).slice();\n    n._pres.set(key, clone);\n  }\n  for (const key of this._posts.keys()) {\n    n._posts.set(key, this._posts.get(key).slice());\n  }\n  return n;\n};\n\n/**\n * Merge \"other\" into self or \"clone\"\n * @param {Kareem} other The instance to merge with\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\n * @returns {Kareem} The merged instance\n */\nKareem.prototype.merge = function (other, clone) {\n  clone = arguments.length === 1 ? true : clone;\n  const ret = clone ? this.clone() : this;\n  for (const key of other._pres.keys()) {\n    const sourcePres = ret._pres.get(key) || [];\n    const deduplicated = other._pres.get(key).\n    // Deduplicate based on `fn`\n    filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\n    const combined = sourcePres.concat(deduplicated);\n    ret._pres.set(key, combined);\n  }\n  for (const key of other._posts.keys()) {\n    const sourcePosts = ret._posts.get(key) || [];\n    const deduplicated = other._posts.get(key).filter(p => sourcePosts.indexOf(p) === -1);\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\n  }\n  return ret;\n};\nfunction isPromiseLike(v) {\n  return typeof v === 'object' && v !== null && typeof v.then === 'function';\n}\nfunction isErrorHandlingMiddleware(post, numArgs) {\n  if (post.errorHandler) {\n    return true;\n  }\n  return post.fn.length === numArgs + 2;\n}\nmodule.exports = Kareem;","map":{"version":3,"names":["Kareem","_pres","Map","_posts","skipWrappedFunction","arguments","args","overwriteResult","overwriteArguments","prototype","execPre","name","context","pres","get","numPres","length","$args","pre","_args","concat","i","push","maybePromiseLike","fn","apply","isPromiseLike","result","error","execPreSync","execPost","options","posts","numPosts","firstError","currentPost","post","numArgs","newArgs","argLength","_kareemIgnore","numCallbackParams","resolve","reject","cbPromise","Promise","_resolve","_reject","nextCallback","err","isErrorHandlingMiddleware","res","execPostSync","createWrapperSync","_this","syncWrapper","modifiedArgs","Array","from","toReturn","wrap","ret","filter","clone","keys","hooks","map","h","Object","assign","delete","set","hasHooks","has","createWrapper","kareemWrappedFunction","_context","unshift","Error","postError","errorHandler","n","key","slice","merge","other","sourcePres","deduplicated","p","_p","indexOf","combined","sourcePosts","v","then","module","exports"],"sources":["C:/DEVC/node_modules/kareem/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Create a new instance\n */\nfunction Kareem() {\n  this._pres = new Map();\n  this._posts = new Map();\n}\n\nKareem.skipWrappedFunction = function skipWrappedFunction() {\n  if (!(this instanceof Kareem.skipWrappedFunction)) {\n    return new Kareem.skipWrappedFunction(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\nKareem.overwriteResult = function overwriteResult() {\n  if (!(this instanceof Kareem.overwriteResult)) {\n    return new Kareem.overwriteResult(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\nKareem.overwriteArguments = function overwriteArguments() {\n  if (!(this instanceof Kareem.overwriteArguments)) {\n    return new Kareem.overwriteArguments(...arguments);\n  }\n\n  this.args = [...arguments];\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args arguments passed to the pre hooks\n * @returns {Array} The potentially modified arguments\n */\nKareem.prototype.execPre = async function execPre(name, context, args) {\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  let $args = args;\n  let skipWrappedFunction = null;\n\n  if (!numPres) {\n    return $args;\n  }\n\n  for (const pre of pres) {\n    const args = [];\n    const _args = [null].concat($args);\n    for (let i = 1; i < _args.length; ++i) {\n      if (i === _args.length - 1 && typeof _args[i] === 'function') {\n        continue; // skip callbacks to avoid accidentally calling the callback from a hook\n      }\n      args.push(_args[i]);\n    }\n\n    try {\n      const maybePromiseLike = pre.fn.apply(context, args);\n      if (isPromiseLike(maybePromiseLike)) {\n        const result = await maybePromiseLike;\n        if (result instanceof Kareem.overwriteArguments) {\n          $args = result.args;\n        }\n      } else if (maybePromiseLike instanceof Kareem.overwriteArguments) {\n        $args = maybePromiseLike.args;\n      }\n    } catch (error) {\n      if (error instanceof Kareem.skipWrappedFunction) {\n        skipWrappedFunction = error;\n        continue;\n      }\n      if (error instanceof Kareem.overwriteArguments) {\n        $args = error.args;\n        continue;\n      }\n      throw error;\n    }\n  }\n\n  if (skipWrappedFunction) {\n    throw skipWrappedFunction;\n  }\n\n  return $args;\n};\n\n/**\n * Execute all \"pre\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} [args] Apply custom arguments to the hook\n * @returns {Array} The potentially modified arguments\n */\nKareem.prototype.execPreSync = function(name, context, args) {\n  const pres = this._pres.get(name) || [];\n  const numPres = pres.length;\n  let $args = args || [];\n\n  for (let i = 0; i < numPres; ++i) {\n    const result = pres[i].fn.apply(context, $args);\n    if (result instanceof Kareem.overwriteArguments) {\n      $args = result.args;\n    }\n  }\n\n  return $args;\n};\n\n/**\n * Execute all \"post\" hooks for \"name\"\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {*} options Optional options or directly the callback\n * @returns {void}\n */\nKareem.prototype.execPost = async function execPost(name, context, args, options) {\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n\n  let firstError = null;\n  if (options && options.error) {\n    firstError = options.error;\n  }\n\n  if (!numPosts) {\n    if (firstError != null) {\n      throw firstError;\n    }\n    return args;\n  }\n\n  for (const currentPost of posts) {\n    const post = currentPost.fn;\n    let numArgs = 0;\n    const newArgs = [];\n    const argLength = args.length;\n    for (let i = 0; i < argLength; ++i) {\n      if (!args[i] || !args[i]._kareemIgnore) {\n        numArgs += 1;\n        newArgs.push(args[i]);\n      }\n    }\n    // If numCallbackParams set, fill in the rest with null to enforce consistent number of args\n    if (options?.numCallbackParams != null) {\n      numArgs = options.numCallbackParams;\n      for (let i = newArgs.length; i < numArgs; ++i) {\n        newArgs.push(null);\n      }\n    }\n\n    let resolve;\n    let reject;\n    const cbPromise = new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n    newArgs.push(function nextCallback(err) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n\n    if (firstError) {\n      if (isErrorHandlingMiddleware(currentPost, numArgs)) {\n        try {\n          const res = post.apply(context, [firstError].concat(newArgs));\n          if (isPromiseLike(res)) {\n            await res;\n          } else if (post.length === numArgs + 2) {\n            // `numArgs + 2` because we added the error and the callback\n            await cbPromise;\n          }\n        } catch (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            continue;\n          }\n          firstError = error;\n        }\n      } else {\n        continue;\n      }\n    } else {\n      if (isErrorHandlingMiddleware(currentPost, numArgs)) {\n        // Skip error handlers if no error\n        continue;\n      } else {\n        let res = null;\n        try {\n          res = post.apply(context, newArgs);\n          if (isPromiseLike(res)) {\n            res = await res;\n          } else if (post.length === numArgs + 1) {\n            // If post function takes a callback, wait for the post function to call the callback\n            res = await cbPromise;\n          }\n        } catch (error) {\n          if (error instanceof Kareem.overwriteResult) {\n            args = error.args;\n            continue;\n          }\n          firstError = error;\n          continue;\n        }\n\n        if (res instanceof Kareem.overwriteResult) {\n          args = res.args;\n          continue;\n        }\n      }\n    }\n  }\n\n  if (firstError != null) {\n    throw firstError;\n  }\n\n  return args;\n};\n\n/**\n * Execute all \"post\" hooks for \"name\" synchronously\n * @param {String} name The hook name to execute\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @returns {Array} The used arguments\n */\nKareem.prototype.execPostSync = function(name, context, args) {\n  const posts = this._posts.get(name) || [];\n  const numPosts = posts.length;\n\n  for (let i = 0; i < numPosts; ++i) {\n    const res = posts[i].fn.apply(context, args || []);\n    if (res instanceof Kareem.overwriteResult) {\n      args = res.args;\n    }\n  }\n\n  return args;\n};\n\n/**\n * Create a synchronous wrapper for \"fn\"\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapperSync = function(name, fn) {\n  const _this = this;\n  return function syncWrapper() {\n    const modifiedArgs = _this.execPreSync(name, this, Array.from(arguments));\n\n    const toReturn = fn.apply(this, modifiedArgs);\n\n    const result = _this.execPostSync(name, this, [toReturn]);\n\n    return result[0];\n  };\n};\n\n/**\n * Executes pre hooks, followed by the wrapped function, followed by post hooks.\n * @param {String} name The name of the hook\n * @param {Function} fn The function for the hook\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Array} args Apply custom arguments to the hook\n * @param {Object} options Additional options for the hook\n * @returns {void}\n */\nKareem.prototype.wrap = async function wrap(name, fn, context, args, options) {\n  let ret;\n  let skipWrappedFunction = false;\n  let modifiedArgs = args;\n  try {\n    modifiedArgs = await this.execPre(name, context, args);\n  } catch (error) {\n    if (error instanceof Kareem.skipWrappedFunction) {\n      ret = error.args;\n      skipWrappedFunction = true;\n    } else {\n      await this.execPost(name, context, args, { ...options, error });\n    }\n  }\n\n  if (!skipWrappedFunction) {\n    ret = await fn.apply(context, modifiedArgs);\n  }\n\n  ret = await this.execPost(name, context, [ret], options);\n\n  return ret[0];\n};\n\n/**\n * Filter current instance for something specific and return the filtered clone\n * @param {Function} fn The filter function\n * @returns {Kareem} The cloned and filtered instance\n */\nKareem.prototype.filter = function(fn) {\n  const clone = this.clone();\n\n  const pres = Array.from(clone._pres.keys());\n  for (const name of pres) {\n    const hooks = this._pres.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._pres.delete(name);\n      continue;\n    }\n\n    clone._pres.set(name, hooks);\n  }\n\n  const posts = Array.from(clone._posts.keys());\n  for (const name of posts) {\n    const hooks = this._posts.get(name).\n      map(h => Object.assign({}, h, { name: name })).\n      filter(fn);\n\n    if (hooks.length === 0) {\n      clone._posts.delete(name);\n      continue;\n    }\n\n    clone._posts.set(name, hooks);\n  }\n\n  return clone;\n};\n\n/**\n * Check for a \"name\" to exist either in pre or post hooks\n * @param {String} name The name of the hook\n * @returns {Boolean} \"true\" if found, \"false\" otherwise\n */\nKareem.prototype.hasHooks = function(name) {\n  return this._pres.has(name) || this._posts.has(name);\n};\n\n/**\n * Create a Wrapper for \"fn\" on \"name\" and return the wrapped function\n * @param {String} name The name of the hook\n * @param {Function} fn The function to wrap\n * @param {*} context Overwrite the \"this\" for the hook\n * @param {Object} [options]\n * @returns {Function} The wrapped function\n */\nKareem.prototype.createWrapper = function(name, fn, context, options) {\n  const _this = this;\n  if (!this.hasHooks(name)) {\n    // Fast path: if there's no hooks for this function, just return the function\n    return fn;\n  }\n  return function kareemWrappedFunction() {\n    const _context = context || this;\n    return _this.wrap(name, fn, _context, Array.from(arguments), options);\n  };\n};\n\n/**\n * Register a new hook for \"pre\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {never} error Unused\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.pre = function(name, options, fn, error, unshift) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  } else if (options == null) {\n    options = {};\n  }\n\n  const pres = this._pres.get(name) || [];\n  this._pres.set(name, pres);\n\n  if (typeof fn !== 'function') {\n    throw new Error('pre() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    pres.unshift(Object.assign({}, options, { fn: fn }));\n  } else {\n    pres.push(Object.assign({}, options, { fn: fn }));\n  }\n\n  return this;\n};\n\n/**\n * Register a new hook for \"post\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Boolean} [options.errorHandler] Whether this is an error handler\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\nKareem.prototype.post = function(name, options, fn, unshift) {\n  const posts = this._posts.get(name) || [];\n\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('post() requires a function, got \"' + typeof fn + '\"');\n  }\n\n  if (unshift) {\n    posts.unshift(Object.assign({}, options, { fn: fn }));\n  } else {\n    posts.push(Object.assign({}, options, { fn: fn }));\n  }\n  this._posts.set(name, posts);\n  return this;\n};\n\n/**\n * Register a new error handler for \"name\"\n * @param {String} name The name of the hook\n * @param {Object} [options]\n * @param {Function} fn The function to register for \"name\"\n * @param {Boolean} [unshift] Wheter to \"push\" or to \"unshift\" the new hook\n * @returns {Kareem}\n */\n\nKareem.prototype.postError = function postError(name, options, fn, unshift) {\n  if (typeof options === 'function') {\n    unshift = !!fn;\n    fn = options;\n    options = {};\n  }\n  return this.post(name, { ...options, errorHandler: true }, fn, unshift);\n};\n\n/**\n * Clone the current instance\n * @returns {Kareem} The cloned instance\n */\nKareem.prototype.clone = function() {\n  const n = new Kareem();\n\n  for (const key of this._pres.keys()) {\n    const clone = this._pres.get(key).slice();\n    n._pres.set(key, clone);\n  }\n  for (const key of this._posts.keys()) {\n    n._posts.set(key, this._posts.get(key).slice());\n  }\n\n  return n;\n};\n\n/**\n * Merge \"other\" into self or \"clone\"\n * @param {Kareem} other The instance to merge with\n * @param {Kareem} [clone] The instance to merge onto (if not defined, using \"this\")\n * @returns {Kareem} The merged instance\n */\nKareem.prototype.merge = function(other, clone) {\n  clone = arguments.length === 1 ? true : clone;\n  const ret = clone ? this.clone() : this;\n\n  for (const key of other._pres.keys()) {\n    const sourcePres = ret._pres.get(key) || [];\n    const deduplicated = other._pres.get(key).\n      // Deduplicate based on `fn`\n      filter(p => sourcePres.map(_p => _p.fn).indexOf(p.fn) === -1);\n    const combined = sourcePres.concat(deduplicated);\n    ret._pres.set(key, combined);\n  }\n  for (const key of other._posts.keys()) {\n    const sourcePosts = ret._posts.get(key) || [];\n    const deduplicated = other._posts.get(key).\n      filter(p => sourcePosts.indexOf(p) === -1);\n    ret._posts.set(key, sourcePosts.concat(deduplicated));\n  }\n\n  return ret;\n};\n\nfunction isPromiseLike(v) {\n  return (typeof v === 'object' && v !== null && typeof v.then === 'function');\n}\n\nfunction isErrorHandlingMiddleware(post, numArgs) {\n  if (post.errorHandler) {\n    return true;\n  }\n  return post.fn.length === numArgs + 2;\n}\n\nmodule.exports = Kareem;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}