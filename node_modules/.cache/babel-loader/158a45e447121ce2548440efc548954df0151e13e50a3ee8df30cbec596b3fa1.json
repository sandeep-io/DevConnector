{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst CastError = require('./error/cast');\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst cast$expr = require('./helpers/query/cast$expr');\nconst castString = require('./cast/string');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst isOperator = require('./helpers/query/isOperator');\nconst util = require('util');\nconst isObject = require('./helpers/isObject');\nconst isMongooseObject = require('./helpers/isMongooseObject');\nconst utils = require('./utils');\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.sanitizeFilter] avoid adding implict query selectors ($in)\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n  if (obj == null) {\n    return obj;\n  }\n  if (schema?.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n  options = options || {};\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = val.length - 1; k >= 0; k--) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const beforeCastKeysLength = Object.keys(val[k]).length;\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n        if (utils.hasOwnKeys(val[k]) === false && beforeCastKeysLength !== 0) {\n          val.splice(k, 1);\n        }\n      }\n\n      // delete empty: {$or: []} -> {}\n      if (val.length === 0) {\n        delete obj[path];\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else if (path === '$comment' && !Object.hasOwn(schema.paths, '$comment')) {\n      val = castString(val, path);\n      obj[path] = val;\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype?.schema?.options?.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype?.schema?.discriminators != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null && Object.keys(discriminatorVal).length === 1 && Array.isArray(discriminatorVal.$in) && discriminatorVal.$in.length === 1 && typeof discriminatorVal.$in[0] === 'string' && discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            const ret = cast(schematype.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__', null, null, schema);\n            let value = val[geo];\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(null, val.$maxDistance, context);\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(null, val.$minDistance, context);\n            }\n            if (geo === '$within') {\n              const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n              value = withinType;\n            } else if (geo === '$near' && typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') && value.$geometry && typeof value.$geometry.type === 'string' && Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(null, value.$maxDistance, context);\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(null, value.$minDistance, context);\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({\n                    virtuals: false\n                  });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' + geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center || value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({\n                    virtuals: false\n                  });\n                }\n              }\n            }\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n        if (schema.nested[path]) {\n          continue;\n        }\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema, strict mode is `true`, and upsert is `true`.');\n        }\n        if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(null, val, context);\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype?.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype?.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery($cond, nested, context);\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(key, nested[key], context);\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery($cond, nested, context);\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested, context);\n            }\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1 && !options.sanitizeFilter) {\n        const casted = [];\n        const valuesArray = val;\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(null, _val, context));\n        }\n        obj[path] = {\n          $in: casted\n        };\n      } else {\n        obj[path] = schematype.castForQuery(null, val, context);\n      }\n    }\n  }\n  return obj;\n};\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function (item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({\n          val: item,\n          context: context\n        });\n      }\n    }\n  }\n}\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context?.mongooseCollection?.conn?.base?.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}","map":{"version":3,"names":["CastError","require","StrictModeError","Types","cast$expr","castString","castTextSearch","get","getSchemaDiscriminatorByValue","isOperator","util","isObject","isMongooseObject","utils","ALLOWED_GEOWITHIN_GEOJSON_TYPES","module","exports","cast","schema","obj","options","context","Array","isArray","Error","inspect","discriminators","discriminatorKey","paths","Object","keys","i","length","_keys","any$conditionals","schematype","nested","path","type","val","k","beforeCastKeysLength","discriminatorValue","discriminatorSchema","hasOwnKeys","splice","toString","hasOwn","split","j","pathFirstHalf","slice","join","pathLastHalf","_schematype","discriminatorVal","$in","remainingConds","ret","geo","$near","$nearSphere","$within","$geoIntersects","$geoWithin","numbertype","Number","value","$maxDistance","castForQuery","$minDistance","withinType","$center","$centerSphere","$box","$polygon","JSON","stringify","coordinates","$geometry","toObject","transform","virtuals","geoWithinType","indexOf","_cast","strict","strictQuery","getStrictQuery","_userProvidedOptions","upsert","isPOJO","some","ks","$cond","$isMongooseArray","$not","key","instance","sanitizeFilter","casted","valuesArray","_val","push","forEach","item","nearKeys","nearLen","nkey","queryOptions","schemaUserProvidedOptions","schemaOptions","mongooseOptions","mongooseCollection","conn","base"],"sources":["C:/DEVC/node_modules/mongoose/lib/cast.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('./error/cast');\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst cast$expr = require('./helpers/query/cast$expr');\nconst castString = require('./cast/string');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst isOperator = require('./helpers/query/isOperator');\nconst util = require('util');\nconst isObject = require('./helpers/isObject');\nconst isMongooseObject = require('./helpers/isMongooseObject');\nconst utils = require('./utils');\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.sanitizeFilter] avoid adding implict query selectors ($in)\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (schema?.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = val.length - 1; k >= 0; k--) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const beforeCastKeysLength = Object.keys(val[k]).length;\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n\n        if (utils.hasOwnKeys(val[k]) === false && beforeCastKeysLength !== 0) {\n          val.splice(k, 1);\n        }\n      }\n\n      // delete empty: {$or: []} -> {}\n      if (val.length === 0) {\n        delete obj[path];\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else if (path === '$comment' && !Object.hasOwn(schema.paths, '$comment')) {\n      val = castString(val, path);\n      obj[path] = val;\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype?.schema?.options?.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype?.schema?.discriminators != null &&\n            discriminatorKey != null &&\n            pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null &&\n              Object.keys(discriminatorVal).length === 1 &&\n              Array.isArray(discriminatorVal.$in) &&\n              discriminatorVal.$in.length === 1 &&\n              typeof discriminatorVal.$in[0] === 'string' &&\n              discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n\n            const ret = cast(schematype.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__', null, null, schema);\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(\n                null,\n                val.$maxDistance,\n                context\n              );\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(\n                null,\n                val.$minDistance,\n                context\n              );\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(\n                  null,\n                  value.$maxDistance,\n                  context\n                );\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(\n                  null,\n                  value.$minDistance,\n                  context\n                );\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(\n            null,\n            val,\n            context\n          );\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype?.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype?.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(\n                      key,\n                      nested[key],\n                      context\n                    );\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery(\n                $cond,\n                nested,\n                context\n              );\n            }\n\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1 && !options.sanitizeFilter) {\n        const casted = [];\n        const valuesArray = val;\n\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(\n            null,\n            _val,\n            context\n          ));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQuery(\n          null,\n          val,\n          context\n        );\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}\n\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context?.mongooseCollection?.conn?.base?.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}