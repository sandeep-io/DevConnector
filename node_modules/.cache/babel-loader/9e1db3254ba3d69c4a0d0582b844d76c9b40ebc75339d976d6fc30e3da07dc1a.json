{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AutoEncrypter = exports.AutoEncryptionLoggerLevel = void 0;\nconst net = require(\"net\");\nconst bson_1 = require(\"../bson\");\nconst constants_1 = require(\"../constants\");\nconst deps_1 = require(\"../deps\");\nconst error_1 = require(\"../error\");\nconst mongo_client_1 = require(\"../mongo_client\");\nconst utils_1 = require(\"../utils\");\nconst client_encryption_1 = require(\"./client_encryption\");\nconst errors_1 = require(\"./errors\");\nconst mongocryptd_manager_1 = require(\"./mongocryptd_manager\");\nconst providers_1 = require(\"./providers\");\nconst state_machine_1 = require(\"./state_machine\");\n/** @public */\nexports.AutoEncryptionLoggerLevel = Object.freeze({\n  FatalError: 0,\n  Error: 1,\n  Warning: 2,\n  Info: 3,\n  Trace: 4\n});\n/**\n * @internal An internal class to be used by the driver for auto encryption\n * **NOTE**: Not meant to be instantiated directly, this is for internal use only.\n */\nclass AutoEncrypter {\n  static {\n    _a = constants_1.kDecorateResult;\n  }\n  /** @internal */\n  static getMongoCrypt() {\n    const encryption = (0, deps_1.getMongoDBClientEncryption)();\n    if ('kModuleError' in encryption) {\n      throw encryption.kModuleError;\n    }\n    return encryption.MongoCrypt;\n  }\n  /**\n   * Create an AutoEncrypter\n   *\n   * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient\n   *\n   * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n   *\n   * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>\n   * ```ts\n   * // Enabling autoEncryption via a MongoClient using mongocryptd\n   * const { MongoClient } = require('mongodb');\n   * const client = new MongoClient(URL, {\n   *   autoEncryption: {\n   *     kmsProviders: {\n   *       aws: {\n   *         accessKeyId: AWS_ACCESS_KEY,\n   *         secretAccessKey: AWS_SECRET_KEY\n   *       }\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * await client.connect();\n   * // From here on, the client will be encrypting / decrypting automatically\n   * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>\n   * ```ts\n   * // Enabling autoEncryption via a MongoClient using CSFLE shared library\n   * const { MongoClient } = require('mongodb');\n   * const client = new MongoClient(URL, {\n   *   autoEncryption: {\n   *     kmsProviders: {\n   *       aws: {}\n   *     },\n   *     extraOptions: {\n   *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',\n   *       cryptSharedLibRequired: true\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * await client.connect();\n   * // From here on, the client will be encrypting / decrypting automatically\n   */\n  constructor(client, options) {\n    /**\n     * Used by devtools to enable decorating decryption results.\n     *\n     * When set and enabled, `decrypt` will automatically recursively\n     * traverse a decrypted document and if a field has been decrypted,\n     * it will mark it as decrypted.  Compass uses this to determine which\n     * fields were decrypted.\n     */\n    this[_a] = false;\n    this._client = client;\n    this._bypassEncryption = options.bypassAutoEncryption === true;\n    this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';\n    this._keyVaultClient = options.keyVaultClient || client;\n    this._metaDataClient = options.metadataClient || client;\n    this._proxyOptions = options.proxyOptions || {};\n    this._tlsOptions = options.tlsOptions || {};\n    this._kmsProviders = options.kmsProviders || {};\n    this._credentialProviders = options.credentialProviders;\n    if (options.credentialProviders?.aws && !(0, providers_1.isEmptyCredentials)('aws', this._kmsProviders)) {\n      throw new errors_1.MongoCryptInvalidArgumentError('Can only provide a custom AWS credential provider when the state machine is configured for automatic AWS credential fetching');\n    }\n    const mongoCryptOptions = {\n      errorWrapper: errors_1.defaultErrorWrapper\n    };\n    if (options.schemaMap) {\n      mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap) ? options.schemaMap : (0, bson_1.serialize)(options.schemaMap);\n    }\n    if (options.encryptedFieldsMap) {\n      mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap) ? options.encryptedFieldsMap : (0, bson_1.serialize)(options.encryptedFieldsMap);\n    }\n    mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders;\n    if (options.options?.logger) {\n      mongoCryptOptions.logger = options.options.logger;\n    }\n    if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {\n      mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;\n    }\n    if (options.bypassQueryAnalysis) {\n      mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;\n    }\n    if (options.keyExpirationMS != null) {\n      mongoCryptOptions.keyExpirationMS = options.keyExpirationMS;\n    }\n    this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;\n    if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {\n      // Only for driver testing\n      mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;\n    } else if (!this._bypassMongocryptdAndCryptShared) {\n      mongoCryptOptions.cryptSharedLibSearchPaths = ['$SYSTEM'];\n    }\n    const MongoCrypt = AutoEncrypter.getMongoCrypt();\n    this._mongocrypt = new MongoCrypt(mongoCryptOptions);\n    this._contextCounter = 0;\n    if (options.extraOptions && options.extraOptions.cryptSharedLibRequired && !this.cryptSharedLibVersionInfo) {\n      throw new errors_1.MongoCryptInvalidArgumentError('`cryptSharedLibRequired` set but no crypt_shared library loaded');\n    }\n    // Only instantiate mongocryptd manager/client once we know for sure\n    // that we are not using the CSFLE shared library.\n    if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {\n      this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);\n      const clientOptions = {\n        serverSelectionTimeoutMS: 10000\n      };\n      if ((options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== 'string') && !net.getDefaultAutoSelectFamily) {\n        // Only set family if autoSelectFamily options are not supported.\n        clientOptions.family = 4;\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore: TS complains as this always returns true on versions where it is present.\n      if (net.getDefaultAutoSelectFamily) {\n        // AutoEncrypter is made inside of MongoClient constructor while options are being parsed,\n        // we do not have access to the options that are in progress.\n        // TODO(NODE-6449): AutoEncrypter does not use client options for autoSelectFamily\n        Object.assign(clientOptions, (0, client_encryption_1.autoSelectSocketOptions)(this._client.s?.options ?? {}));\n      }\n      this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);\n    }\n  }\n  /**\n   * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.\n   *\n   * This function is a no-op when bypassSpawn is set or the crypt shared library is used.\n   */\n  async init() {\n    if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {\n      return;\n    }\n    if (!this._mongocryptdManager) {\n      throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.');\n    }\n    if (!this._mongocryptdClient) {\n      throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.');\n    }\n    if (!this._mongocryptdManager.bypassSpawn) {\n      await this._mongocryptdManager.spawn();\n    }\n    try {\n      const client = await this._mongocryptdClient.connect();\n      return client;\n    } catch (error) {\n      throw new error_1.MongoRuntimeError('Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn', {\n        cause: error\n      });\n    }\n  }\n  /**\n   * Cleans up the `_mongocryptdClient`, if present.\n   */\n  async close() {\n    await this._mongocryptdClient?.close();\n  }\n  /**\n   * Encrypt a command for a given namespace.\n   */\n  async encrypt(ns, cmd, options = {}) {\n    options.signal?.throwIfAborted();\n    if (this._bypassEncryption) {\n      // If `bypassAutoEncryption` has been specified, don't encrypt\n      return cmd;\n    }\n    const commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options);\n    const context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);\n    context.id = this._contextCounter++;\n    context.ns = ns;\n    context.document = cmd;\n    const stateMachine = new state_machine_1.StateMachine({\n      promoteValues: false,\n      promoteLongs: false,\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)\n    });\n    return (0, bson_1.deserialize)(await stateMachine.execute(this, context, options), {\n      promoteValues: false,\n      promoteLongs: false\n    });\n  }\n  /**\n   * Decrypt a command response\n   */\n  async decrypt(response, options = {}) {\n    options.signal?.throwIfAborted();\n    const context = this._mongocrypt.makeDecryptionContext(response);\n    context.id = this._contextCounter++;\n    const stateMachine = new state_machine_1.StateMachine({\n      ...options,\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)\n    });\n    return await stateMachine.execute(this, context, options);\n  }\n  /**\n   * Ask the user for KMS credentials.\n   *\n   * This returns anything that looks like the kmsProviders original input\n   * option. It can be empty, and any provider specified here will override\n   * the original ones.\n   */\n  async askForKMSCredentials() {\n    return await (0, providers_1.refreshKMSCredentials)(this._kmsProviders, this._credentialProviders);\n  }\n  /**\n   * Return the current libmongocrypt's CSFLE shared library version\n   * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE\n   * shared library was loaded.\n   */\n  get cryptSharedLibVersionInfo() {\n    return this._mongocrypt.cryptSharedLibVersionInfo;\n  }\n  static get libmongocryptVersion() {\n    return AutoEncrypter.getMongoCrypt().libmongocryptVersion;\n  }\n}\nexports.AutoEncrypter = AutoEncrypter;","map":{"version":3,"names":["net","require","bson_1","constants_1","deps_1","error_1","mongo_client_1","utils_1","client_encryption_1","errors_1","mongocryptd_manager_1","providers_1","state_machine_1","exports","AutoEncryptionLoggerLevel","Object","freeze","FatalError","Error","Warning","Info","Trace","AutoEncrypter","kDecorateResult","getMongoCrypt","encryption","getMongoDBClientEncryption","kModuleError","MongoCrypt","constructor","client","options","_a","_client","_bypassEncryption","bypassAutoEncryption","_keyVaultNamespace","keyVaultNamespace","_keyVaultClient","keyVaultClient","_metaDataClient","metadataClient","_proxyOptions","proxyOptions","_tlsOptions","tlsOptions","_kmsProviders","kmsProviders","_credentialProviders","credentialProviders","aws","isEmptyCredentials","MongoCryptInvalidArgumentError","mongoCryptOptions","errorWrapper","defaultErrorWrapper","schemaMap","Buffer","isBuffer","serialize","encryptedFieldsMap","logger","extraOptions","cryptSharedLibPath","bypassQueryAnalysis","keyExpirationMS","_bypassMongocryptdAndCryptShared","cryptSharedLibSearchPaths","_mongocrypt","_contextCounter","cryptSharedLibRequired","cryptSharedLibVersionInfo","_mongocryptdManager","MongocryptdManager","clientOptions","serverSelectionTimeoutMS","mongocryptdURI","getDefaultAutoSelectFamily","family","assign","autoSelectSocketOptions","s","_mongocryptdClient","MongoClient","uri","init","MongoRuntimeError","bypassSpawn","spawn","connect","error","cause","close","encrypt","ns","cmd","signal","throwIfAborted","commandBuffer","context","makeEncryptionContext","MongoDBCollectionNamespace","fromString","db","id","document","stateMachine","StateMachine","promoteValues","promoteLongs","socketOptions","deserialize","execute","decrypt","response","makeDecryptionContext","askForKMSCredentials","refreshKMSCredentials","libmongocryptVersion"],"sources":["C:\\DEVC\\node_modules\\mongodb\\src\\client-side-encryption\\auto_encrypter.ts"],"sourcesContent":["import { type MongoCrypt, type MongoCryptOptions } from 'mongodb-client-encryption';\nimport * as net from 'net';\n\nimport { deserialize, type Document, serialize } from '../bson';\nimport { type CommandOptions, type ProxyOptions } from '../cmap/connection';\nimport { kDecorateResult } from '../constants';\nimport { getMongoDBClientEncryption } from '../deps';\nimport { MongoRuntimeError } from '../error';\nimport { MongoClient, type MongoClientOptions } from '../mongo_client';\nimport { type Abortable } from '../mongo_types';\nimport { MongoDBCollectionNamespace } from '../utils';\nimport { autoSelectSocketOptions } from './client_encryption';\nimport { defaultErrorWrapper, MongoCryptInvalidArgumentError } from './errors';\nimport { MongocryptdManager } from './mongocryptd_manager';\nimport {\n  type CredentialProviders,\n  isEmptyCredentials,\n  type KMSProviders,\n  refreshKMSCredentials\n} from './providers';\nimport { type CSFLEKMSTlsOptions, StateMachine } from './state_machine';\n\n/** @public */\nexport interface AutoEncryptionOptions {\n  /** @internal client for metadata lookups */\n  metadataClient?: MongoClient;\n  /** A `MongoClient` used to fetch keys from a key vault */\n  keyVaultClient?: MongoClient;\n  /** The namespace where keys are stored in the key vault */\n  keyVaultNamespace?: string;\n  /** Configuration options that are used by specific KMS providers during key generation, encryption, and decryption. */\n  kmsProviders?: KMSProviders;\n  /** Configuration options for custom credential providers. */\n  credentialProviders?: CredentialProviders;\n  /**\n   * A map of namespaces to a local JSON schema for encryption\n   *\n   * **NOTE**: Supplying options.schemaMap provides more security than relying on JSON Schemas obtained from the server.\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending decrypted data that should be encrypted.\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n   */\n  schemaMap?: Document;\n  /** Supply a schema for the encrypted fields in the document  */\n  encryptedFieldsMap?: Document;\n  /** Allows the user to bypass auto encryption, maintaining implicit decryption */\n  bypassAutoEncryption?: boolean;\n  /** Allows users to bypass query analysis */\n  bypassQueryAnalysis?: boolean;\n  /**\n   * Sets the expiration time for the DEK in the cache in milliseconds. Defaults to 60000.  0 means no timeout.\n   */\n  keyExpirationMS?: number;\n  options?: {\n    /** An optional hook to catch logging messages from the underlying encryption engine */\n    logger?: (level: AutoEncryptionLoggerLevel, message: string) => void;\n  };\n  extraOptions?: {\n    /**\n     * A local process the driver communicates with to determine how to encrypt values in a command.\n     * Defaults to \"mongodb://%2Fvar%2Fmongocryptd.sock\" if domain sockets are available or \"mongodb://localhost:27020\" otherwise\n     */\n    mongocryptdURI?: string;\n    /** If true, autoEncryption will not attempt to spawn a mongocryptd before connecting  */\n    mongocryptdBypassSpawn?: boolean;\n    /** The path to the mongocryptd executable on the system */\n    mongocryptdSpawnPath?: `${string}mongocryptd${'.exe' | ''}`;\n    /** Command line arguments to use when auto-spawning a mongocryptd */\n    mongocryptdSpawnArgs?: string[];\n    /**\n     * Full path to a MongoDB Crypt shared library to be used (instead of mongocryptd).\n     *\n     * This needs to be the path to the file itself, not a directory.\n     * It can be an absolute or relative path. If the path is relative and\n     * its first component is `$ORIGIN`, it will be replaced by the directory\n     * containing the mongodb-client-encryption native addon file. Otherwise,\n     * the path will be interpreted relative to the current working directory.\n     *\n     * Currently, loading different MongoDB Crypt shared library files from different\n     * MongoClients in the same process is not supported.\n     *\n     * If this option is provided and no MongoDB Crypt shared library could be loaded\n     * from the specified location, creating the MongoClient will fail.\n     *\n     * If this option is not provided and `cryptSharedLibRequired` is not specified,\n     * the AutoEncrypter will attempt to spawn and/or use mongocryptd according\n     * to the mongocryptd-specific `extraOptions` options.\n     *\n     * Specifying a path prevents mongocryptd from being used as a fallback.\n     *\n     * Requires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.\n     */\n    cryptSharedLibPath?: `${string}mongo_crypt_v${number}.${'so' | 'dll' | 'dylib'}`;\n    /**\n     * If specified, never use mongocryptd and instead fail when the MongoDB Crypt\n     * shared library could not be loaded.\n     *\n     * This is always true when `cryptSharedLibPath` is specified.\n     *\n     * Requires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.\n     */\n    cryptSharedLibRequired?: boolean;\n    /**\n     * Search paths for a MongoDB Crypt shared library to be used (instead of mongocryptd)\n     * Only for driver testing!\n     * @internal\n     */\n    cryptSharedLibSearchPaths?: string[];\n  };\n  proxyOptions?: ProxyOptions;\n  /** The TLS options to use connecting to the KMS provider */\n  tlsOptions?: CSFLEKMSTlsOptions;\n}\n\n/**\n * @public\n *\n * Extra options related to the mongocryptd process\n * \\* _Available in MongoDB 6.0 or higher._\n */\nexport type AutoEncryptionExtraOptions = NonNullable<AutoEncryptionOptions['extraOptions']>;\n\n/** @public */\nexport const AutoEncryptionLoggerLevel = Object.freeze({\n  FatalError: 0,\n  Error: 1,\n  Warning: 2,\n  Info: 3,\n  Trace: 4\n} as const);\n\n/**\n * @public\n * The level of severity of the log message\n *\n * | Value | Level |\n * |-------|-------|\n * | 0 | Fatal Error |\n * | 1 | Error |\n * | 2 | Warning |\n * | 3 | Info |\n * | 4 | Trace |\n */\nexport type AutoEncryptionLoggerLevel =\n  (typeof AutoEncryptionLoggerLevel)[keyof typeof AutoEncryptionLoggerLevel];\n\n/**\n * @internal An internal class to be used by the driver for auto encryption\n * **NOTE**: Not meant to be instantiated directly, this is for internal use only.\n */\nexport class AutoEncrypter {\n  _client: MongoClient;\n  _bypassEncryption: boolean;\n  _keyVaultNamespace: string;\n  _keyVaultClient: MongoClient;\n  _metaDataClient: MongoClient;\n  _proxyOptions: ProxyOptions;\n  _tlsOptions: CSFLEKMSTlsOptions;\n  _kmsProviders: KMSProviders;\n  _bypassMongocryptdAndCryptShared: boolean;\n  _contextCounter: number;\n  _credentialProviders?: CredentialProviders;\n\n  _mongocryptdManager?: MongocryptdManager;\n  _mongocryptdClient?: MongoClient;\n\n  /** @internal */\n  _mongocrypt: MongoCrypt;\n\n  /**\n   * Used by devtools to enable decorating decryption results.\n   *\n   * When set and enabled, `decrypt` will automatically recursively\n   * traverse a decrypted document and if a field has been decrypted,\n   * it will mark it as decrypted.  Compass uses this to determine which\n   * fields were decrypted.\n   */\n  [kDecorateResult] = false;\n\n  /** @internal */\n  static getMongoCrypt(): typeof MongoCrypt {\n    const encryption = getMongoDBClientEncryption();\n    if ('kModuleError' in encryption) {\n      throw encryption.kModuleError;\n    }\n    return encryption.MongoCrypt;\n  }\n\n  /**\n   * Create an AutoEncrypter\n   *\n   * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient\n   *\n   * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.\n   * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.\n   * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\n   * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n   *\n   * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>\n   * ```ts\n   * // Enabling autoEncryption via a MongoClient using mongocryptd\n   * const { MongoClient } = require('mongodb');\n   * const client = new MongoClient(URL, {\n   *   autoEncryption: {\n   *     kmsProviders: {\n   *       aws: {\n   *         accessKeyId: AWS_ACCESS_KEY,\n   *         secretAccessKey: AWS_SECRET_KEY\n   *       }\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * await client.connect();\n   * // From here on, the client will be encrypting / decrypting automatically\n   * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>\n   * ```ts\n   * // Enabling autoEncryption via a MongoClient using CSFLE shared library\n   * const { MongoClient } = require('mongodb');\n   * const client = new MongoClient(URL, {\n   *   autoEncryption: {\n   *     kmsProviders: {\n   *       aws: {}\n   *     },\n   *     extraOptions: {\n   *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',\n   *       cryptSharedLibRequired: true\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * await client.connect();\n   * // From here on, the client will be encrypting / decrypting automatically\n   */\n  constructor(client: MongoClient, options: AutoEncryptionOptions) {\n    this._client = client;\n    this._bypassEncryption = options.bypassAutoEncryption === true;\n\n    this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';\n    this._keyVaultClient = options.keyVaultClient || client;\n    this._metaDataClient = options.metadataClient || client;\n    this._proxyOptions = options.proxyOptions || {};\n    this._tlsOptions = options.tlsOptions || {};\n    this._kmsProviders = options.kmsProviders || {};\n    this._credentialProviders = options.credentialProviders;\n\n    if (options.credentialProviders?.aws && !isEmptyCredentials('aws', this._kmsProviders)) {\n      throw new MongoCryptInvalidArgumentError(\n        'Can only provide a custom AWS credential provider when the state machine is configured for automatic AWS credential fetching'\n      );\n    }\n\n    const mongoCryptOptions: MongoCryptOptions = {\n      errorWrapper: defaultErrorWrapper\n    };\n    if (options.schemaMap) {\n      mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap)\n        ? options.schemaMap\n        : (serialize(options.schemaMap) as Buffer);\n    }\n\n    if (options.encryptedFieldsMap) {\n      mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap)\n        ? options.encryptedFieldsMap\n        : (serialize(options.encryptedFieldsMap) as Buffer);\n    }\n\n    mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders)\n      ? (serialize(this._kmsProviders) as Buffer)\n      : this._kmsProviders;\n\n    if (options.options?.logger) {\n      mongoCryptOptions.logger = options.options.logger;\n    }\n\n    if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {\n      mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;\n    }\n\n    if (options.bypassQueryAnalysis) {\n      mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;\n    }\n\n    if (options.keyExpirationMS != null) {\n      mongoCryptOptions.keyExpirationMS = options.keyExpirationMS;\n    }\n\n    this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;\n\n    if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {\n      // Only for driver testing\n      mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;\n    } else if (!this._bypassMongocryptdAndCryptShared) {\n      mongoCryptOptions.cryptSharedLibSearchPaths = ['$SYSTEM'];\n    }\n\n    const MongoCrypt = AutoEncrypter.getMongoCrypt();\n    this._mongocrypt = new MongoCrypt(mongoCryptOptions);\n    this._contextCounter = 0;\n\n    if (\n      options.extraOptions &&\n      options.extraOptions.cryptSharedLibRequired &&\n      !this.cryptSharedLibVersionInfo\n    ) {\n      throw new MongoCryptInvalidArgumentError(\n        '`cryptSharedLibRequired` set but no crypt_shared library loaded'\n      );\n    }\n\n    // Only instantiate mongocryptd manager/client once we know for sure\n    // that we are not using the CSFLE shared library.\n    if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {\n      this._mongocryptdManager = new MongocryptdManager(options.extraOptions);\n      const clientOptions: MongoClientOptions = {\n        serverSelectionTimeoutMS: 10000\n      };\n\n      if (\n        (options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== 'string') &&\n        !net.getDefaultAutoSelectFamily\n      ) {\n        // Only set family if autoSelectFamily options are not supported.\n        clientOptions.family = 4;\n      }\n\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore: TS complains as this always returns true on versions where it is present.\n      if (net.getDefaultAutoSelectFamily) {\n        // AutoEncrypter is made inside of MongoClient constructor while options are being parsed,\n        // we do not have access to the options that are in progress.\n        // TODO(NODE-6449): AutoEncrypter does not use client options for autoSelectFamily\n        Object.assign(clientOptions, autoSelectSocketOptions(this._client.s?.options ?? {}));\n      }\n\n      this._mongocryptdClient = new MongoClient(this._mongocryptdManager.uri, clientOptions);\n    }\n  }\n\n  /**\n   * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.\n   *\n   * This function is a no-op when bypassSpawn is set or the crypt shared library is used.\n   */\n  async init(): Promise<MongoClient | void> {\n    if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {\n      return;\n    }\n    if (!this._mongocryptdManager) {\n      throw new MongoRuntimeError(\n        'Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.'\n      );\n    }\n    if (!this._mongocryptdClient) {\n      throw new MongoRuntimeError(\n        'Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.'\n      );\n    }\n\n    if (!this._mongocryptdManager.bypassSpawn) {\n      await this._mongocryptdManager.spawn();\n    }\n\n    try {\n      const client = await this._mongocryptdClient.connect();\n      return client;\n    } catch (error) {\n      throw new MongoRuntimeError(\n        'Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn',\n        { cause: error }\n      );\n    }\n  }\n\n  /**\n   * Cleans up the `_mongocryptdClient`, if present.\n   */\n  async close(): Promise<void> {\n    await this._mongocryptdClient?.close();\n  }\n\n  /**\n   * Encrypt a command for a given namespace.\n   */\n  async encrypt(\n    ns: string,\n    cmd: Document,\n    options: CommandOptions & Abortable = {}\n  ): Promise<Document | Uint8Array> {\n    options.signal?.throwIfAborted();\n\n    if (this._bypassEncryption) {\n      // If `bypassAutoEncryption` has been specified, don't encrypt\n      return cmd;\n    }\n\n    const commandBuffer = Buffer.isBuffer(cmd) ? cmd : serialize(cmd, options);\n    const context = this._mongocrypt.makeEncryptionContext(\n      MongoDBCollectionNamespace.fromString(ns).db,\n      commandBuffer\n    );\n\n    context.id = this._contextCounter++;\n    context.ns = ns;\n    context.document = cmd;\n\n    const stateMachine = new StateMachine({\n      promoteValues: false,\n      promoteLongs: false,\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n\n    return deserialize(await stateMachine.execute(this, context, options), {\n      promoteValues: false,\n      promoteLongs: false\n    });\n  }\n\n  /**\n   * Decrypt a command response\n   */\n  async decrypt(\n    response: Uint8Array,\n    options: CommandOptions & Abortable = {}\n  ): Promise<Uint8Array> {\n    options.signal?.throwIfAborted();\n\n    const context = this._mongocrypt.makeDecryptionContext(response);\n\n    context.id = this._contextCounter++;\n\n    const stateMachine = new StateMachine({\n      ...options,\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions,\n      socketOptions: autoSelectSocketOptions(this._client.s.options)\n    });\n\n    return await stateMachine.execute(this, context, options);\n  }\n\n  /**\n   * Ask the user for KMS credentials.\n   *\n   * This returns anything that looks like the kmsProviders original input\n   * option. It can be empty, and any provider specified here will override\n   * the original ones.\n   */\n  async askForKMSCredentials(): Promise<KMSProviders> {\n    return await refreshKMSCredentials(this._kmsProviders, this._credentialProviders);\n  }\n\n  /**\n   * Return the current libmongocrypt's CSFLE shared library version\n   * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE\n   * shared library was loaded.\n   */\n  get cryptSharedLibVersionInfo(): { version: bigint; versionStr: string } | null {\n    return this._mongocrypt.cryptSharedLibVersionInfo;\n  }\n\n  static get libmongocryptVersion(): string {\n    return AutoEncrypter.getMongoCrypt().libmongocryptVersion;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}