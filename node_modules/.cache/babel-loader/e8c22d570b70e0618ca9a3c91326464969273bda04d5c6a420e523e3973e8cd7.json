{"ast":null,"code":"'use strict';\n\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n * @param {Schema} schema\n * @param {Object} [update]\n * @param {Object} [filter]\n * @param {String} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = Array.isArray(options?.arrayFilters) ? options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n  let startIndex = 0;\n  for (let i = 0; i < parts.length; ++i) {\n    const originalSubpath = parts.slice(startIndex, i + 1).join('.');\n    const subpath = cleanPositionalOperators(originalSubpath);\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath = discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n      const discriminatorKeyUpdatePath = originalSubpath + '.' + key;\n      if (discriminatorKeyUpdatePath in update) {\n        discriminatorKey = update[discriminatorKeyUpdatePath];\n      }\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => Object.hasOwn(filter, arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n      if (discriminatorKey == null) {\n        continue;\n      }\n      const discriminator = getDiscriminatorByValue(schematype.Constructor.discriminators, discriminatorKey);\n      const discriminatorSchema = discriminator?.schema;\n      if (discriminatorSchema == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      schema = discriminatorSchema;\n      startIndex = i + 1;\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n  return {\n    type: type,\n    schematype: schematype\n  };\n};","map":{"version":3,"names":["cleanPositionalOperators","require","get","getDiscriminatorByValue","updatedPathsByArrayFilter","module","exports","getEmbeddedDiscriminatorPath","schema","update","filter","path","options","parts","indexOf","split","schematype","type","arrayFilters","Array","isArray","updatedPathsByFilter","startIndex","i","length","originalSubpath","slice","join","subpath","pathType","$isSingleNested","$isMongooseDocumentArrayElement","discriminators","key","discriminatorValuePath","discriminatorFilterPath","replace","discriminatorKey","wrapperPath","$elemMatch","discriminatorKeyUpdatePath","filterKey","Object","keys","schemaKey","arrayFilterKey","find","hasOwn","discriminator","Constructor","discriminatorSchema","rest","_getPathType"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js"],"sourcesContent":["'use strict';\n\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n * @param {Schema} schema\n * @param {Object} [update]\n * @param {Object} [filter]\n * @param {String} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = Array.isArray(options?.arrayFilters) ?\n    options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n  let startIndex = 0;\n\n  for (let i = 0; i < parts.length; ++i) {\n    const originalSubpath = parts.slice(startIndex, i + 1).join('.');\n    const subpath = cleanPositionalOperators(originalSubpath);\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\n        schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath =\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement &&\n          get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n\n      const discriminatorKeyUpdatePath = originalSubpath + '.' + key;\n      if (discriminatorKeyUpdatePath in update) {\n        discriminatorKey = update[discriminatorKeyUpdatePath];\n      }\n\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => Object.hasOwn(filter, arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n\n      if (discriminatorKey == null) {\n        continue;\n      }\n\n      const discriminator = getDiscriminatorByValue(schematype.Constructor.discriminators, discriminatorKey);\n      const discriminatorSchema = discriminator?.schema;\n      if (discriminatorSchema == null) {\n        continue;\n      }\n\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      schema = discriminatorSchema;\n      startIndex = i + 1;\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return { type: type, schematype: schematype };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}