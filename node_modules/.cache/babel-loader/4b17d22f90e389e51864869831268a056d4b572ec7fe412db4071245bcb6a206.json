{"ast":null,"code":"'use strict';\n\nconst get = require('../get');\nconst helperIsObject = require('../isObject');\nconst decorateDiscriminatorIndexOptions = require('../indexes/decorateDiscriminatorIndexOptions');\n\n/**\n * Gather all indexes defined in the schema, including single nested,\n * document arrays, and embedded discriminators.\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function getIndexes(schema) {\n  let indexes = [];\n  const schemaStack = new WeakMap();\n  const indexTypes = schema.constructor.indexTypes;\n  const indexByName = new Map();\n  collectIndexes(schema);\n  return indexes;\n  function collectIndexes(schema, prefix, baseSchema) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.has(schema)) {\n      return;\n    }\n    schemaStack.set(schema, true);\n    prefix = prefix || '';\n    const keys = Object.keys(schema.paths);\n    for (const key of keys) {\n      const path = schema.paths[key];\n      if (baseSchema != null && baseSchema.paths[key]) {\n        // If looking at an embedded discriminator schema, don't look at paths\n        // that the\n        continue;\n      }\n      if (path._duplicateKeyErrorMessage != null) {\n        schema._duplicateKeyErrorMessagesByPath = schema._duplicateKeyErrorMessagesByPath || {};\n        schema._duplicateKeyErrorMessagesByPath[key] = path._duplicateKeyErrorMessage;\n      }\n      if (path.$isMongooseDocumentArray || path.$isSingleNested) {\n        if (get(path, 'options.excludeIndexes') !== true && get(path, 'schemaOptions.excludeIndexes') !== true && get(path, 'schema.options.excludeIndexes') !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n        if (path.schema.discriminators != null) {\n          const discriminators = path.schema.discriminators;\n          const discriminatorKeys = Object.keys(discriminators);\n          for (const discriminatorKey of discriminatorKeys) {\n            collectIndexes(discriminators[discriminatorKey], prefix + key + '.', path.schema);\n          }\n        }\n\n        // Retained to minimize risk of backwards breaking changes due to\n        // gh-6113\n        if (path.$isMongooseDocumentArray) {\n          continue;\n        }\n      }\n      const index = path._index || path.embeddedSchemaType && path.embeddedSchemaType._index;\n      if (index !== false && index != null) {\n        const field = {};\n        const isObject = helperIsObject(index);\n        const options = isObject ? {\n          ...index\n        } : {};\n        const type = typeof index === 'string' ? index : isObject ? index.type : false;\n        if (type && indexTypes.indexOf(type) !== -1) {\n          field[prefix + key] = type;\n        } else if (options.text) {\n          field[prefix + key] = 'text';\n          delete options.text;\n        } else {\n          let isDescendingIndex = false;\n          if (index === 'descending' || index === 'desc') {\n            isDescendingIndex = true;\n          } else if (index === 'ascending' || index === 'asc') {\n            isDescendingIndex = false;\n          } else {\n            isDescendingIndex = Number(index) === -1;\n          }\n          field[prefix + key] = isDescendingIndex ? -1 : 1;\n        }\n        delete options.type;\n        if (schema.options.autoIndex != null) {\n          options._autoIndex = schema.options.autoIndex;\n        }\n        const indexName = options?.name;\n        if (typeof indexName === 'string') {\n          if (indexByName.has(indexName)) {\n            Object.assign(indexByName.get(indexName), field);\n          } else {\n            indexes.push([field, options]);\n            indexByName.set(indexName, field);\n          }\n        } else {\n          indexes.push([field, options]);\n          indexByName.set(indexName, field);\n        }\n      }\n    }\n    schemaStack.delete(schema);\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function (index) {\n        const options = index[1];\n        decorateDiscriminatorIndexOptions(schema, options);\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  }\n\n  /**\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   * @param {Schema} schema\n   * @param {String} prefix\n   * @api private\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    const subindexes = schema._indexes;\n    const len = subindexes.length;\n    for (let i = 0; i < len; ++i) {\n      const indexObj = subindexes[i][0];\n      const indexOptions = subindexes[i][1];\n      const keys = Object.keys(indexObj);\n      const klen = keys.length;\n      const newindex = {};\n\n      // use forward iteration, order matters\n      for (let j = 0; j < klen; ++j) {\n        const key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n      const newIndexOptions = Object.assign({}, indexOptions);\n      if (indexOptions?.partialFilterExpression != null) {\n        newIndexOptions.partialFilterExpression = {};\n        const partialFilterExpression = indexOptions.partialFilterExpression;\n        for (const key of Object.keys(partialFilterExpression)) {\n          newIndexOptions.partialFilterExpression[prefix + key] = partialFilterExpression[key];\n        }\n      }\n      indexes.push([newindex, newIndexOptions]);\n    }\n  }\n};","map":{"version":3,"names":["get","require","helperIsObject","decorateDiscriminatorIndexOptions","module","exports","getIndexes","schema","indexes","schemaStack","WeakMap","indexTypes","constructor","indexByName","Map","collectIndexes","prefix","baseSchema","has","set","keys","Object","paths","key","path","_duplicateKeyErrorMessage","_duplicateKeyErrorMessagesByPath","$isMongooseDocumentArray","$isSingleNested","discriminators","discriminatorKeys","discriminatorKey","index","_index","embeddedSchemaType","field","isObject","options","type","indexOf","text","isDescendingIndex","Number","autoIndex","_autoIndex","indexName","name","assign","push","delete","fixSubIndexPaths","_indexes","forEach","concat","subindexes","len","length","i","indexObj","indexOptions","klen","newindex","j","newIndexOptions","partialFilterExpression"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/schema/getIndexes.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst helperIsObject = require('../isObject');\nconst decorateDiscriminatorIndexOptions = require('../indexes/decorateDiscriminatorIndexOptions');\n\n/**\n * Gather all indexes defined in the schema, including single nested,\n * document arrays, and embedded discriminators.\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function getIndexes(schema) {\n  let indexes = [];\n  const schemaStack = new WeakMap();\n  const indexTypes = schema.constructor.indexTypes;\n  const indexByName = new Map();\n\n  collectIndexes(schema);\n  return indexes;\n\n  function collectIndexes(schema, prefix, baseSchema) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.has(schema)) {\n      return;\n    }\n    schemaStack.set(schema, true);\n\n    prefix = prefix || '';\n    const keys = Object.keys(schema.paths);\n\n    for (const key of keys) {\n      const path = schema.paths[key];\n      if (baseSchema != null && baseSchema.paths[key]) {\n        // If looking at an embedded discriminator schema, don't look at paths\n        // that the\n        continue;\n      }\n\n      if (path._duplicateKeyErrorMessage != null) {\n        schema._duplicateKeyErrorMessagesByPath = schema._duplicateKeyErrorMessagesByPath || {};\n        schema._duplicateKeyErrorMessagesByPath[key] = path._duplicateKeyErrorMessage;\n      }\n\n      if (path.$isMongooseDocumentArray || path.$isSingleNested) {\n        if (get(path, 'options.excludeIndexes') !== true &&\n            get(path, 'schemaOptions.excludeIndexes') !== true &&\n            get(path, 'schema.options.excludeIndexes') !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n\n        if (path.schema.discriminators != null) {\n          const discriminators = path.schema.discriminators;\n          const discriminatorKeys = Object.keys(discriminators);\n          for (const discriminatorKey of discriminatorKeys) {\n            collectIndexes(discriminators[discriminatorKey],\n              prefix + key + '.', path.schema);\n          }\n        }\n\n        // Retained to minimize risk of backwards breaking changes due to\n        // gh-6113\n        if (path.$isMongooseDocumentArray) {\n          continue;\n        }\n      }\n\n      const index = path._index || (path.embeddedSchemaType && path.embeddedSchemaType._index);\n\n      if (index !== false && index != null) {\n        const field = {};\n        const isObject = helperIsObject(index);\n        const options = isObject ? { ...index } : {};\n        const type = typeof index === 'string' ? index :\n          isObject ? index.type :\n            false;\n\n        if (type && indexTypes.indexOf(type) !== -1) {\n          field[prefix + key] = type;\n        } else if (options.text) {\n          field[prefix + key] = 'text';\n          delete options.text;\n        } else {\n          let isDescendingIndex = false;\n          if (index === 'descending' || index === 'desc') {\n            isDescendingIndex = true;\n          } else if (index === 'ascending' || index === 'asc') {\n            isDescendingIndex = false;\n          } else {\n            isDescendingIndex = Number(index) === -1;\n          }\n\n          field[prefix + key] = isDescendingIndex ? -1 : 1;\n        }\n\n        delete options.type;\n        if (schema.options.autoIndex != null) {\n          options._autoIndex = schema.options.autoIndex;\n        }\n\n        const indexName = options?.name;\n\n        if (typeof indexName === 'string') {\n          if (indexByName.has(indexName)) {\n            Object.assign(indexByName.get(indexName), field);\n          } else {\n            indexes.push([field, options]);\n            indexByName.set(indexName, field);\n          }\n        } else {\n          indexes.push([field, options]);\n          indexByName.set(indexName, field);\n        }\n      }\n    }\n\n    schemaStack.delete(schema);\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function(index) {\n        const options = index[1];\n        decorateDiscriminatorIndexOptions(schema, options);\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  }\n\n  /**\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   * @param {Schema} schema\n   * @param {String} prefix\n   * @api private\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    const subindexes = schema._indexes;\n    const len = subindexes.length;\n    for (let i = 0; i < len; ++i) {\n      const indexObj = subindexes[i][0];\n      const indexOptions = subindexes[i][1];\n      const keys = Object.keys(indexObj);\n      const klen = keys.length;\n      const newindex = {};\n\n      // use forward iteration, order matters\n      for (let j = 0; j < klen; ++j) {\n        const key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      const newIndexOptions = Object.assign({}, indexOptions);\n      if (indexOptions?.partialFilterExpression != null) {\n        newIndexOptions.partialFilterExpression = {};\n        const partialFilterExpression = indexOptions.partialFilterExpression;\n        for (const key of Object.keys(partialFilterExpression)) {\n          newIndexOptions.partialFilterExpression[prefix + key] =\n            partialFilterExpression[key];\n        }\n      }\n\n      indexes.push([newindex, newIndexOptions]);\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}