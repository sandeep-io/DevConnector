{"ast":null,"code":"'use strict';\n\nconst castFilterPath = require('../query/castFilterPath');\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst getPath = require('../schema/getPath');\nconst updatedPathsByArrayFilter = require('./updatedPathsByArrayFilter');\nconst utils = require('../../utils');\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n  let strictQuery = schema.options.strict;\n  if (query._mongooseOptions.strict != null) {\n    strictQuery = query._mongooseOptions.strict;\n  }\n  if (query.model?.base.options.strictQuery != null) {\n    strictQuery = query.model.base.options.strictQuery;\n  }\n  if (schema._userProvidedOptions.strictQuery != null) {\n    strictQuery = schema._userProvidedOptions.strictQuery;\n  }\n  if (query._mongooseOptions.strictQuery != null) {\n    strictQuery = query._mongooseOptions.strictQuery;\n  }\n  _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);\n};\nfunction _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {\n  // Map to store discriminator values for embedded documents in the array filters.\n  // This is used to handle cases where array filters target specific embedded document types.\n  const discriminatorValueMap = {};\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    const keys = Object.keys(filter).filter(key => filter[key] != null);\n    if (keys.length === 0) {\n      continue;\n    }\n    const firstKey = keys[0];\n    if (firstKey === '$and' || firstKey === '$or') {\n      for (const key of keys) {\n        _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);\n      }\n      continue;\n    }\n    const dot = firstKey.indexOf('.');\n    const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);\n    if (updatedPathsByFilter[filterWildcardPath] == null) {\n      continue;\n    }\n    const baseFilterPath = cleanPositionalOperators(updatedPathsByFilter[filterWildcardPath]);\n    const baseSchematype = getPath(schema, baseFilterPath, discriminatorValueMap);\n    let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;\n    if (filterBaseSchema?.discriminators != null && filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]) {\n      filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;\n      discriminatorValueMap[baseFilterPath] = filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey];\n    }\n    for (const key of keys) {\n      if (updatedPathsByFilter[key] === null) {\n        continue;\n      }\n      if (utils.hasOwnKeys(updatedPathsByFilter) === false) {\n        continue;\n      }\n      const dot = key.indexOf('.');\n      let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);\n      let schematype;\n      if (filterPathRelativeToBase == null || filterBaseSchema == null) {\n        schematype = baseSchematype;\n      } else {\n        // If there are multiple array filters in the path being updated, make sure\n        // to replace them so we can get the schema path.\n        filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);\n        schematype = getPath(filterBaseSchema, filterPathRelativeToBase, discriminatorValueMap);\n      }\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        const filterPath = filterPathRelativeToBase == null ? baseFilterPath + '.0' : baseFilterPath + '.0' + filterPathRelativeToBase;\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(null, filter[key]);\n      }\n    }\n  }\n}","map":{"version":3,"names":["castFilterPath","require","cleanPositionalOperators","getPath","updatedPathsByArrayFilter","utils","module","exports","castArrayFilters","query","arrayFilters","options","Array","isArray","update","getUpdate","schema","updatedPathsByFilter","strictQuery","strict","_mongooseOptions","model","base","_userProvidedOptions","_castArrayFilters","discriminatorValueMap","filter","Error","keys","Object","key","length","firstKey","dot","indexOf","filterWildcardPath","substring","baseFilterPath","baseSchematype","filterBaseSchema","discriminators","discriminatorKey","hasOwnKeys","filterPathRelativeToBase","schematype","filterPath","castForQuery"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/update/castArrayFilters.js"],"sourcesContent":["'use strict';\n\nconst castFilterPath = require('../query/castFilterPath');\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst getPath = require('../schema/getPath');\nconst updatedPathsByArrayFilter = require('./updatedPathsByArrayFilter');\nconst utils = require('../../utils');\n\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  let strictQuery = schema.options.strict;\n  if (query._mongooseOptions.strict != null) {\n    strictQuery = query._mongooseOptions.strict;\n  }\n  if (query.model?.base.options.strictQuery != null) {\n    strictQuery = query.model.base.options.strictQuery;\n  }\n  if (schema._userProvidedOptions.strictQuery != null) {\n    strictQuery = schema._userProvidedOptions.strictQuery;\n  }\n  if (query._mongooseOptions.strictQuery != null) {\n    strictQuery = query._mongooseOptions.strictQuery;\n  }\n\n  _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);\n};\n\nfunction _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {\n  // Map to store discriminator values for embedded documents in the array filters.\n  // This is used to handle cases where array filters target specific embedded document types.\n  const discriminatorValueMap = {};\n\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    const keys = Object.keys(filter).filter(key => filter[key] != null);\n    if (keys.length === 0) {\n      continue;\n    }\n\n    const firstKey = keys[0];\n    if (firstKey === '$and' || firstKey === '$or') {\n      for (const key of keys) {\n        _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);\n      }\n      continue;\n    }\n    const dot = firstKey.indexOf('.');\n    const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);\n    if (updatedPathsByFilter[filterWildcardPath] == null) {\n      continue;\n    }\n    const baseFilterPath = cleanPositionalOperators(\n      updatedPathsByFilter[filterWildcardPath]\n    );\n\n    const baseSchematype = getPath(schema, baseFilterPath, discriminatorValueMap);\n    let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;\n    if (filterBaseSchema?.discriminators != null &&\n        filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]) {\n      filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;\n      discriminatorValueMap[baseFilterPath] = filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey];\n    }\n\n    for (const key of keys) {\n      if (updatedPathsByFilter[key] === null) {\n        continue;\n      }\n      if (utils.hasOwnKeys(updatedPathsByFilter) === false) {\n        continue;\n      }\n      const dot = key.indexOf('.');\n\n      let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);\n      let schematype;\n      if (filterPathRelativeToBase == null || filterBaseSchema == null) {\n        schematype = baseSchematype;\n      } else {\n        // If there are multiple array filters in the path being updated, make sure\n        // to replace them so we can get the schema path.\n        filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);\n        schematype = getPath(filterBaseSchema, filterPathRelativeToBase, discriminatorValueMap);\n      }\n\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        const filterPath = filterPathRelativeToBase == null ?\n          baseFilterPath + '.0' :\n          baseFilterPath + '.0' + filterPathRelativeToBase;\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(null, filter[key]);\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}