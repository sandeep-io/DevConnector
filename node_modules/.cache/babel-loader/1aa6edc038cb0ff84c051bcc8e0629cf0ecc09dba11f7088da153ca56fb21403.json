{"ast":null,"code":"/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/mongooseError');\nconst Readable = require('stream').Readable;\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst helpers = require('../queryHelpers');\nconst kareem = require('kareem');\nconst immediate = require('../helpers/immediate');\nconst {\n  once\n} = require('events');\nconst util = require('util');\n\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre `find` hooks before loading any documents\n * from MongoDB, and the model's post `find` hooks after loading each document.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor()) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction QueryCursor(query) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, {\n    autoDestroy: true,\n    objectMode: true\n  });\n  this.cursor = null;\n  this.skipped = false;\n  this.query = query;\n  this._closed = false;\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  this.model = model;\n  this.options = {};\n  const onPreComplete = err => {\n    if (err != null) {\n      if (err instanceof kareem.skipWrappedFunction) {\n        const resultValue = err.args[0];\n        if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {\n          const err = new MongooseError('Cannot `skipMiddlewareFunction()` with a value when using ' + '`.find().cursor()`, value must be nullish or empty array, got \"' + util.inspect(resultValue) + '\".');\n          this._markError(err);\n          this.listeners('error').length > 0 && this.emit('error', err);\n          return;\n        }\n        this.skipped = true;\n        this.emit('cursor', null);\n        return;\n      }\n      this._markError(err);\n      this.listeners('error').length > 0 && this.emit('error', err);\n      return;\n    }\n    Object.assign(this.options, query._optionsForExec());\n    this._transforms = this._transforms.concat(query._transforms.slice());\n    if (this.options.transform) {\n      this._transforms.push(this.options.transform);\n    }\n    // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n    // `batchSize` option doesn't work.\n    if (this.options.batchSize) {\n      // Max out the number of documents we'll populate in parallel at 5000.\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\n    }\n    if (query._mongooseOptions._asyncIterator) {\n      this._mongooseOptions._asyncIterator = true;\n    }\n    if (model.collection._shouldBufferCommands() && model.collection.buffer) {\n      model.collection.queue.push([() => _getRawCursor(query, this)]);\n    } else {\n      _getRawCursor(query, this);\n    }\n  };\n  model.hooks.execPre('find', query).then(() => onPreComplete(null), err => onPreComplete(err));\n}\nutil.inherits(QueryCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _getRawCursor(query, queryCursor) {\n  try {\n    const cursor = query.model.collection.find(query._conditions, queryCursor.options);\n    queryCursor.cursor = cursor;\n    queryCursor.emit('cursor', cursor);\n  } catch (err) {\n    queryCursor._markError(err);\n    queryCursor.listeners('error').length > 0 && queryCursor.emit('error', queryCursor._error);\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._read = function () {\n  _next(this, (error, doc) => {\n    if (error) {\n      return this.emit('error', error);\n    }\n    if (!doc) {\n      this.push(null);\n      this.cursor.close(function (error) {\n        if (error) {\n          return this.emit('error', error);\n        }\n      });\n      return;\n    }\n    this.push(doc);\n  });\n};\n\n/**\n * Returns the underlying cursor from the MongoDB Node driver that this cursor uses.\n *\n * @method getDriverCursor\n * @memberOf QueryCursor\n * @returns {Cursor} MongoDB Node driver cursor instance\n * @instance\n * @api public\n */\n\nQueryCursor.prototype.getDriverCursor = async function getDriverCursor() {\n  if (this.cursor) {\n    return this.cursor;\n  }\n  await once(this, 'cursor');\n  return this.cursor;\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @memberOf QueryCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(QueryCursor.prototype, 'map', {\n  value: function (fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._markError = function (error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nQueryCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n    this._closed = true;\n    this.emit('close');\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n};\n\n/**\n * Marks this cursor as destroyed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {this}\n * @api private\n * @method _destroy\n */\n\nQueryCursor.prototype._destroy = function _destroy(_err, callback) {\n  let waitForCursor = null;\n  if (!this.cursor) {\n    waitForCursor = new Promise(resolve => {\n      this.once('cursor', resolve);\n    });\n  } else {\n    waitForCursor = Promise.resolve();\n  }\n  waitForCursor.then(() => {\n    this.cursor.close();\n  }).then(() => {\n    this._closed = true;\n    callback();\n  }).catch(error => {\n    callback(error);\n  });\n  return this;\n};\n\n/**\n * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n * if the resultant data has already been retrieved by this cursor.\n *\n * @return {AggregationCursor} this\n * @api public\n * @method rewind\n */\n\nQueryCursor.prototype.rewind = function () {\n  _waitForCursor(this, () => {\n    this.cursor.rewind();\n  });\n  return this;\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nQueryCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.next() no longer accepts a callback');\n  }\n  if (this._closed) {\n    throw new MongooseError('Cannot call `next()` on a closed cursor');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, function (error, doc) {\n      if (error) {\n        return reject(error);\n      }\n      resolve(doc);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * #### Example:\n *\n *     // Iterate over documents asynchronously\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       eachAsync(async function (doc, i) {\n *         doc.foo = doc.bar + i;\n *         await doc.save();\n *       })\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nQueryCursor.prototype.eachAsync = function (fn, opts) {\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.eachAsync() no longer accepts a callback');\n  }\n  if (typeof opts === 'function') {\n    opts = {};\n  }\n  opts = opts || {};\n  return eachAsync(cb => _next(this, cb), fn, opts);\n};\n\n/**\n * The `options` passed in to the `QueryCursor` constructor.\n *\n * @api public\n * @property options\n */\n\nQueryCursor.prototype.options;\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nQueryCursor.prototype.addCursorFlag = function (flag, value) {\n  _waitForCursor(this, () => {\n    this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Works without using `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n *     // Can also use `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf QueryCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  QueryCursor.prototype[Symbol.asyncIterator] = function queryCursorAsyncIterator() {\n    // Set so QueryCursor knows it should transform results for async iterators into `{ value, done }` syntax\n    this._mongooseOptions._asyncIterator = true;\n    return this;\n  };\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n\n  // Create a custom callback to handle transforms, async iterator, and transformNull\n  callback = function (err, doc) {\n    if (err) {\n      return cb(err);\n    }\n\n    // Handle null documents - if asyncIterator, we need to return `done: true`, otherwise just\n    // skip. In either case, avoid transforms.\n    if (doc === null) {\n      if (ctx._mongooseOptions._asyncIterator) {\n        return cb(null, {\n          done: true\n        });\n      } else {\n        return cb(null, null);\n      }\n    }\n\n    // Apply transforms\n    if (ctx._transforms.length && doc !== null) {\n      doc = ctx._transforms.reduce(function (doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc);\n    }\n\n    // This option is set in `Symbol.asyncIterator` code paths.\n    // For async iterator, we need to convert to {value, done} format\n    if (ctx._mongooseOptions._asyncIterator) {\n      return cb(null, {\n        value: doc,\n        done: false\n      });\n    }\n    return cb(null, doc);\n  };\n  if (ctx._error) {\n    return immediate(function () {\n      callback(ctx._error);\n    });\n  }\n  if (ctx.skipped) {\n    return immediate(() => callback(null, null));\n  }\n  if (ctx.cursor) {\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query, ctx.query._mongooseOptions);\n      ctx._pop.__noPromise = true;\n    }\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\n      if (ctx._batchDocs && ctx._batchDocs.length) {\n        // Return a cached populated doc\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\n      } else if (ctx._batchExhausted) {\n        // Internal cursor reported no more docs. Act the same here\n        return callback(null, null);\n      } else {\n        // Request as many docs as batchSize, to populate them also in batch\n        ctx._batchDocs = [];\n        ctx.cursor.next().then(res => {\n          _onNext.call({\n            ctx,\n            callback\n          }, null, res);\n        }, err => {\n          _onNext.call({\n            ctx,\n            callback\n          }, err);\n        });\n        return;\n      }\n    } else {\n      return ctx.cursor.next().then(doc => {\n        if (!doc) {\n          callback(null, null);\n          return;\n        }\n        if (!ctx.query._mongooseOptions.populate) {\n          return _nextDoc(ctx, doc, null, callback);\n        }\n        _nextDoc(ctx, doc, ctx._pop, (err, doc) => {\n          if (err != null) {\n            return callback(err);\n          }\n          ctx.query.model.populate(doc, ctx._pop).then(doc => callback(null, doc), err => callback(err));\n        });\n      }, error => {\n        callback(error);\n      });\n    }\n  } else {\n    ctx.once('error', cb);\n    ctx.once('cursor', function (cursor) {\n      ctx.removeListener('error', cb);\n      if (cursor == null) {\n        if (ctx.skipped) {\n          return cb(null, null);\n        }\n        return;\n      }\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _onNext(error, doc) {\n  if (error) {\n    return this.callback(error);\n  }\n  if (!doc) {\n    this.ctx._batchExhausted = true;\n    return _populateBatch.call(this);\n  }\n  this.ctx._batchDocs.push(doc);\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\n    // cause a stack overflow. So make sure we clear the stack.\n    immediate(() => this.ctx.cursor.next().then(res => {\n      _onNext.call(this, null, res);\n    }, err => {\n      _onNext.call(this, err);\n    }));\n  } else {\n    _populateBatch.call(this);\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _populateBatch() {\n  if (!this.ctx._batchDocs.length) {\n    return this.callback(null, null);\n  }\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(() => {\n    _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);\n  }, err => {\n    this.callback(err);\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _nextDoc(ctx, doc, pop, callback) {\n  if (ctx.query._mongooseOptions.lean) {\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]]).then(() => callback(null, doc), err => callback(err));\n  }\n  const {\n    model,\n    _fields,\n    _userProvidedFields,\n    options\n  } = ctx.query;\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]]).then(() => callback(null, doc), err => callback(err));\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function (cursor) {\n    if (cursor == null) {\n      return;\n    }\n    cb();\n  });\n}\nmodule.exports = QueryCursor;","map":{"version":3,"names":["MongooseError","require","Readable","eachAsync","helpers","kareem","immediate","once","util","QueryCursor","query","call","autoDestroy","objectMode","cursor","skipped","_closed","model","_mongooseOptions","_transforms","options","onPreComplete","err","skipWrappedFunction","resultValue","args","Array","isArray","length","inspect","_markError","listeners","emit","Object","assign","_optionsForExec","concat","slice","transform","push","batchSize","_populateBatchSize","Math","min","_asyncIterator","collection","_shouldBufferCommands","buffer","queue","_getRawCursor","hooks","execPre","then","inherits","queryCursor","find","_conditions","_error","prototype","_read","_next","error","doc","close","getDriverCursor","defineProperty","value","fn","enumerable","configurable","writable","arguments","_destroy","_err","callback","waitForCursor","Promise","resolve","catch","rewind","_waitForCursor","next","reject","opts","cb","addCursorFlag","flag","Symbol","asyncIterator","queryCursorAsyncIterator","ctx","done","reduce","populate","_pop","preparePopulationOptionsMQ","__noPromise","_batchDocs","_nextDoc","shift","_batchExhausted","res","_onNext","removeListener","_populateBatch","pop","lean","execPost","_fields","_userProvidedFields","createModelAndInit","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/cursor/queryCursor.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/mongooseError');\nconst Readable = require('stream').Readable;\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst helpers = require('../queryHelpers');\nconst kareem = require('kareem');\nconst immediate = require('../helpers/immediate');\nconst { once } = require('events');\nconst util = require('util');\n\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre `find` hooks before loading any documents\n * from MongoDB, and the model's post `find` hooks after loading each document.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor()) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction QueryCursor(query) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.skipped = false;\n  this.query = query;\n  this._closed = false;\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  this.model = model;\n  this.options = {};\n\n  const onPreComplete = (err) => {\n    if (err != null) {\n      if (err instanceof kareem.skipWrappedFunction) {\n        const resultValue = err.args[0];\n        if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {\n          const err = new MongooseError(\n            'Cannot `skipMiddlewareFunction()` with a value when using ' +\n            '`.find().cursor()`, value must be nullish or empty array, got \"' +\n            util.inspect(resultValue) +\n            '\".'\n          );\n          this._markError(err);\n          this.listeners('error').length > 0 && this.emit('error', err);\n          return;\n        }\n        this.skipped = true;\n        this.emit('cursor', null);\n        return;\n      }\n      this._markError(err);\n      this.listeners('error').length > 0 && this.emit('error', err);\n      return;\n    }\n    Object.assign(this.options, query._optionsForExec());\n    this._transforms = this._transforms.concat(query._transforms.slice());\n    if (this.options.transform) {\n      this._transforms.push(this.options.transform);\n    }\n    // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n    // `batchSize` option doesn't work.\n    if (this.options.batchSize) {\n      // Max out the number of documents we'll populate in parallel at 5000.\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\n    }\n    if (query._mongooseOptions._asyncIterator) {\n      this._mongooseOptions._asyncIterator = true;\n    }\n\n    if (model.collection._shouldBufferCommands() && model.collection.buffer) {\n      model.collection.queue.push([\n        () => _getRawCursor(query, this)\n      ]);\n    } else {\n      _getRawCursor(query, this);\n    }\n  };\n\n  model.hooks.execPre('find', query).then(() => onPreComplete(null), err => onPreComplete(err));\n}\n\nutil.inherits(QueryCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _getRawCursor(query, queryCursor) {\n  try {\n    const cursor = query.model.collection.find(query._conditions, queryCursor.options);\n    queryCursor.cursor = cursor;\n    queryCursor.emit('cursor', cursor);\n  } catch (err) {\n    queryCursor._markError(err);\n    queryCursor.listeners('error').length > 0 && queryCursor.emit('error', queryCursor._error);\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._read = function() {\n  _next(this, (error, doc) => {\n    if (error) {\n      return this.emit('error', error);\n    }\n    if (!doc) {\n      this.push(null);\n      this.cursor.close(function(error) {\n        if (error) {\n          return this.emit('error', error);\n        }\n      });\n      return;\n    }\n    this.push(doc);\n  });\n};\n\n/**\n * Returns the underlying cursor from the MongoDB Node driver that this cursor uses.\n *\n * @method getDriverCursor\n * @memberOf QueryCursor\n * @returns {Cursor} MongoDB Node driver cursor instance\n * @instance\n * @api public\n */\n\nQueryCursor.prototype.getDriverCursor = async function getDriverCursor() {\n  if (this.cursor) {\n    return this.cursor;\n  }\n\n  await once(this, 'cursor');\n  return this.cursor;\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @memberOf QueryCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(QueryCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nQueryCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n    this._closed = true;\n    this.emit('close');\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n};\n\n/**\n * Marks this cursor as destroyed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {this}\n * @api private\n * @method _destroy\n */\n\nQueryCursor.prototype._destroy = function _destroy(_err, callback) {\n  let waitForCursor = null;\n  if (!this.cursor) {\n    waitForCursor = new Promise((resolve) => {\n      this.once('cursor', resolve);\n    });\n  } else {\n    waitForCursor = Promise.resolve();\n  }\n\n  waitForCursor\n    .then(() => {\n      this.cursor.close();\n    })\n    .then(() => {\n      this._closed = true;\n      callback();\n    })\n    .catch(error => {\n      callback(error);\n    });\n  return this;\n};\n\n/**\n * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n * if the resultant data has already been retrieved by this cursor.\n *\n * @return {AggregationCursor} this\n * @api public\n * @method rewind\n */\n\nQueryCursor.prototype.rewind = function() {\n  _waitForCursor(this, () => {\n    this.cursor.rewind();\n  });\n  return this;\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nQueryCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.next() no longer accepts a callback');\n  }\n  if (this._closed) {\n    throw new MongooseError('Cannot call `next()` on a closed cursor');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, function(error, doc) {\n      if (error) {\n        return reject(error);\n      }\n      resolve(doc);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * #### Example:\n *\n *     // Iterate over documents asynchronously\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       eachAsync(async function (doc, i) {\n *         doc.foo = doc.bar + i;\n *         await doc.save();\n *       })\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nQueryCursor.prototype.eachAsync = function(fn, opts) {\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.eachAsync() no longer accepts a callback');\n  }\n  if (typeof opts === 'function') {\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync((cb) => _next(this, cb), fn, opts);\n};\n\n/**\n * The `options` passed in to the `QueryCursor` constructor.\n *\n * @api public\n * @property options\n */\n\nQueryCursor.prototype.options;\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nQueryCursor.prototype.addCursorFlag = function(flag, value) {\n  _waitForCursor(this, () => {\n    this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Works without using `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n *     // Can also use `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf QueryCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  QueryCursor.prototype[Symbol.asyncIterator] = function queryCursorAsyncIterator() {\n    // Set so QueryCursor knows it should transform results for async iterators into `{ value, done }` syntax\n    this._mongooseOptions._asyncIterator = true;\n    return this;\n  };\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n\n  // Create a custom callback to handle transforms, async iterator, and transformNull\n  callback = function(err, doc) {\n    if (err) {\n      return cb(err);\n    }\n\n    // Handle null documents - if asyncIterator, we need to return `done: true`, otherwise just\n    // skip. In either case, avoid transforms.\n    if (doc === null) {\n      if (ctx._mongooseOptions._asyncIterator) {\n        return cb(null, { done: true });\n      } else {\n        return cb(null, null);\n      }\n    }\n\n    // Apply transforms\n    if (ctx._transforms.length && doc !== null) {\n      doc = ctx._transforms.reduce(function(doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc);\n    }\n\n    // This option is set in `Symbol.asyncIterator` code paths.\n    // For async iterator, we need to convert to {value, done} format\n    if (ctx._mongooseOptions._asyncIterator) {\n      return cb(null, { value: doc, done: false });\n    }\n\n    return cb(null, doc);\n  };\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n  if (ctx.skipped) {\n    return immediate(() => callback(null, null));\n  }\n\n  if (ctx.cursor) {\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query,\n        ctx.query._mongooseOptions);\n      ctx._pop.__noPromise = true;\n    }\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\n      if (ctx._batchDocs && ctx._batchDocs.length) {\n        // Return a cached populated doc\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\n      } else if (ctx._batchExhausted) {\n        // Internal cursor reported no more docs. Act the same here\n        return callback(null, null);\n      } else {\n        // Request as many docs as batchSize, to populate them also in batch\n        ctx._batchDocs = [];\n        ctx.cursor.next().then(\n          res => { _onNext.call({ ctx, callback }, null, res); },\n          err => { _onNext.call({ ctx, callback }, err); }\n        );\n        return;\n      }\n    } else {\n      return ctx.cursor.next().then(\n        doc => {\n          if (!doc) {\n            callback(null, null);\n            return;\n          }\n\n          if (!ctx.query._mongooseOptions.populate) {\n            return _nextDoc(ctx, doc, null, callback);\n          }\n\n          _nextDoc(ctx, doc, ctx._pop, (err, doc) => {\n            if (err != null) {\n              return callback(err);\n            }\n            ctx.query.model.populate(doc, ctx._pop).then(\n              doc => callback(null, doc),\n              err => callback(err)\n            );\n          });\n        },\n        error => {\n          callback(error);\n        }\n      );\n    }\n  } else {\n    ctx.once('error', cb);\n\n    ctx.once('cursor', function(cursor) {\n      ctx.removeListener('error', cb);\n      if (cursor == null) {\n        if (ctx.skipped) {\n          return cb(null, null);\n        }\n        return;\n      }\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _onNext(error, doc) {\n  if (error) {\n    return this.callback(error);\n  }\n  if (!doc) {\n    this.ctx._batchExhausted = true;\n    return _populateBatch.call(this);\n  }\n\n  this.ctx._batchDocs.push(doc);\n\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\n    // cause a stack overflow. So make sure we clear the stack.\n    immediate(() => this.ctx.cursor.next().then(\n      res => { _onNext.call(this, null, res); },\n      err => { _onNext.call(this, err); }\n    ));\n  } else {\n    _populateBatch.call(this);\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _populateBatch() {\n  if (!this.ctx._batchDocs.length) {\n    return this.callback(null, null);\n  }\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(\n    () => {\n      _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);\n    },\n    err => {\n      this.callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _nextDoc(ctx, doc, pop, callback) {\n  if (ctx.query._mongooseOptions.lean) {\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]]).then(() => callback(null, doc), err => callback(err));\n  }\n\n  const { model, _fields, _userProvidedFields, options } = ctx.query;\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]]).then(() => callback(null, doc), err => callback(err));\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function(cursor) {\n    if (cursor == null) {\n      return;\n    }\n    cb();\n  });\n}\n\nmodule.exports = QueryCursor;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}