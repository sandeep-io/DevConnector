{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../error/mongooseError');\nconst clone = require('../helpers/clone');\nconst deepEqual = require('../utils').deepEqual;\nconst getConstructorName = require('../helpers/getConstructorName');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst util = require('util');\nconst specialProperties = require('../helpers/specialProperties');\nconst isBsonType = require('../helpers/isBsonType');\nconst cleanModifiedSubpaths = require('../helpers/document/cleanModifiedSubpaths');\nconst populateModelSymbol = require('../helpers/symbols').populateModelSymbol;\n\n/*!\n * ignore\n */\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType, options) {\n    if (getConstructorName(v) === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n    super(v);\n    this.$__parent = doc?.$__ != null ? doc : null;\n\n    // Calculate the full path from the root document\n    // Priority: parent.$basePath (from subdoc) > options.path (from parent map/structure) > path (schema path)\n    // Subdocuments have the most up-to-date path info, so prefer that over options.path\n    if (this.$__parent?.$isSingleNested && this.$__parent.$basePath) {\n      this.$__path = this.$__parent.$basePath + '.' + path;\n      // Performance optimization: store path relative to parent subdocument\n      // to avoid string operations in set() hot path\n      this.$__pathRelativeToParent = path;\n    } else if (options?.path) {\n      this.$__path = options.path;\n      this.$__pathRelativeToParent = null;\n    } else {\n      this.$__path = path;\n      this.$__pathRelativeToParent = null;\n    }\n    this.$__schemaType = schemaType;\n    this.$__runDeferred();\n  }\n  $init(key, value) {\n    checkValidKey(key);\n    super.set(key, value);\n    if (value?.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n      // Store the path relative to parent subdoc for efficient markModified()\n      if (this.$__pathRelativeToParent != null) {\n        // Map's parent is a subdocument, store path relative to that subdoc\n        value.$pathRelativeToParent = this.$__pathRelativeToParent + '.' + key;\n      } else {\n        // Map's parent is root document, store the full path\n        value.$pathRelativeToParent = this.$__path + '.' + key;\n      }\n    }\n  }\n  $__set(key, value) {\n    super.set(key, value);\n  }\n\n  /**\n   * Overwrites native Map's `get()` function to support Mongoose getters.\n   *\n   * @api public\n   * @method get\n   * @memberOf Map\n   */\n\n  get(key, options) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n    options = options || {};\n    if (options.getters === false) {\n      return super.get(key);\n    }\n    return this.$__schemaType.applyGetters(super.get(key), this.$__parent);\n  }\n\n  /**\n   * Overwrites native Map's `set()` function to support setters, `populate()`,\n   * and change tracking. Note that Mongoose maps _only_ support strings and\n   * ObjectIds as keys.\n   *\n   * Keys also cannot:\n   * - be named after special properties `prototype`, `constructor`, and `__proto__`\n   * - start with a dollar sign (`$`)\n   * - contain any dots (`.`)\n   *\n   * #### Example:\n   *\n   *     doc.myMap.set('test', 42); // works\n   *     doc.myMap.set({ obj: 42 }, 42); // Throws \"Mongoose maps only support string keys\"\n   *     doc.myMap.set(10, 42); // Throws \"Mongoose maps only support string keys\"\n   *     doc.myMap.set(\"$test\", 42); // Throws \"Mongoose maps do not support keys that start with \"$\", got \"$test\"\"\n   *\n   * @api public\n   * @method set\n   * @memberOf Map\n   */\n\n  set(key, value) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n    checkValidKey(key);\n    value = handleSpreadDoc(value);\n\n    // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({\n        key: key,\n        value: value\n      });\n      return;\n    }\n    let _fullPath;\n    const parent = this.$__parent;\n    const populated = parent?.$__?.populated ? parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) : null;\n    const priorVal = this.get(key);\n    if (populated != null) {\n      if (this.$__schemaType.$isSingleNested) {\n        throw new MongooseError('Cannot manually populate single nested subdoc underneath Map ' + `at path \"${this.$__path}\". Try using an array instead of a Map.`);\n      }\n      if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {\n        value = value.map(v => {\n          if (v.$__ == null) {\n            v = new populated.options[populateModelSymbol](v);\n          }\n          // Doesn't support single nested \"in-place\" populate\n          v.$__.wasPopulated = {\n            value: v._doc._id\n          };\n          return v;\n        });\n      } else if (value != null) {\n        if (value.$__ == null) {\n          value = new populated.options[populateModelSymbol](value);\n        }\n        // Doesn't support single nested \"in-place\" populate\n        value.$__.wasPopulated = {\n          value: value._doc._id\n        };\n      }\n    } else {\n      try {\n        let options = null;\n        if (this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested || this.$__schemaType.$isMongooseArray || this.$__schemaType.$isSchemaMap) {\n          options = {\n            path: fullPath.call(this)\n          };\n          // For subdocuments, also pass the relative path to avoid string operations\n          if (this.$__schemaType.$isSingleNested) {\n            options.pathRelativeToParent = this.$__pathRelativeToParent != null ? this.$__pathRelativeToParent + '.' + key : this.$__path + '.' + key;\n          }\n        }\n        value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key), options);\n      } catch (error) {\n        if (this.$__parent?.$__ != null) {\n          this.$__parent.invalidate(fullPath.call(this), error);\n          return;\n        }\n        throw error;\n      }\n    }\n    super.set(key, value);\n\n    // Set relative path on subdocuments to avoid string operations in markModified()\n    // The path should be relative to the parent subdocument (if any), not just the key\n    if (value?.$isSingleNested) {\n      if (this.$__pathRelativeToParent != null) {\n        // Map's parent is a subdocument, store path relative to that subdoc (e.g., 'items.i2')\n        value.$pathRelativeToParent = this.$__pathRelativeToParent + '.' + key;\n      } else {\n        // Map's parent is root document, store just the full path\n        value.$pathRelativeToParent = this.$__path + '.' + key;\n      }\n    }\n    if (parent?.$__ != null && !deepEqual(value, priorVal)) {\n      // Optimization: if parent is a subdocument, use precalculated relative path\n      // to avoid building a full path just to strip the parent's prefix\n      let pathToMark;\n      if (this.$__pathRelativeToParent != null) {\n        // Parent is a subdocument - use precalculated relative path (e.g., 'items.i1')\n        pathToMark = this.$__pathRelativeToParent + '.' + key;\n      } else {\n        // Parent is root document or map - use full path\n        pathToMark = fullPath.call(this);\n      }\n      parent.markModified(pathToMark);\n      // If overwriting the full document array or subdoc, make sure to clean up any paths that were modified\n      // before re: #15108\n      if (this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested) {\n        cleanModifiedSubpaths(parent, pathToMark);\n      }\n    }\n\n    // Delay calculating full path unless absolutely necessary, because string\n    // concatenation is a bottleneck re: #13171\n    function fullPath() {\n      if (_fullPath) {\n        return _fullPath;\n      }\n      _fullPath = this.$__path + '.' + key;\n      return _fullPath;\n    }\n  }\n\n  /**\n   * Overwrites native Map's `clear()` function to support change tracking.\n   *\n   * @api public\n   * @method clear\n   * @memberOf Map\n   */\n\n  clear() {\n    super.clear();\n    const parent = this.$__parent;\n    if (parent != null) {\n      parent.markModified(this.$__path);\n    }\n  }\n\n  /**\n   * Overwrites native Map's `delete()` function to support change tracking.\n   *\n   * @api public\n   * @method delete\n   * @memberOf Map\n   */\n\n  delete(key) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n    this.set(key, undefined);\n    return super.delete(key);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map so the MongoDB driver can serialize it.\n   *\n   * @api public\n   * @method toBSON\n   * @memberOf Map\n   */\n\n  toBSON() {\n    return new Map(this);\n  }\n  toObject(options) {\n    if (options?.flattenMaps) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n    return new Map(this);\n  }\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map for `JSON.stringify()`. Set\n   * the `flattenMaps` option to convert this map to a POJO instead.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.toJSON() instanceof Map; // true\n   *     doc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false\n   *\n   * @api public\n   * @method toJSON\n   * @param {Object} [options]\n   * @param {Boolean} [options.flattenMaps=false] set to `true` to convert the map to a POJO rather than a native JavaScript map\n   * @memberOf Map\n   */\n\n  toJSON(options) {\n    if (typeof options?.flattenMaps === 'boolean' ? options.flattenMaps : true) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n    return new Map(this);\n  }\n  inspect() {\n    return new Map(this);\n  }\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n    for (const keyValueObject of this.$__deferred) {\n      this.set(keyValueObject.key, keyValueObject.value);\n    }\n    this.$__deferred = null;\n  }\n}\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\nObject.defineProperty(MongooseMap.prototype, '$__set', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\n/**\n * Set to `true` for all Mongoose map instances\n *\n * @api public\n * @property $isMongooseMap\n * @memberOf MongooseMap\n * @instance\n */\n\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\n/**\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n * @param {String} key\n * @api private\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n  if (keyType !== 'string') {\n    throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);\n  }\n  if (key.startsWith('$')) {\n    throw new Error(`Mongoose maps do not support keys that start with \"$\", got \"${key}\"`);\n  }\n  if (key.includes('.')) {\n    throw new Error(`Mongoose maps do not support keys that contain \".\", got \"${key}\"`);\n  }\n  if (specialProperties.has(key)) {\n    throw new Error(`Mongoose maps do not support reserved key name \"${key}\"`);\n  }\n}\nmodule.exports = MongooseMap;","map":{"version":3,"names":["MongooseError","require","clone","deepEqual","getConstructorName","handleSpreadDoc","util","specialProperties","isBsonType","cleanModifiedSubpaths","populateModelSymbol","MongooseMap","Map","constructor","v","path","doc","schemaType","options","Object","keys","reduce","arr","key","concat","$__parent","$__","$isSingleNested","$basePath","$__path","$__pathRelativeToParent","$__schemaType","$__runDeferred","$init","value","checkValidKey","set","$pathRelativeToParent","$__set","get","toString","getters","applyGetters","$__deferred","push","_fullPath","parent","populated","$populated","fullPath","call","priorVal","Array","isArray","$isMongooseArray","map","wasPopulated","_doc","_id","$isMongooseDocumentArray","$isSchemaMap","pathRelativeToParent","applySetters","error","invalidate","pathToMark","markModified","clear","delete","undefined","toBSON","toObject","flattenMaps","ret","$toObject","prototype","apply","arguments","toJSON","inspect","keyValueObject","custom","defineProperty","enumerable","writable","configurable","keyType","TypeError","startsWith","Error","includes","has","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/types/map.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../error/mongooseError');\nconst clone = require('../helpers/clone');\nconst deepEqual = require('../utils').deepEqual;\nconst getConstructorName = require('../helpers/getConstructorName');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst util = require('util');\nconst specialProperties = require('../helpers/specialProperties');\nconst isBsonType = require('../helpers/isBsonType');\nconst cleanModifiedSubpaths = require('../helpers/document/cleanModifiedSubpaths');\n\nconst populateModelSymbol = require('../helpers/symbols').populateModelSymbol;\n\n/*!\n * ignore\n */\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType, options) {\n    if (getConstructorName(v) === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n    super(v);\n    this.$__parent = doc?.$__ != null ? doc : null;\n\n    // Calculate the full path from the root document\n    // Priority: parent.$basePath (from subdoc) > options.path (from parent map/structure) > path (schema path)\n    // Subdocuments have the most up-to-date path info, so prefer that over options.path\n    if (this.$__parent?.$isSingleNested && this.$__parent.$basePath) {\n      this.$__path = this.$__parent.$basePath + '.' + path;\n      // Performance optimization: store path relative to parent subdocument\n      // to avoid string operations in set() hot path\n      this.$__pathRelativeToParent = path;\n    } else if (options?.path) {\n      this.$__path = options.path;\n      this.$__pathRelativeToParent = null;\n    } else {\n      this.$__path = path;\n      this.$__pathRelativeToParent = null;\n    }\n\n    this.$__schemaType = schemaType;\n\n    this.$__runDeferred();\n  }\n\n  $init(key, value) {\n    checkValidKey(key);\n\n    super.set(key, value);\n\n    if (value?.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n      // Store the path relative to parent subdoc for efficient markModified()\n      if (this.$__pathRelativeToParent != null) {\n        // Map's parent is a subdocument, store path relative to that subdoc\n        value.$pathRelativeToParent = this.$__pathRelativeToParent + '.' + key;\n      } else {\n        // Map's parent is root document, store the full path\n        value.$pathRelativeToParent = this.$__path + '.' + key;\n      }\n    }\n  }\n\n  $__set(key, value) {\n    super.set(key, value);\n  }\n\n  /**\n   * Overwrites native Map's `get()` function to support Mongoose getters.\n   *\n   * @api public\n   * @method get\n   * @memberOf Map\n   */\n\n  get(key, options) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    options = options || {};\n    if (options.getters === false) {\n      return super.get(key);\n    }\n    return this.$__schemaType.applyGetters(super.get(key), this.$__parent);\n  }\n\n  /**\n   * Overwrites native Map's `set()` function to support setters, `populate()`,\n   * and change tracking. Note that Mongoose maps _only_ support strings and\n   * ObjectIds as keys.\n   *\n   * Keys also cannot:\n   * - be named after special properties `prototype`, `constructor`, and `__proto__`\n   * - start with a dollar sign (`$`)\n   * - contain any dots (`.`)\n   *\n   * #### Example:\n   *\n   *     doc.myMap.set('test', 42); // works\n   *     doc.myMap.set({ obj: 42 }, 42); // Throws \"Mongoose maps only support string keys\"\n   *     doc.myMap.set(10, 42); // Throws \"Mongoose maps only support string keys\"\n   *     doc.myMap.set(\"$test\", 42); // Throws \"Mongoose maps do not support keys that start with \"$\", got \"$test\"\"\n   *\n   * @api public\n   * @method set\n   * @memberOf Map\n   */\n\n  set(key, value) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    checkValidKey(key);\n    value = handleSpreadDoc(value);\n\n    // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({ key: key, value: value });\n      return;\n    }\n\n    let _fullPath;\n    const parent = this.$__parent;\n    const populated = parent?.$__?.populated ?\n      parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) :\n      null;\n    const priorVal = this.get(key);\n\n    if (populated != null) {\n      if (this.$__schemaType.$isSingleNested) {\n        throw new MongooseError(\n          'Cannot manually populate single nested subdoc underneath Map ' +\n          `at path \"${this.$__path}\". Try using an array instead of a Map.`\n        );\n      }\n      if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {\n        value = value.map(v => {\n          if (v.$__ == null) {\n            v = new populated.options[populateModelSymbol](v);\n          }\n          // Doesn't support single nested \"in-place\" populate\n          v.$__.wasPopulated = { value: v._doc._id };\n          return v;\n        });\n      } else if (value != null) {\n        if (value.$__ == null) {\n          value = new populated.options[populateModelSymbol](value);\n        }\n        // Doesn't support single nested \"in-place\" populate\n        value.$__.wasPopulated = { value: value._doc._id };\n      }\n    } else {\n      try {\n        let options = null;\n        if (this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested || this.$__schemaType.$isMongooseArray || this.$__schemaType.$isSchemaMap) {\n          options = { path: fullPath.call(this) };\n          // For subdocuments, also pass the relative path to avoid string operations\n          if (this.$__schemaType.$isSingleNested) {\n            options.pathRelativeToParent = this.$__pathRelativeToParent != null ?\n              this.$__pathRelativeToParent + '.' + key :\n              this.$__path + '.' + key;\n          }\n        }\n        value = this.$__schemaType.applySetters(\n          value,\n          this.$__parent,\n          false,\n          this.get(key),\n          options\n        );\n      } catch (error) {\n        if (this.$__parent?.$__ != null) {\n          this.$__parent.invalidate(fullPath.call(this), error);\n          return;\n        }\n        throw error;\n      }\n    }\n\n    super.set(key, value);\n\n    // Set relative path on subdocuments to avoid string operations in markModified()\n    // The path should be relative to the parent subdocument (if any), not just the key\n    if (value?.$isSingleNested) {\n      if (this.$__pathRelativeToParent != null) {\n        // Map's parent is a subdocument, store path relative to that subdoc (e.g., 'items.i2')\n        value.$pathRelativeToParent = this.$__pathRelativeToParent + '.' + key;\n      } else {\n        // Map's parent is root document, store just the full path\n        value.$pathRelativeToParent = this.$__path + '.' + key;\n      }\n    }\n\n    if (parent?.$__ != null && !deepEqual(value, priorVal)) {\n      // Optimization: if parent is a subdocument, use precalculated relative path\n      // to avoid building a full path just to strip the parent's prefix\n      let pathToMark;\n      if (this.$__pathRelativeToParent != null) {\n        // Parent is a subdocument - use precalculated relative path (e.g., 'items.i1')\n        pathToMark = this.$__pathRelativeToParent + '.' + key;\n      } else {\n        // Parent is root document or map - use full path\n        pathToMark = fullPath.call(this);\n      }\n      parent.markModified(pathToMark);\n      // If overwriting the full document array or subdoc, make sure to clean up any paths that were modified\n      // before re: #15108\n      if (this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested) {\n        cleanModifiedSubpaths(parent, pathToMark);\n      }\n    }\n\n    // Delay calculating full path unless absolutely necessary, because string\n    // concatenation is a bottleneck re: #13171\n    function fullPath() {\n      if (_fullPath) {\n        return _fullPath;\n      }\n      _fullPath = this.$__path + '.' + key;\n      return _fullPath;\n    }\n  }\n\n  /**\n   * Overwrites native Map's `clear()` function to support change tracking.\n   *\n   * @api public\n   * @method clear\n   * @memberOf Map\n   */\n\n  clear() {\n    super.clear();\n    const parent = this.$__parent;\n    if (parent != null) {\n      parent.markModified(this.$__path);\n    }\n  }\n\n  /**\n   * Overwrites native Map's `delete()` function to support change tracking.\n   *\n   * @api public\n   * @method delete\n   * @memberOf Map\n   */\n\n  delete(key) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    this.set(key, undefined);\n    return super.delete(key);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map so the MongoDB driver can serialize it.\n   *\n   * @api public\n   * @method toBSON\n   * @memberOf Map\n   */\n\n  toBSON() {\n    return new Map(this);\n  }\n\n  toObject(options) {\n    if (options?.flattenMaps) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map for `JSON.stringify()`. Set\n   * the `flattenMaps` option to convert this map to a POJO instead.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.toJSON() instanceof Map; // true\n   *     doc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false\n   *\n   * @api public\n   * @method toJSON\n   * @param {Object} [options]\n   * @param {Boolean} [options.flattenMaps=false] set to `true` to convert the map to a POJO rather than a native JavaScript map\n   * @memberOf Map\n   */\n\n  toJSON(options) {\n    if (typeof options?.flattenMaps === 'boolean' ? options.flattenMaps : true) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  inspect() {\n    return new Map(this);\n  }\n\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n\n    for (const keyValueObject of this.$__deferred) {\n      this.set(keyValueObject.key, keyValueObject.value);\n    }\n\n    this.$__deferred = null;\n  }\n}\n\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\n\nObject.defineProperty(MongooseMap.prototype, '$__set', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\n/**\n * Set to `true` for all Mongoose map instances\n *\n * @api public\n * @property $isMongooseMap\n * @memberOf MongooseMap\n * @instance\n */\n\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\n/**\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n * @param {String} key\n * @api private\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n  if (keyType !== 'string') {\n    throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);\n  }\n  if (key.startsWith('$')) {\n    throw new Error(`Mongoose maps do not support keys that start with \"$\", got \"${key}\"`);\n  }\n  if (key.includes('.')) {\n    throw new Error(`Mongoose maps do not support keys that contain \".\", got \"${key}\"`);\n  }\n  if (specialProperties.has(key)) {\n    throw new Error(`Mongoose maps do not support reserved key name \"${key}\"`);\n  }\n}\n\nmodule.exports = MongooseMap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}