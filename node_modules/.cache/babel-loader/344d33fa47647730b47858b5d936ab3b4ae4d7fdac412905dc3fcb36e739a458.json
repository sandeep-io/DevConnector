{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies\n */\nconst PopulateOptions = require('./options/populateOptions');\nconst checkEmbeddedDiscriminatorKeyProjection = require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.filter(p => p?.options?.lean == null).forEach(makeLean(options.lean));\n  }\n  const session = query?.options?.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = {\n          session: session\n        };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n  const projection = query._fieldsForExec();\n  for (let i = 0; i < pop.length; ++i) {\n    if (pop[i] instanceof PopulateOptions) {\n      pop[i] = new PopulateOptions({\n        ...pop[i],\n        _queryProjection: projection,\n        _localModel: query.model\n      });\n    } else {\n      pop[i]._queryProjection = projection;\n      pop[i]._localModel = query.model;\n    }\n  }\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;\n  const key = discriminatorMapping?.isRoot ? discriminatorMapping.key : null;\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, {\n        skipId: true\n      });\n    }\n  }\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ? {\n    populated: populatedIds\n  } : undefined;\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema, sanitizeProjection) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if (!type?.selected || exclude !== false) {\n        fields[path] = 0;\n        exclude = true;\n      } else if (type?.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema?.paths['_id']?.options?.select === false) {\n        fields._id = 0;\n      }\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n    const addedPaths = [];\n    schema.eachPath(function (path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options?.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.embeddedSchemaType);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      if (sanitizeProjection) {\n        fields[path] = 0;\n      }\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path) && !sanitizeProjection) {\n        fields[path] = 1;\n      } else if (exclude == null && sanitizeProjection && type.selected === false) {\n        fields[path] = 0;\n      }\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type?.options?.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function (option) {\n    option.options || (option.options = {});\n    if (Array.isArray(val?.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).map(path => path.slice(option.path.length + 1));\n    }\n    option.options.lean = val;\n  };\n}","map":{"version":3,"names":["PopulateOptions","require","checkEmbeddedDiscriminatorKeyProjection","get","getDiscriminatorByValue","isDefiningProjection","clone","isPathSelectedInclusive","exports","preparePopulationOptionsMQ","query","options","_populate","_mongooseOptions","populate","pop","Object","keys","reduce","vals","key","concat","lean","filter","p","forEach","makeLean","session","path","projection","_fieldsForExec","i","length","_queryProjection","_localModel","model","createModel","doc","fields","userProvidedFields","hooks","execPreSync","discriminatorMapping","schema","isRoot","value","discriminators","discriminator","_fields","applyPaths","undefined","skipId","_opts","isNew","willInit","defaults","createModelAndInit","populatedIds","callback","initOpts","populated","casted","$init","error","sanitizeProjection","exclude","minusPathsToSkip","Set","minusPaths","push","slice","keyIndex","field","discriminatorKey","type","selected","add","excluded","stack","analyzeSchema","fieldName","paths","select","_id","has","startsWith","prefix","indexOf","addedPaths","eachPath","$isSchemaMap","endsWith","plusPath","hasPlusPath","addedPath","analyzePath","Array","isArray","$isMongooseArray","$isMongooseDocumentArray","embeddedSchemaType","_addedPaths","pieces","split","cur","$skipDiscriminatorCheck","val","option","virtuals","assign","map"],"sources":["C:/DEVC/node_modules/mongoose/lib/queryHelpers.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst PopulateOptions = require('./options/populateOptions');\nconst checkEmbeddedDiscriminatorKeyProjection =\n  require('./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection');\nconst get = require('./helpers/get');\nconst getDiscriminatorByValue =\n  require('./helpers/discriminator/getDiscriminatorByValue');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst clone = require('./helpers/clone');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => p?.options?.lean == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  const session = query?.options?.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  for (let i = 0; i < pop.length; ++i) {\n    if (pop[i] instanceof PopulateOptions) {\n      pop[i] = new PopulateOptions({\n        ...pop[i],\n        _queryProjection: projection,\n        _localModel: query.model\n      });\n    } else {\n      pop[i]._queryProjection = projection;\n      pop[i]._localModel = query.model;\n    }\n  }\n\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping?.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, { skipId: true });\n    }\n  }\n\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ?\n    { populated: populatedIds } :\n    undefined;\n\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema, sanitizeProjection) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if (!type?.selected || exclude !== false) {\n        fields[path] = 0;\n        exclude = true;\n      } else if (type?.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema?.paths['_id']?.options?.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options?.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.embeddedSchemaType);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      if (sanitizeProjection) {\n        fields[path] = 0;\n      }\n\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path) && !sanitizeProjection) {\n        fields[path] = 1;\n      } else if (exclude == null && sanitizeProjection && type.selected === false) {\n        fields[path] = 0;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type?.options?.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (Array.isArray(val?.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AAEA,MAAMA,eAAe,GAAGC,OAAO,CAAC,2BAA2B,CAAC;AAC5D,MAAMC,uCAAuC,GAC3CD,OAAO,CAAC,iEAAiE,CAAC;AAC5E,MAAME,GAAG,GAAGF,OAAO,CAAC,eAAe,CAAC;AACpC,MAAMG,uBAAuB,GAC3BH,OAAO,CAAC,iDAAiD,CAAC;AAC5D,MAAMI,oBAAoB,GAAGJ,OAAO,CAAC,2CAA2C,CAAC;AACjF,MAAMK,KAAK,GAAGL,OAAO,CAAC,iBAAiB,CAAC;AACxC,MAAMM,uBAAuB,GAAGN,OAAO,CAAC,8CAA8C,CAAC;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAO,OAAO,CAACC,0BAA0B,GAAG,SAASA,0BAA0BA,CAACC,KAAK,EAAEC,OAAO,EAAE;EACvF,MAAMC,SAAS,GAAGF,KAAK,CAACG,gBAAgB,CAACC,QAAQ;EACjD,MAAMC,GAAG,GAAGC,MAAM,CAACC,IAAI,CAACL,SAAS,CAAC,CAACM,MAAM,CAAC,CAACC,IAAI,EAAEC,GAAG,KAAKD,IAAI,CAACE,MAAM,CAAC,CAACT,SAAS,CAACQ,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;;EAE3F;EACA,IAAIT,OAAO,CAACW,IAAI,IAAI,IAAI,EAAE;IACxBP,GAAG,CACAQ,MAAM,CAACC,CAAC,IAAIA,CAAC,EAAEb,OAAO,EAAEW,IAAI,IAAI,IAAI,CAAC,CACrCG,OAAO,CAACC,QAAQ,CAACf,OAAO,CAACW,IAAI,CAAC,CAAC;EACpC;EAEA,MAAMK,OAAO,GAAGjB,KAAK,EAAEC,OAAO,EAAEgB,OAAO,IAAI,IAAI;EAC/C,IAAIA,OAAO,IAAI,IAAI,EAAE;IACnBZ,GAAG,CAACU,OAAO,CAACG,IAAI,IAAI;MAClB,IAAIA,IAAI,CAACjB,OAAO,IAAI,IAAI,EAAE;QACxBiB,IAAI,CAACjB,OAAO,GAAG;UAAEgB,OAAO,EAAEA;QAAQ,CAAC;QACnC;MACF;MACA,IAAI,EAAE,SAAS,IAAIC,IAAI,CAACjB,OAAO,CAAC,EAAE;QAChCiB,IAAI,CAACjB,OAAO,CAACgB,OAAO,GAAGA,OAAO;MAChC;IACF,CAAC,CAAC;EACJ;EAEA,MAAME,UAAU,GAAGnB,KAAK,CAACoB,cAAc,CAAC,CAAC;EACzC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,GAAG,CAACiB,MAAM,EAAE,EAAED,CAAC,EAAE;IACnC,IAAIhB,GAAG,CAACgB,CAAC,CAAC,YAAY/B,eAAe,EAAE;MACrCe,GAAG,CAACgB,CAAC,CAAC,GAAG,IAAI/B,eAAe,CAAC;QAC3B,GAAGe,GAAG,CAACgB,CAAC,CAAC;QACTE,gBAAgB,EAAEJ,UAAU;QAC5BK,WAAW,EAAExB,KAAK,CAACyB;MACrB,CAAC,CAAC;IACJ,CAAC,MAAM;MACLpB,GAAG,CAACgB,CAAC,CAAC,CAACE,gBAAgB,GAAGJ,UAAU;MACpCd,GAAG,CAACgB,CAAC,CAAC,CAACG,WAAW,GAAGxB,KAAK,CAACyB,KAAK;IAClC;EACF;EAEA,OAAOpB,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAP,OAAO,CAAC4B,WAAW,GAAG,SAASA,WAAWA,CAACD,KAAK,EAAEE,GAAG,EAAEC,MAAM,EAAEC,kBAAkB,EAAE5B,OAAO,EAAE;EAC1FwB,KAAK,CAACK,KAAK,CAACC,WAAW,CAAC,aAAa,EAAEJ,GAAG,CAAC;EAC3C,MAAMK,oBAAoB,GAAGP,KAAK,CAACQ,MAAM,GACvCR,KAAK,CAACQ,MAAM,CAACD,oBAAoB,GACjC,IAAI;EAEN,MAAMtB,GAAG,GAAGsB,oBAAoB,EAAEE,MAAM,GACtCF,oBAAoB,CAACtB,GAAG,GACxB,IAAI;EAEN,MAAMyB,KAAK,GAAGR,GAAG,CAACjB,GAAG,CAAC;EACtB,IAAIA,GAAG,IAAIyB,KAAK,IAAIV,KAAK,CAACW,cAAc,EAAE;IACxC,MAAMC,aAAa,GAAGZ,KAAK,CAACW,cAAc,CAACD,KAAK,CAAC,IAAIzC,uBAAuB,CAAC+B,KAAK,CAACW,cAAc,EAAED,KAAK,CAAC;IACzG,IAAIE,aAAa,EAAE;MACjB,MAAMC,OAAO,GAAG1C,KAAK,CAACiC,kBAAkB,CAAC;MACzC/B,OAAO,CAACyC,UAAU,CAACD,OAAO,EAAED,aAAa,CAACJ,MAAM,CAAC;MACjD,OAAO,IAAII,aAAa,CAACG,SAAS,EAAEF,OAAO,EAAE;QAAEG,MAAM,EAAE;MAAK,CAAC,CAAC;IAChE;EACF;EAEA,MAAMC,KAAK,GAAG;IACZD,MAAM,EAAE,IAAI;IACZE,KAAK,EAAE,KAAK;IACZC,QAAQ,EAAE;EACZ,CAAC;EACD,IAAI3C,OAAO,IAAI,IAAI,IAAI,UAAU,IAAIA,OAAO,EAAE;IAC5CyC,KAAK,CAACG,QAAQ,GAAG5C,OAAO,CAAC4C,QAAQ;EACnC;EACA,OAAO,IAAIpB,KAAK,CAACe,SAAS,EAAEZ,MAAM,EAAEc,KAAK,CAAC;AAC5C,CAAC;;AAED;AACA;AACA;;AAEA5C,OAAO,CAACgD,kBAAkB,GAAG,SAASA,kBAAkBA,CAACrB,KAAK,EAAEE,GAAG,EAAEC,MAAM,EAAEC,kBAAkB,EAAE5B,OAAO,EAAE8C,YAAY,EAAEC,QAAQ,EAAE;EAChI,MAAMC,QAAQ,GAAGF,YAAY,GAC3B;IAAEG,SAAS,EAAEH;EAAa,CAAC,GAC3BP,SAAS;EAEX,MAAMW,MAAM,GAAGrD,OAAO,CAAC4B,WAAW,CAACD,KAAK,EAAEE,GAAG,EAAEC,MAAM,EAAEC,kBAAkB,EAAE5B,OAAO,CAAC;EACnF,IAAI;IACFkD,MAAM,CAACC,KAAK,CAACzB,GAAG,EAAEsB,QAAQ,EAAED,QAAQ,CAAC;EACvC,CAAC,CAAC,OAAOK,KAAK,EAAE;IACdL,QAAQ,CAACK,KAAK,EAAEF,MAAM,CAAC;EACzB;AACF,CAAC;;AAED;AACA;AACA;;AAEArD,OAAO,CAACyC,UAAU,GAAG,SAASA,UAAUA,CAACX,MAAM,EAAEK,MAAM,EAAEqB,kBAAkB,EAAE;EAC3E;EACA,IAAIC,OAAO;EACX,IAAIhD,IAAI;EACR,MAAMiD,gBAAgB,GAAG,IAAIC,GAAG,CAAC,CAAC;EAElC,IAAI7B,MAAM,EAAE;IACVrB,IAAI,GAAGD,MAAM,CAACC,IAAI,CAACqB,MAAM,CAAC;;IAE1B;IACA,MAAM8B,UAAU,GAAG,EAAE;IACrB,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,IAAI,CAACe,MAAM,EAAE,EAAED,CAAC,EAAE;MACpC,MAAMX,GAAG,GAAGH,IAAI,CAACc,CAAC,CAAC;MACnB,IAAId,IAAI,CAACc,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACtB;MACF;MAEA,OAAOO,MAAM,CAAClB,GAAG,CAAC;MAClB,IAAIA,GAAG,KAAK,MAAM,EAAE;QAClBkB,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC;MACnB,CAAC,MAAM;QACL8B,UAAU,CAACC,IAAI,CAACjD,GAAG,CAACkD,KAAK,CAAC,CAAC,CAAC,CAAC;MAC/B;IACF;IAEArD,IAAI,GAAGD,MAAM,CAACC,IAAI,CAACqB,MAAM,CAAC;IAC1B,KAAK,IAAIiC,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGtD,IAAI,CAACe,MAAM,EAAE,EAAEuC,QAAQ,EAAE;MACzD,IAAItD,IAAI,CAACsD,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC7B;MACF;MACA,MAAMC,KAAK,GAAGlC,MAAM,CAACrB,IAAI,CAACsD,QAAQ,CAAC,CAAC;MACpC;MACA,IAAI,CAAClE,oBAAoB,CAACmE,KAAK,CAAC,EAAE;QAChC;MACF;MACA,IAAIvD,IAAI,CAACsD,QAAQ,CAAC,KAAK,KAAK,IAAItD,IAAI,CAACe,MAAM,GAAG,CAAC,EAAE;QAC/C;MACF;MACA,IAAIf,IAAI,CAACsD,QAAQ,CAAC,KAAK5B,MAAM,CAAChC,OAAO,CAAC8D,gBAAgB,IAAIxD,IAAI,CAACe,MAAM,GAAG,CAAC,IAAIwC,KAAK,IAAI,IAAI,IAAI,CAACA,KAAK,EAAE;QACpG;MACF;MACAP,OAAO,GAAG,CAACO,KAAK;MAChB;IACF;;IAEA;IACA;IACA,KAAK,MAAM5C,IAAI,IAAIwC,UAAU,EAAE;MAC7B,MAAMM,IAAI,GAAG/B,MAAM,CAACf,IAAI,CAACA,IAAI,CAAC;MAC9B;MACA;MACA;MACA;MACA,IAAI,CAAC8C,IAAI,EAAEC,QAAQ,IAAIV,OAAO,KAAK,KAAK,EAAE;QACxC3B,MAAM,CAACV,IAAI,CAAC,GAAG,CAAC;QAChBqC,OAAO,GAAG,IAAI;MAChB,CAAC,MAAM,IAAIS,IAAI,EAAEC,QAAQ,IAAIV,OAAO,KAAK,KAAK,EAAE;QAC9C;QACA;QACAC,gBAAgB,CAACU,GAAG,CAAChD,IAAI,CAAC;MAC5B;IACF;EACF;;EAEA;EACA;EACA,MAAM+C,QAAQ,GAAG,EAAE;EACnB,MAAME,QAAQ,GAAG,EAAE;EACnB,MAAMC,KAAK,GAAG,EAAE;EAEhBC,aAAa,CAACpC,MAAM,CAAC;EACrB,QAAQsB,OAAO;IACb,KAAK,IAAI;MACP,KAAK,MAAMe,SAAS,IAAIH,QAAQ,EAAE;QAChCvC,MAAM,CAAC0C,SAAS,CAAC,GAAG,CAAC;MACvB;MACA;IACF,KAAK,KAAK;MACR,IAAIrC,MAAM,EAAEsC,KAAK,CAAC,KAAK,CAAC,EAAEtE,OAAO,EAAEuE,MAAM,KAAK,KAAK,EAAE;QACnD5C,MAAM,CAAC6C,GAAG,GAAG,CAAC;MAChB;MAEA,KAAK,MAAMH,SAAS,IAAIL,QAAQ,EAAE;QAChC,IAAIT,gBAAgB,CAACkB,GAAG,CAACJ,SAAS,CAAC,EAAE;UACnC;QACF;QACA,IAAIzE,uBAAuB,CAAC+B,MAAM,EAAE0C,SAAS,CAAC,EAAE;UAC9C;QACF;QACA1C,MAAM,CAAC0C,SAAS,CAAC,GAAG1C,MAAM,CAAC0C,SAAS,CAAC,IAAI,CAAC;MAC5C;MACA;IACF,KAAK9B,SAAS;MACZ,IAAIZ,MAAM,IAAI,IAAI,EAAE;QAClB;MACF;MACA;MACA,KAAK,MAAMlB,GAAG,IAAIJ,MAAM,CAACC,IAAI,CAACqB,MAAM,IAAI,CAAC,CAAC,CAAC,EAAE;QAC3C,IAAIlB,GAAG,CAACiE,UAAU,CAAC,GAAG,CAAC,EAAE;UACvB,OAAO/C,MAAM,CAAClB,GAAG,CAAC;QACpB;MACF;;MAEA;MACA;MACA,KAAK,MAAM4D,SAAS,IAAIH,QAAQ,EAAE;QAChC,IAAIvC,MAAM,CAAC0C,SAAS,CAAC,IAAI,IAAI,EAAE;UAC7B;UACA;UACA;QACF;QACA1C,MAAM,CAAC0C,SAAS,CAAC,GAAG,CAAC;MACvB;MACA;EACJ;EAEA,SAASD,aAAaA,CAACpC,MAAM,EAAE2C,MAAM,EAAE;IACrCA,MAAM,KAAKA,MAAM,GAAG,EAAE,CAAC;;IAEvB;IACA,IAAIR,KAAK,CAACS,OAAO,CAAC5C,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;MAChC,OAAO,EAAE;IACX;IACAmC,KAAK,CAACT,IAAI,CAAC1B,MAAM,CAAC;IAElB,MAAM6C,UAAU,GAAG,EAAE;IACrB7C,MAAM,CAAC8C,QAAQ,CAAC,UAAS7D,IAAI,EAAE8C,IAAI,EAAE;MACnC,IAAIY,MAAM,EAAE1D,IAAI,GAAG0D,MAAM,GAAG,GAAG,GAAG1D,IAAI;MACtC,IAAI8C,IAAI,CAACgB,YAAY,IAAI9D,IAAI,CAAC+D,QAAQ,CAAC,KAAK,CAAC,EAAE;QAC7C,MAAMC,QAAQ,GAAG,GAAG,GAAGhE,IAAI;QAC3B,MAAMiE,WAAW,GAAGvD,MAAM,IAAIsD,QAAQ,IAAItD,MAAM;QAChD,IAAIoC,IAAI,CAAC/D,OAAO,EAAEuE,MAAM,KAAK,KAAK,IAAI,CAACW,WAAW,EAAE;UAClDhB,QAAQ,CAACR,IAAI,CAACzC,IAAI,CAAC;QACrB;QACA;MACF;MACA,IAAIkE,SAAS,GAAGC,WAAW,CAACnE,IAAI,EAAE8C,IAAI,CAAC;MACvC;MACA,IAAIoB,SAAS,IAAI,IAAI,IAAI,CAACE,KAAK,CAACC,OAAO,CAACvB,IAAI,CAAC,IAAIA,IAAI,CAACwB,gBAAgB,IAAI,CAACxB,IAAI,CAACyB,wBAAwB,EAAE;QACxGL,SAAS,GAAGC,WAAW,CAACnE,IAAI,EAAE8C,IAAI,CAAC0B,kBAAkB,CAAC;MACxD;MACA,IAAIN,SAAS,IAAI,IAAI,EAAE;QACrBN,UAAU,CAACnB,IAAI,CAACyB,SAAS,CAAC;MAC5B;;MAEA;MACA,IAAIpB,IAAI,CAAC/B,MAAM,EAAE;QACf,MAAM0D,WAAW,GAAGtB,aAAa,CAACL,IAAI,CAAC/B,MAAM,EAAEf,IAAI,CAAC;;QAEpD;QACA;QACA,IAAIqC,OAAO,KAAK,KAAK,EAAE;UACrB/D,uCAAuC,CAACoC,MAAM,EAAEV,IAAI,EAAE8C,IAAI,CAAC/B,MAAM,EAC/DgC,QAAQ,EAAE0B,WAAW,CAAC;QAC1B;MACF;IACF,CAAC,CAAC;IACFvB,KAAK,CAAC/D,GAAG,CAAC,CAAC;IACX,OAAOyE,UAAU;EACnB;EAEA,SAASO,WAAWA,CAACnE,IAAI,EAAE8C,IAAI,EAAE;IAC/B,IAAIpC,MAAM,IAAI,IAAI,EAAE;MAClB;IACF;;IAEA;IACA,IAAI,OAAOoC,IAAI,CAACC,QAAQ,KAAK,SAAS,EAAE;MACtC;IACF;;IAEA;IACA,IAAID,IAAI,CAACC,QAAQ,KAAK,KAAK,IAAIrC,MAAM,CAACV,IAAI,CAAC,EAAE;MAC3C,IAAIoC,kBAAkB,EAAE;QACtB1B,MAAM,CAACV,IAAI,CAAC,GAAG,CAAC;MAClB;MAEA;IACF;;IAEA;IACA;IACA;IACA,IAAI,CAACqC,OAAO,IAAIS,IAAI,CAACC,QAAQ,IAAI/C,IAAI,KAAKe,MAAM,CAAChC,OAAO,CAAC8D,gBAAgB,IAAInC,MAAM,CAACV,IAAI,CAAC,IAAI,IAAI,IAAI,CAACU,MAAM,CAACV,IAAI,CAAC,EAAE;MAClH,OAAOU,MAAM,CAACV,IAAI,CAAC;MACnB;IACF;IAEA,IAAIqC,OAAO,KAAK,KAAK,IAAIS,IAAI,CAACC,QAAQ,IAAIrC,MAAM,CAACV,IAAI,CAAC,IAAI,IAAI,IAAI,CAACU,MAAM,CAACV,IAAI,CAAC,EAAE;MAC/E,OAAOU,MAAM,CAACV,IAAI,CAAC;MACnB;IACF;IAEA,MAAMgE,QAAQ,GAAG,GAAG,GAAGhE,IAAI;IAC3B,MAAMiE,WAAW,GAAGvD,MAAM,IAAIsD,QAAQ,IAAItD,MAAM;IAChD,IAAIuD,WAAW,EAAE;MACf;MACA,OAAOvD,MAAM,CAACsD,QAAQ,CAAC;;MAEvB;MACA;MACA,IAAI3B,OAAO,KAAK,KAAK,IAAIhD,IAAI,CAACe,MAAM,GAAG,CAAC,IAAI,CAAC,CAACf,IAAI,CAACsE,OAAO,CAAC3D,IAAI,CAAC,IAAI,CAACoC,kBAAkB,EAAE;QACvF1B,MAAM,CAACV,IAAI,CAAC,GAAG,CAAC;MAClB,CAAC,MAAM,IAAIqC,OAAO,IAAI,IAAI,IAAID,kBAAkB,IAAIU,IAAI,CAACC,QAAQ,KAAK,KAAK,EAAE;QAC3ErC,MAAM,CAACV,IAAI,CAAC,GAAG,CAAC;MAClB;MAEA;IACF;;IAEA;IACA,MAAM0E,MAAM,GAAG1E,IAAI,CAAC2E,KAAK,CAAC,GAAG,CAAC;IAC9B,IAAIC,GAAG,GAAG,EAAE;IACZ,KAAK,IAAIzE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuE,MAAM,CAACtE,MAAM,EAAE,EAAED,CAAC,EAAE;MACtCyE,GAAG,IAAIA,GAAG,CAACxE,MAAM,GAAG,GAAG,GAAGsE,MAAM,CAACvE,CAAC,CAAC,GAAGuE,MAAM,CAACvE,CAAC,CAAC;MAC/C,IAAI8C,QAAQ,CAACU,OAAO,CAACiB,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;QAChC;MACF;IACF;;IAEA;IACA;IACA;IACA,IAAI,CAACvC,OAAO,KAAKS,IAAI,EAAE/D,OAAO,EAAE8F,uBAAuB,IAAI,KAAK,CAAC,EAAE;MACjE,IAAID,GAAG,GAAG,EAAE;MACZ,KAAK,IAAIzE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuE,MAAM,CAACtE,MAAM,EAAE,EAAED,CAAC,EAAE;QACtCyE,GAAG,IAAI,CAACA,GAAG,CAACxE,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,GAAG,IAAIsE,MAAM,CAACvE,CAAC,CAAC;QAChD,MAAMF,UAAU,GAAG1B,GAAG,CAACmC,MAAM,EAAEkE,GAAG,EAAE,KAAK,CAAC,IAAIrG,GAAG,CAACmC,MAAM,EAAEkE,GAAG,GAAG,IAAI,EAAE,KAAK,CAAC;QAC5E,IAAI3E,UAAU,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;UAChD;QACF;MACF;IACF;IAEA,CAAC6C,IAAI,CAACC,QAAQ,GAAGA,QAAQ,GAAGE,QAAQ,EAAER,IAAI,CAACzC,IAAI,CAAC;IAChD,OAAOA,IAAI;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,SAASF,QAAQA,CAACgF,GAAG,EAAE;EACrB,OAAO,UAASC,MAAM,EAAE;IACtBA,MAAM,CAAChG,OAAO,KAAKgG,MAAM,CAAChG,OAAO,GAAG,CAAC,CAAC,CAAC;IAEvC,IAAIqF,KAAK,CAACC,OAAO,CAACS,GAAG,EAAEE,QAAQ,CAAC,EAAE;MAChCF,GAAG,GAAG1F,MAAM,CAAC6F,MAAM,CAAC,CAAC,CAAC,EAAEH,GAAG,CAAC;MAC5BA,GAAG,CAACE,QAAQ,GAAGF,GAAG,CAACE,QAAQ,CACzBrF,MAAM,CAACK,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAACyD,UAAU,CAACsB,MAAM,CAAC/E,IAAI,GAAG,GAAG,CAAC,CAAC,CAC9EkF,GAAG,CAAClF,IAAI,IAAIA,IAAI,CAAC0C,KAAK,CAACqC,MAAM,CAAC/E,IAAI,CAACI,MAAM,GAAG,CAAC,CAAC,CAAC;IACnD;IAEA2E,MAAM,CAAChG,OAAO,CAACW,IAAI,GAAGoF,GAAG;EAC3B,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}