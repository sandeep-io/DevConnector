{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst ObjectExpectedError = require('../error/objectExpected');\nconst SchemaSubdocumentOptions = require('../options/schemaSubdocumentOptions');\nconst SchemaType = require('../schemaType');\nconst applyDefaults = require('../helpers/document/applyDefaults');\nconst $exists = require('./operators/exists');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst discriminator = require('../helpers/model/discriminator');\nconst geospatial = require('./operators/geospatial');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nconst isExclusive = require('../helpers/projection/isExclusive');\nconst utils = require('../utils');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\nlet SubdocumentType;\nmodule.exports = SchemaSubdocument;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} path\n * @param {Object} options\n * @param {Schema} parentSchema\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaSubdocument(schema, path, options, parentSchema) {\n  if (schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(path, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaSubdocument.defaultOptions?._id;\n  if (schemaTypeIdOption != null) {\n    options = options || {};\n    options._id = schemaTypeIdOption;\n  }\n  schema = handleIdOption(schema, options);\n  this.Constructor = _createConstructor(schema, null, options);\n  this.Constructor.path = path;\n  this.Constructor.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  this.base = schema.base;\n  SchemaType.call(this, path, options, 'Embedded', parentSchema);\n}\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype = Object.create(SchemaType.prototype);\nSchemaSubdocument.prototype.constructor = SchemaSubdocument;\nSchemaSubdocument.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass, options) {\n  // lazy load\n  SubdocumentType || (SubdocumentType = require('../types/subdocument'));\n  const _embedded = function SingleNested(value, path, parent) {\n    this.$__parent = parent;\n    SubdocumentType.apply(this, arguments);\n    if (parent == null) {\n      return;\n    }\n    this.$session(parent.$session());\n  };\n  schema._preCompile();\n  const proto = baseClass?.prototype ?? SubdocumentType.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.prototype.$__schemaTypeOptions = options;\n  _embedded.$__required = options?.required;\n  _embedded.base = schema.base;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function () {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n  return _embedded;\n}\n\n/*!\n * ignore\n */\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers\n};\n\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\n$conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {\n  return {\n    $geometry: this.castForQuery(null, val.$geometry, context)\n  };\n};\n\n/*!\n * ignore\n */\n\n$conditionalHandlers.$near = $conditionalHandlers.$nearSphere = geospatial.cast$near;\n$conditionalHandlers.$within = $conditionalHandlers.$geoWithin = geospatial.cast$within;\n$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;\n$conditionalHandlers.$minDistance = castToNumber;\n$conditionalHandlers.$maxDistance = castToNumber;\n$conditionalHandlers.$exists = $exists;\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$exists` is the function Mongoose calls to cast `$exists` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaSubdocument\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaSubdocument.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSchemaSubdocument.prototype.cast = function (val, doc, init, priorVal, options) {\n  if (val?.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n  if (!init && val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n  const discriminatorKeyPath = this.schema.path(this.schema.options.discriminatorKey);\n  const defaultDiscriminatorValue = discriminatorKeyPath == null ? null : discriminatorKeyPath.getDefault(doc);\n  const Constructor = getConstructor(this.Constructor, val, defaultDiscriminatorValue);\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = doc?.$__?.selected;\n  const path = this.path;\n  const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj = obj || {};\n      obj[key.substring(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, null);\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc, {\n      defaults: false\n    });\n    delete subdoc.$__.defaults;\n    // Don't pass `path` to $init - it's only for the subdocument itself, not its fields.\n    // For change tracking, subdocuments use relative paths internally.\n    // Here, `options.path` contains the absolute path and is only used by the subdocument constructor, not by $init.\n    if (options.path != null) {\n      options = {\n        ...options\n      };\n      delete options.path;\n    }\n    subdoc.$init(val, options);\n    const exclude = isExclusive(selected);\n    applyDefaults(subdoc, selected, exclude);\n  } else {\n    options = Object.assign({}, options, {\n      priorDoc: priorVal\n    });\n    if (utils.hasOwnKeys(val) === false) {\n      return new Constructor({}, selected, doc, options);\n    }\n    return new Constructor(val, selected, doc, options);\n  }\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSchemaSubdocument.prototype.castForQuery = function ($conditional, val, context, options) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  if (val == null) {\n    return val;\n  }\n  const Constructor = getConstructor(this.Constructor, val);\n  if (val instanceof Constructor) {\n    return val;\n  }\n  if (this.options.runSetters) {\n    val = this._applySetters(val, context);\n  }\n  const overrideStrict = options?.strict ?? void 0;\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api public\n */\n\nSchemaSubdocument.prototype.doValidate = async function doValidate(value, scope, options) {\n  const Constructor = getConstructor(this.Constructor, value);\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, null, scope?.$__ != null ? scope : null);\n  }\n  if (options?.skipSchemaValidators) {\n    if (!value) {\n      return;\n    }\n    return value.validate();\n  }\n  await SchemaType.prototype.doValidate.call(this, value, scope, options);\n  if (value != null) {\n    await value.validate();\n  }\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidateSync = function (value, scope, options) {\n  if (!options?.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @api public\n */\n\nSchemaSubdocument.prototype.discriminator = function (name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n  schema = discriminator(this.Constructor, name, schema, value, null, null, options.overwriteExisting);\n  this.Constructor.discriminators[name] = _createConstructor(schema, this.Constructor);\n  return this.Constructor.discriminators[name];\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.defaultOptions = {};\n\n/**\n * Sets a default option for all Subdocument instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Subdocument.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaSubdocument.set = SchemaType.set;\nSchemaSubdocument.setters = [];\n\n/**\n * Attaches a getter for all Subdocument instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaSubdocument.get = SchemaType.get;\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.toJSON = function toJSON() {\n  return {\n    path: this.path,\n    options: this.options\n  };\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.clone = function () {\n  const schematype = new this.constructor(this.schema, this.path, {\n    ...this.options,\n    _skipApplyDiscriminators: true\n  }, this.parentSchema);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  schematype._appliedDiscriminators = this._appliedDiscriminators;\n  return schematype;\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaSubdocument.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return {\n    ...this.schema.toJSONSchema(options),\n    ...createJSONSchemaTypeDefinition('object', 'object', options?.useBsonType, isRequired)\n  };\n};","map":{"version":3,"names":["CastError","require","EventEmitter","ObjectExpectedError","SchemaSubdocumentOptions","SchemaType","applyDefaults","$exists","castToNumber","createJSONSchemaTypeDefinition","discriminator","geospatial","getConstructor","handleIdOption","internalToObjectOptions","isExclusive","utils","InvalidSchemaOptionError","SubdocumentType","module","exports","SchemaSubdocument","schema","path","options","parentSchema","timeseries","schemaTypeIdOption","defaultOptions","_id","Constructor","_createConstructor","prototype","$basePath","$isSingleNested","base","call","Object","create","constructor","OptionsConstructor","baseClass","_embedded","SingleNested","value","parent","$__parent","apply","arguments","$session","_preCompile","proto","$__setSchema","$__schemaTypeOptions","$__required","required","events","toBSON","toObject","i","methods","statics","$conditionalHandlers","$geoWithin","handle$geoWithin","val","context","$geometry","castForQuery","$near","$nearSphere","cast$near","$within","cast$within","$geoIntersects","cast$geoIntersects","$minDistance","$maxDistance","defineProperty","enumerable","cast","doc","init","priorVal","Array","isArray","discriminatorKeyPath","discriminatorKey","defaultDiscriminatorValue","getDefault","subdoc","parentSelected","$__","selected","keys","reduce","obj","key","startsWith","substring","length","defaults","$init","exclude","assign","priorDoc","hasOwnKeys","$conditional","handler","Error","runSetters","_applySetters","overrideStrict","strict","error","doValidate","scope","skipSchemaValidators","validate","doValidateSync","schemaTypeError","validateSync","name","isPOJO","clone","instanceOfSchema","overwriteExisting","discriminators","set","setters","get","toJSON","schematype","_skipApplyDiscriminators","validators","slice","requiredValidator","undefined","_appliedDiscriminators","toJSONSchema","isRequired","useBsonType"],"sources":["C:/DEVC/node_modules/mongoose/lib/schema/subdocument.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst ObjectExpectedError = require('../error/objectExpected');\nconst SchemaSubdocumentOptions = require('../options/schemaSubdocumentOptions');\nconst SchemaType = require('../schemaType');\nconst applyDefaults = require('../helpers/document/applyDefaults');\nconst $exists = require('./operators/exists');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst discriminator = require('../helpers/model/discriminator');\nconst geospatial = require('./operators/geospatial');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nconst isExclusive = require('../helpers/projection/isExclusive');\nconst utils = require('../utils');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\n\nlet SubdocumentType;\n\nmodule.exports = SchemaSubdocument;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} path\n * @param {Object} options\n * @param {Schema} parentSchema\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaSubdocument(schema, path, options, parentSchema) {\n  if (schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(path, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaSubdocument.defaultOptions?._id;\n  if (schemaTypeIdOption != null) {\n    options = options || {};\n    options._id = schemaTypeIdOption;\n  }\n\n  schema = handleIdOption(schema, options);\n\n  this.Constructor = _createConstructor(schema, null, options);\n  this.Constructor.path = path;\n  this.Constructor.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  this.base = schema.base;\n  SchemaType.call(this, path, options, 'Embedded', parentSchema);\n}\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype = Object.create(SchemaType.prototype);\nSchemaSubdocument.prototype.constructor = SchemaSubdocument;\nSchemaSubdocument.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass, options) {\n  // lazy load\n  SubdocumentType || (SubdocumentType = require('../types/subdocument'));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    this.$__parent = parent;\n    SubdocumentType.apply(this, arguments);\n\n    if (parent == null) {\n      return;\n    }\n    this.$session(parent.$session());\n  };\n\n  schema._preCompile();\n\n  const proto = baseClass?.prototype ?? SubdocumentType.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.prototype.$__schemaTypeOptions = options;\n  _embedded.$__required = options?.required;\n  _embedded.base = schema.base;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function() {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n\n/*!\n * ignore\n */\nconst $conditionalHandlers = { ...SchemaType.prototype.$conditionalHandlers };\n\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\n$conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {\n  return { $geometry: this.castForQuery(null, val.$geometry, context) };\n};\n\n/*!\n * ignore\n */\n\n$conditionalHandlers.$near =\n$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\n$conditionalHandlers.$within =\n$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\n$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\n$conditionalHandlers.$minDistance = castToNumber;\n$conditionalHandlers.$maxDistance = castToNumber;\n\n$conditionalHandlers.$exists = $exists;\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$exists` is the function Mongoose calls to cast `$exists` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaSubdocument\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaSubdocument.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSchemaSubdocument.prototype.cast = function(val, doc, init, priorVal, options) {\n  if (val?.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n\n  if (!init && val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  const discriminatorKeyPath = this.schema.path(this.schema.options.discriminatorKey);\n  const defaultDiscriminatorValue = discriminatorKeyPath == null ? null : discriminatorKeyPath.getDefault(doc);\n  const Constructor = getConstructor(this.Constructor, val, defaultDiscriminatorValue);\n\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = doc?.$__?.selected;\n  const path = this.path;\n  const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj = obj || {};\n      obj[key.substring(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, null);\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc, { defaults: false });\n    delete subdoc.$__.defaults;\n    // Don't pass `path` to $init - it's only for the subdocument itself, not its fields.\n    // For change tracking, subdocuments use relative paths internally.\n    // Here, `options.path` contains the absolute path and is only used by the subdocument constructor, not by $init.\n    if (options.path != null) {\n      options = { ...options };\n      delete options.path;\n    }\n    subdoc.$init(val, options);\n    const exclude = isExclusive(selected);\n    applyDefaults(subdoc, selected, exclude);\n  } else {\n    options = Object.assign({}, options, { priorDoc: priorVal });\n    if (utils.hasOwnKeys(val) === false) {\n      return new Constructor({}, selected, doc, options);\n    }\n\n    return new Constructor(val, selected, doc, options);\n  }\n\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSchemaSubdocument.prototype.castForQuery = function($conditional, val, context, options) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  if (val == null) {\n    return val;\n  }\n\n  const Constructor = getConstructor(this.Constructor, val);\n  if (val instanceof Constructor) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val, context);\n  }\n\n  const overrideStrict = options?.strict ?? void 0;\n\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api public\n */\n\nSchemaSubdocument.prototype.doValidate = async function doValidate(value, scope, options) {\n  const Constructor = getConstructor(this.Constructor, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, null, scope?.$__ != null ? scope : null);\n  }\n\n  if (options?.skipSchemaValidators) {\n    if (!value) {\n      return;\n    }\n    return value.validate();\n  }\n\n  await SchemaType.prototype.doValidate.call(this, value, scope, options);\n  if (value != null) {\n    await value.validate();\n  }\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidateSync = function(value, scope, options) {\n  if (!options?.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @api public\n */\n\nSchemaSubdocument.prototype.discriminator = function(name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean'\n    ? options.clone\n    : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.Constructor, name, schema, value, null, null, options.overwriteExisting);\n\n  this.Constructor.discriminators[name] = _createConstructor(schema, this.Constructor);\n\n  return this.Constructor.discriminators[name];\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.defaultOptions = {};\n\n/**\n * Sets a default option for all Subdocument instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Subdocument.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaSubdocument.set = SchemaType.set;\n\nSchemaSubdocument.setters = [];\n\n/**\n * Attaches a getter for all Subdocument instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaSubdocument.get = SchemaType.get;\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.toJSON = function toJSON() {\n  return { path: this.path, options: this.options };\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.clone = function() {\n  const schematype = new this.constructor(\n    this.schema,\n    this.path,\n    { ...this.options, _skipApplyDiscriminators: true },\n    this.parentSchema\n  );\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  schematype._appliedDiscriminators = this._appliedDiscriminators;\n  return schematype;\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaSubdocument.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return {\n    ...this.schema.toJSONSchema(options),\n    ...createJSONSchemaTypeDefinition('object', 'object', options?.useBsonType, isRequired)\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}