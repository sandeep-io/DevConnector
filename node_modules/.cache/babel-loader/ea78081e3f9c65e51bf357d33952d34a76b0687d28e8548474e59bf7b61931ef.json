{"ast":null,"code":"'use strict';\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema?.discriminatorMapping;\n  prefix = prefix || '';\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] != null && originalPipeline[0].$match && (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0]?.$geoNear) {\n      originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0]?.$search) {\n      if (originalPipeline[1]?.$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, {\n          $match: match\n        });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({\n        $match: match\n      });\n    }\n  }\n};","map":{"version":3,"names":["module","exports","prepareDiscriminatorPipeline","pipeline","schema","prefix","discriminatorMapping","isRoot","originalPipeline","filterKey","length","key","discriminatorValue","value","$match","undefined","$geoNear","query","$search","match","splice","unshift"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema?.discriminatorMapping;\n  prefix = prefix || '';\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] != null &&\n        originalPipeline[0].$match &&\n        (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0]?.$geoNear) {\n      originalPipeline[0].$geoNear.query =\n          originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0]?.$search) {\n      if (originalPipeline[1]?.$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, { $match: match });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({ $match: match });\n    }\n  }\n};\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAG,SAASC,4BAA4BA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,MAAM,EAAE;EAC/E,MAAMC,oBAAoB,GAAGF,MAAM,EAAEE,oBAAoB;EACzDD,MAAM,GAAGA,MAAM,IAAI,EAAE;EAErB,IAAIC,oBAAoB,IAAI,CAACA,oBAAoB,CAACC,MAAM,EAAE;IACxD,MAAMC,gBAAgB,GAAGL,QAAQ;IACjC,MAAMM,SAAS,GAAG,CAACJ,MAAM,CAACK,MAAM,GAAG,CAAC,GAAGL,MAAM,GAAG,GAAG,GAAGA,MAAM,IAAIC,oBAAoB,CAACK,GAAG;IACxF,MAAMC,kBAAkB,GAAGN,oBAAoB,CAACO,KAAK;;IAErD;IACA;IACA;IACA,IAAIL,gBAAgB,CAAC,CAAC,CAAC,IAAI,IAAI,IAC3BA,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,KACzBN,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,KAAKM,SAAS,IAAIP,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,KAAKG,kBAAkB,CAAC,EAAE;MACzHJ,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,GAAGG,kBAAkB;MAC1D;MACA;IACF,CAAC,MAAM,IAAIJ,gBAAgB,CAAC,CAAC,CAAC,EAAEQ,QAAQ,EAAE;MACxCR,gBAAgB,CAAC,CAAC,CAAC,CAACQ,QAAQ,CAACC,KAAK,GAC9BT,gBAAgB,CAAC,CAAC,CAAC,CAACQ,QAAQ,CAACC,KAAK,IAAI,CAAC,CAAC;MAC5CT,gBAAgB,CAAC,CAAC,CAAC,CAACQ,QAAQ,CAACC,KAAK,CAACR,SAAS,CAAC,GAAGG,kBAAkB;IACpE,CAAC,MAAM,IAAIJ,gBAAgB,CAAC,CAAC,CAAC,EAAEU,OAAO,EAAE;MACvC,IAAIV,gBAAgB,CAAC,CAAC,CAAC,EAAEM,MAAM,IAAI,IAAI,EAAE;QACvCN,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,GAAGD,gBAAgB,CAAC,CAAC,CAAC,CAACM,MAAM,CAACL,SAAS,CAAC,IAAIG,kBAAkB;MACrG,CAAC,MAAM;QACL,MAAMO,KAAK,GAAG,CAAC,CAAC;QAChBA,KAAK,CAACV,SAAS,CAAC,GAAGG,kBAAkB;QACrCJ,gBAAgB,CAACY,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE;UAAEN,MAAM,EAAEK;QAAM,CAAC,CAAC;MAClD;IACF,CAAC,MAAM;MACL,MAAMA,KAAK,GAAG,CAAC,CAAC;MAChBA,KAAK,CAACV,SAAS,CAAC,GAAGG,kBAAkB;MACrCJ,gBAAgB,CAACa,OAAO,CAAC;QAAEP,MAAM,EAAEK;MAAM,CAAC,CAAC;IAC7C;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}