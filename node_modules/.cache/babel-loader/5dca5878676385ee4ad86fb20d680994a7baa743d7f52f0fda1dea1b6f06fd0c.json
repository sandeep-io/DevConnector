{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/schemaArrayOptions');\nconst SchemaType = require('../schemaType');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst VirtualOptions = require('../options/virtualOptions');\nconst VirtualType = require('../virtualType');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst clone = require('../helpers/clone');\nconst getConstructorName = require('../helpers/getConstructorName');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\nlet MongooseArray;\nlet EmbeddedDoc;\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @param {Schema} parentSchema\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions, parentSchema) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n  if (schemaOptions?.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n  if (cast) {\n    let castOptions = {};\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n    if (options?.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n    const Types = require('./index.js');\n    const schemaTypeDefinition = Object.hasOwn(Types, name) ? Types[name] : cast;\n    if (typeof schemaTypeDefinition === 'function') {\n      if (schemaTypeDefinition === SchemaArray) {\n        this.embeddedSchemaType = new schemaTypeDefinition(key, castOptions, schemaOptions, null, parentSchema);\n      } else {\n        this.embeddedSchemaType = new schemaTypeDefinition(key, castOptions, schemaOptions, parentSchema);\n      }\n    } else if (schemaTypeDefinition instanceof SchemaType) {\n      this.embeddedSchemaType = schemaTypeDefinition;\n      if (!(this.embeddedSchemaType instanceof EmbeddedDoc)) {\n        this.embeddedSchemaType.path = key;\n      }\n    }\n  }\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array', parentSchema);\n  let defaultArr;\n  let fn;\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n  if (!('defaultValue' in this) || this.defaultValue != null) {\n    const defaultFn = function () {\n      // Leave it up to `cast()` to convert the array\n      return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\nSchemaArray.setters = [];\n\n/**\n * Attaches a getter for all Array instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaArray.get = SchemaType.get;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/*!\n * Virtuals defined on this array itself.\n */\n\nSchemaArray.prototype.virtuals = null;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n  while (true) {\n    const instance = arr?.embeddedSchemaType?.instance;\n    if (instance === 'Array') {\n      arr = arr.embeddedSchemaType;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' + ', not ' + instance);\n    }\n    break;\n  }\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n  arr.embeddedSchemaType.enum.apply(arr.embeddedSchemaType, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (scope?.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  return ret;\n};\nSchemaArray.prototype._applySetters = function (value, scope, init, priorVal) {\n  if (this.embeddedSchemaType.$isMongooseArray && SchemaArray.options.castNonArrays) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.embeddedSchemaType;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n    options = options || emptyOpts;\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    let path = options.path || this.path;\n    if (options.arrayPathIndex != null) {\n      path += '.' + options.arrayPathIndex;\n    }\n    value = MongooseArray(rawValue, path, doc, this);\n    rawValue = value.__array;\n    if (init && doc?.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n    const caster = this.embeddedSchemaType;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.embeddedSchemaType.constructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          if (options.hydratedPopulatedDocs) {\n            opts.hydratedPopulatedDocs = options.hydratedPopulatedDocs;\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  const castNonArraysOption = this.options.castNonArrays ?? SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n    if (this.embeddedSchemaType && this.embeddedSchemaType.constructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (this.embeddedSchemaType.$isMongooseArray && this.embeddedSchemaType._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n          rawValue[i] = this.embeddedSchemaType.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n    return value;\n  }\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function (...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.embeddedSchemaType;\n  }\n  if (!arr.$isMongooseDocumentArray) {\n    throw new MongooseError('You can only add an embedded discriminator on a document array, ' + this.path + ' is a plain array');\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.embeddedSchemaType, options, this.schemaOptions, this.parentSchema);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\nSchemaArray.prototype._castForQuery = function (val, context) {\n  let embeddedSchemaType = this.embeddedSchemaType;\n  const discriminatorKey = embeddedSchemaType?.schema?.options?.discriminatorKey;\n  const discriminators = embeddedSchemaType?.discriminators;\n  if (val && discriminators && typeof discriminatorKey === 'string') {\n    if (discriminators[val[discriminatorKey]]) {\n      embeddedSchemaType = discriminators[val[discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(discriminators, val[discriminatorKey]);\n      if (constructorByValue) {\n        embeddedSchemaType = constructorByValue;\n      }\n    }\n  }\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function (v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      return embeddedSchemaType.castForQuery(null, v, context);\n    });\n  } else {\n    val = embeddedSchemaType.castForQuery(null, val, context);\n  }\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function ($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\n/**\n * Add a virtual to this array. Specifically to this array, not the individual elements.\n *\n * @param {String} name\n * @param {Object} [options]\n * @api private\n */\n\nSchemaArray.prototype.virtual = function virtual(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    throw new MongooseError('Cannot set populate virtual as a property of an array');\n  }\n  const virtual = new VirtualType(options, name);\n  if (this.virtuals === null) {\n    this.virtuals = {};\n  }\n  this.virtuals[name] = virtual;\n  return virtual;\n};\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n  val = val.map(v => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return {\n        $elemMatch: cast(this.embeddedSchemaType.schema, v.$elemMatch, null, this?.$$context)\n      };\n    }\n    const o = {};\n    o[this.path] = v;\n    return cast(this.embeddedSchemaType.schema, o, null, this?.$$context)[this.path];\n  }, this);\n  return this.castForQuery(null, val, context);\n}\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n  return val;\n}\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$all` is the function Mongoose calls to cast `$all` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaArray\n * @instance\n * @api public\n */\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val, context) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.embeddedSchemaType.schema ?? context.schema, obj, null, this?.$$context));\n    }\n    return ret;\n  };\n}\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$not = handle.$regex = handle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaArray.prototype.toJSONSchema = function toJSONSchema(options) {\n  const embeddedSchemaType = this.getEmbeddedSchemaType();\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return {\n    ...createJSONSchemaTypeDefinition('array', 'array', options?.useBsonType, isRequired),\n    items: embeddedSchemaType.toJSONSchema(options)\n  };\n};\nSchemaArray.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'array';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","VirtualOptions","VirtualType","arrayDepth","cast","clone","getConstructorName","isOperator","util","utils","castToNumber","createJSONSchemaTypeDefinition","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","emptyOpts","Object","freeze","SchemaArray","key","options","schemaOptions","parentSchema","Embedded","typeKey","castOptions","isPOJO","ref","name","getFunctionName","Types","schemaTypeDefinition","hasOwn","embeddedSchemaType","path","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","concat","$runBeforeSetters","default","schemaName","castNonArrays","defaultOptions","set","setters","get","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","virtuals","value","doc","_isRef","enum","arr","instance","Error","enumArray","arguments","Array","isArray","isObject","object","vals","apply","applyGetters","scope","$__","$populated","ret","_applySetters","init","priorVal","depth","$isMongooseDocumentArray","length","valueDepth","min","max","containsNonArrayItem","i","prev","l","len","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substring","lastIndexOf","rawValue","isMongooseArray","__array","arrayPathIndex","caster","opts","_arrayParentPath","hydratedPopulatedDocs","applySetters","e","kind","inspect","castNonArraysOption","markModified","_castForPopulate","$toObject","toObject","discriminator","args","assign","schematype","validators","slice","requiredValidator","undefined","_castForQuery","val","context","discriminatorKey","discriminators","constructorByValue","reverse","forEach","setter","map","v","$elemMatch","castForQuery","$conditional","handler","$conditionalHandlers","virtual","hasUserDefinedProperty","cast$all","$$context","o","cast$elemMatch","keys","numKeys","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","createLogicalQueryOperatorHandler","$and","$nor","op","logicalQueryOperatorHandler","TypeError","obj","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$not","$regex","$ne","$nin","$in","toJSONSchema","getEmbeddedSchemaType","isRequired","required","useBsonType","items","autoEncryptionType","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/schema/array.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/schemaArrayOptions');\nconst SchemaType = require('../schemaType');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst VirtualOptions = require('../options/virtualOptions');\nconst VirtualType = require('../virtualType');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst clone = require('../helpers/clone');\nconst getConstructorName = require('../helpers/getConstructorName');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @param {Schema} parentSchema\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions, parentSchema) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions?.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options?.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const schemaTypeDefinition = Object.hasOwn(Types, name) ? Types[name] : cast;\n\n    if (typeof schemaTypeDefinition === 'function') {\n      if (schemaTypeDefinition === SchemaArray) {\n        this.embeddedSchemaType = new schemaTypeDefinition(key, castOptions, schemaOptions, null, parentSchema);\n      } else {\n        this.embeddedSchemaType = new schemaTypeDefinition(key, castOptions, schemaOptions, parentSchema);\n      }\n    } else if (schemaTypeDefinition instanceof SchemaType) {\n      this.embeddedSchemaType = schemaTypeDefinition;\n      if (!(this.embeddedSchemaType instanceof EmbeddedDoc)) {\n        this.embeddedSchemaType.path = key;\n      }\n    }\n\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array', parentSchema);\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue != null) {\n    const defaultFn = function() {\n      // Leave it up to `cast()` to convert the array\n      return fn\n        ? defaultArr.call(this)\n        : defaultArr != null\n          ? [].concat(defaultArr)\n          : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\nSchemaArray.setters = [];\n\n/**\n * Attaches a getter for all Array instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaArray.get = SchemaType.get;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/*!\n * Virtuals defined on this array itself.\n */\n\nSchemaArray.prototype.virtuals = null;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = arr?.embeddedSchemaType?.instance;\n    if (instance === 'Array') {\n      arr = arr.embeddedSchemaType;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.embeddedSchemaType.enum.apply(arr.embeddedSchemaType, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope?.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.embeddedSchemaType.$isMongooseArray &&\n      SchemaArray.options.castNonArrays) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.embeddedSchemaType;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    let path = options.path || this.path;\n    if (options.arrayPathIndex != null) {\n      path += '.' + options.arrayPathIndex;\n    }\n    value = MongooseArray(rawValue, path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc?.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.embeddedSchemaType;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.embeddedSchemaType.constructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          if (options.hydratedPopulatedDocs) {\n            opts.hydratedPopulatedDocs = options.hydratedPopulatedDocs;\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  const castNonArraysOption = this.options.castNonArrays ?? SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    if (this.embeddedSchemaType && this.embeddedSchemaType.constructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (this.embeddedSchemaType.$isMongooseArray && this.embeddedSchemaType._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = this.embeddedSchemaType.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function(...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.embeddedSchemaType;\n  }\n  if (!arr.$isMongooseDocumentArray) {\n    throw new MongooseError('You can only add an embedded discriminator on a document array, ' + this.path + ' is a plain array');\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.embeddedSchemaType, options, this.schemaOptions, this.parentSchema);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\nSchemaArray.prototype._castForQuery = function(val, context) {\n  let embeddedSchemaType = this.embeddedSchemaType;\n  const discriminatorKey = embeddedSchemaType?.schema?.options?.discriminatorKey;\n  const discriminators = embeddedSchemaType?.discriminators;\n\n  if (val && discriminators && typeof discriminatorKey === 'string') {\n    if (discriminators[val[discriminatorKey]]) {\n      embeddedSchemaType = discriminators[val[discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(discriminators, val[discriminatorKey]);\n      if (constructorByValue) {\n        embeddedSchemaType = constructorByValue;\n      }\n    }\n  }\n\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function(v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      return embeddedSchemaType.castForQuery(null, v, context);\n    });\n  } else {\n    val = embeddedSchemaType.castForQuery(null, val, context);\n  }\n\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\n/**\n * Add a virtual to this array. Specifically to this array, not the individual elements.\n *\n * @param {String} name\n * @param {Object} [options]\n * @api private\n */\n\nSchemaArray.prototype.virtual = function virtual(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    throw new MongooseError('Cannot set populate virtual as a property of an array');\n  }\n\n  const virtual = new VirtualType(options, name);\n  if (this.virtuals === null) {\n    this.virtuals = {};\n  }\n  this.virtuals[name] = virtual;\n  return virtual;\n};\n\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map((v) => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return { $elemMatch: cast(this.embeddedSchemaType.schema, v.$elemMatch, null, this?.$$context) };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.embeddedSchemaType.schema, o, null, this?.$$context)[this.path];\n  }, this);\n\n  return this.castForQuery(null, val, context);\n}\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  return val;\n}\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$all` is the function Mongoose calls to cast `$all` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaArray\n * @instance\n * @api public\n */\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val, context) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.embeddedSchemaType.schema ?? context.schema, obj, null, this?.$$context));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$not =\nhandle.$regex =\nhandle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaArray.prototype.toJSONSchema = function toJSONSchema(options) {\n  const embeddedSchemaType = this.getEmbeddedSchemaType();\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return {\n    ...createJSONSchemaTypeDefinition('array', 'array', options?.useBsonType, isRequired),\n    items: embeddedSchemaType.toJSONSchema(options)\n  };\n};\n\nSchemaArray.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'array';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}