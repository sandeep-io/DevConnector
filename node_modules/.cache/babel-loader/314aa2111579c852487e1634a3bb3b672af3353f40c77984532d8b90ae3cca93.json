{"ast":null,"code":"'use strict';\n\nconst get = require('./get');\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function (filter, schema, castedDoc, options) {\n  options = options || {};\n  const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert ?? schema.base.options.setDefaultsOnInsert;\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = {};\n  const updatedValues = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].charAt(0) === '$') {\n      hasDollarUpdate = true;\n      break;\n    }\n  }\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].charAt(0) === '$') {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n  }\n  if (options?.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n  schema.eachPath(function (path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (typeof def === 'undefined') {\n      return;\n    }\n    const pathPieces = schemaType.splitPath();\n    if (pathPieces.includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n    if (isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate)) {\n      return;\n    }\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n  return castedDoc;\n};\nfunction isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate) {\n  // Check if path is in filter (updatedKeys)\n  if (updatedKeys[path]) {\n    return true;\n  }\n\n  // Check if any parent path is in filter\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (updatedKeys[cur]) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if path is modified in the update\n  if (hasDollarUpdate) {\n    // Check each update operator\n    for (const key in castedDoc) {\n      if (key.charAt(0) === '$') {\n        if (pathExistsInUpdate(castedDoc[key], path, pathPieces)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    // No dollar operators, check the castedDoc directly\n    if (pathExistsInUpdate(castedDoc, path, pathPieces)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction pathExistsInUpdate(update, targetPath, pathPieces) {\n  if (update == null || typeof update !== 'object') {\n    return false;\n  }\n\n  // Check exact match\n  if (Object.hasOwn(update, targetPath)) {\n    return true;\n  }\n\n  // Check if any parent path exists\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (Object.hasOwn(update, cur)) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if any child path exists (e.g., path is \"a\" and update has \"a.b\")\n  const prefix = targetPath + '.';\n  for (const key in update) {\n    if (key.startsWith(prefix)) {\n      return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["get","require","module","exports","filter","schema","castedDoc","options","shouldSetDefaultsOnInsert","setDefaultsOnInsert","base","upsert","keys","Object","updatedKeys","updatedValues","numKeys","length","hasDollarUpdate","i","charAt","paths","numPaths","path","condition","conditionKeys","numConditionKeys","hasDollarKey","j","overwrite","eachPath","schemaType","auto","def","getDefault","pathPieces","splitPath","includes","isModified","$setOnInsert","cur","key","pathExistsInUpdate","update","targetPath","hasOwn","prefix","startsWith"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js"],"sourcesContent":["'use strict';\nconst get = require('./get');\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function(filter, schema, castedDoc, options) {\n  options = options || {};\n\n  const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert ?? schema.base.options.setDefaultsOnInsert;\n\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = {};\n  const updatedValues = {};\n  const numKeys = keys.length;\n\n  let hasDollarUpdate = false;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].charAt(0) === '$') {\n      hasDollarUpdate = true;\n      break;\n    }\n  }\n\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].charAt(0) === '$') {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n  }\n\n  if (options?.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n\n  schema.eachPath(function(path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (typeof def === 'undefined') {\n      return;\n    }\n    const pathPieces = schemaType.splitPath();\n    if (pathPieces.includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n    if (isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate)) {\n      return;\n    }\n\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n\n  return castedDoc;\n};\n\nfunction isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate) {\n  // Check if path is in filter (updatedKeys)\n  if (updatedKeys[path]) {\n    return true;\n  }\n\n  // Check if any parent path is in filter\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (updatedKeys[cur]) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if path is modified in the update\n  if (hasDollarUpdate) {\n    // Check each update operator\n    for (const key in castedDoc) {\n      if (key.charAt(0) === '$') {\n        if (pathExistsInUpdate(castedDoc[key], path, pathPieces)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    // No dollar operators, check the castedDoc directly\n    if (pathExistsInUpdate(castedDoc, path, pathPieces)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction pathExistsInUpdate(update, targetPath, pathPieces) {\n  if (update == null || typeof update !== 'object') {\n    return false;\n  }\n\n  // Check exact match\n  if (Object.hasOwn(update, targetPath)) {\n    return true;\n  }\n\n  // Check if any parent path exists\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (Object.hasOwn(update, cur)) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if any child path exists (e.g., path is \"a\" and update has \"a.b\")\n  const prefix = targetPath + '.';\n  for (const key in update) {\n    if (key.startsWith(prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}