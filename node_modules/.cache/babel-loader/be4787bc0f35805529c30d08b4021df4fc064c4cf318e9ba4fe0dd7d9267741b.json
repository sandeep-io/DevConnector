{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseError = require('./error/mongooseError');\nconst SchemaType = require('./schemaType');\nconst SchemaTypeOptions = require('./options/schemaTypeOptions');\nconst VirtualOptions = require('./options/virtualOptions');\nconst VirtualType = require('./virtualType');\nconst addAutoId = require('./helpers/schema/addAutoId');\nconst clone = require('./helpers/clone');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getIndexes = require('./helpers/schema/getIndexes');\nconst handleReadPreferenceAliases = require('./helpers/query/handleReadPreferenceAliases');\nconst idGetter = require('./helpers/schema/idGetter');\nconst isIndexSpecEqual = require('./helpers/indexes/isIndexSpecEqual');\nconst merge = require('./helpers/schema/merge');\nconst mpath = require('mpath');\nconst setPopulatedVirtualValue = require('./helpers/populate/setPopulatedVirtualValue');\nconst setupTimestamps = require('./helpers/timestamps/setupTimestamps');\nconst symbols = require('./schema/symbols');\nconst utils = require('./utils');\nconst validateRef = require('./helpers/populate/validateRef');\nconst hasNumericSubpathRegex = /\\.\\d+(\\.|$)/;\nlet MongooseTypes;\nconst queryHooks = require('./constants').queryMiddlewareFunctions;\nconst documentHooks = require('./constants').documentMiddlewareFunctions;\nconst hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), new Set());\nconst isPOJO = utils.isPOJO;\nlet id = 0;\nconst numberRE = /^\\d+$/;\n\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](https://mongoosejs.com/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](https://mongoosejs.com/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](https://mongoosejs.com/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](https://mongoosejs.com/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](https://mongoosejs.com/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](https://mongoosejs.com/docs/guide.html#collection): string - no default\n * - [discriminatorKey](https://mongoosejs.com/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](https://mongoosejs.com/docs/guide.html#id): bool - defaults to true\n * - [_id](https://mongoosejs.com/docs/guide.html#_id): bool - defaults to true\n * - [minimize](https://mongoosejs.com/docs/guide.html#minimize): bool - controls [document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) behavior when called manually - defaults to true\n * - [read](https://mongoosejs.com/docs/guide.html#read): string\n * - [readConcern](https://mongoosejs.com/docs/guide.html#readConcern): object - defaults to null, use to set a default [read concern](https://www.mongodb.com/docs/manual/reference/read-concern/) for all queries.\n * - [writeConcern](https://mongoosejs.com/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://www.mongodb.com/docs/manual/reference/write-concern/)\n * - [shardKey](https://mongoosejs.com/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](https://mongoosejs.com/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](https://mongoosejs.com/docs/guide.html#toJSON) - object - no default\n * - [toObject](https://mongoosejs.com/docs/guide.html#toObject) - object - no default\n * - [typeKey](https://mongoosejs.com/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](https://mongoosejs.com/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [validateModifiedOnly](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) - bool - defaults to `false`\n * - [versionKey](https://mongoosejs.com/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](https://mongoosejs.com/docs/guide.html#optimisticConcurrency): bool or string[] or { exclude: string[] } - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html) for all fields. Set to a string array to enable optimistic concurrency only for the specified fields; note that this **replaces** the default array versioning behavior. Set to `{ exclude: string[] }` to enable optimistic concurrency for all fields except the specified ones; this also replaces the default array versioning.\n * - [collation](https://mongoosejs.com/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](https://mongoosejs.com/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](https://mongoosejs.com/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](https://mongoosejs.com/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](https://mongoosejs.com/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n * - [virtuals](https://mongoosejs.com/docs/tutorials/virtuals.html#virtuals-via-schema-options): object - virtuals to define, alias for [`.virtual`](https://mongoosejs.com/docs/api/schema.html#Schema.prototype.virtual())\n * - [collectionOptions]: object with options passed to [`createCollection()`](https://www.mongodb.com/docs/manual/reference/method/db.createCollection/) when calling `Model.createCollection()` or `autoCreate` set to true.\n * - [encryptionType]: the encryption type for the schema.  Valid options are `csfle` or `queryableEncryption`.  See https://mongoosejs.com/docs/field-level-encryption.\n * - [lean]: boolean - set to true to make all queries use [lean](https://mongoosejs.com/docs/tutorials/lean.html) by default. Defaults to false.\n *\n * #### Options for Nested Schemas:\n *\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this._searchIndexes = [];\n  this.methods = options?.methods || {};\n  this.methodOptions = {};\n  this.statics = options?.statics || {};\n  this.tree = {};\n  this.query = options?.query || {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n  this.encryptedFields = {};\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // build virtual paths\n  if (options?.virtuals) {\n    const virtuals = options.virtuals;\n    const pathNames = Object.keys(virtuals);\n    for (const pathName of pathNames) {\n      const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;\n      const virtual = this.virtual(pathName, pathOptions);\n      if (virtuals[pathName].get) {\n        virtual.get(virtuals[pathName].get);\n      }\n      if (virtuals[pathName].set) {\n        virtual.set(virtuals[pathName].set);\n      }\n    }\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj?._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] && this.options._id && !_idSubDoc;\n  if (auto_id) {\n    addAutoId(this);\n  }\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/**\n * Create virtual properties with alias field\n * @api private\n */\nfunction aliasFields(schema, paths) {\n  for (const path of Object.keys(paths)) {\n    let alias = null;\n    if (paths[path] != null) {\n      alias = paths[path];\n    } else {\n      const options = get(schema.paths[path], 'options');\n      if (options == null) {\n        continue;\n      }\n      alias = options.alias;\n    }\n    if (!alias) {\n      continue;\n    }\n    const prop = schema.paths[path].path;\n    if (Array.isArray(alias)) {\n      for (const a of alias) {\n        if (typeof a !== 'string') {\n          throw new Error('Invalid value for alias option on ' + prop + ', got ' + a);\n        }\n        schema.aliases[a] = prop;\n        schema.virtual(a).get(function (p) {\n          return function () {\n            if (typeof this.get === 'function') {\n              return this.get(p);\n            }\n            return this[p];\n          };\n        }(prop)).set(function (p) {\n          return function (v) {\n            return this.$set(p, v);\n          };\n        }(prop));\n      }\n      continue;\n    }\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n    schema.aliases[alias] = prop;\n    schema.virtual(alias).get(function (p) {\n      return function () {\n        if (typeof this.get === 'function') {\n          return this.get(p);\n        }\n        return this[p];\n      };\n    }(prop)).set(function (p) {\n      return function (v) {\n        return this.$set(p, v);\n      };\n    }(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * #### Example:\n *\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Creates a new schema with the given definition and options. Equivalent to `new Schema(definition, options)`.\n *\n * `Schema.create()` is primarily useful for automatic schema type inference in TypeScript.\n *\n * #### Example:\n *\n *     const schema = Schema.create({ name: String }, { toObject: { virtuals: true } });\n *     // Equivalent:\n *     const schema2 = new Schema({ name: String }, { toObject: { virtuals: true } });\n *\n * @param {Object} definition\n * @param {Object} [options]\n * @return {Schema} the new schema\n * @api public\n * @memberOf Schema\n * @static\n */\n\nSchema.create = function create(definition, options) {\n  return new Schema(definition, options);\n};\n\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function () {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n  return s;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = clone(this.options);\n  s.callQueue = this.callQueue.map(function (f) {\n    return f;\n  });\n  s.methods = clone(this.methods);\n  s.methodOptions = clone(this.methodOptions);\n  s.statics = clone(this.statics);\n  s.query = clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = clone(this._indexes);\n  s._searchIndexes = clone(this._searchIndexes);\n  s.s.hooks = this.s.hooks.clone();\n  s.tree = clone(this.tree);\n  s.paths = Object.fromEntries(Object.entries(this.paths).map(([key, value]) => [key, value.clone()]));\n  s.nested = clone(this.nested);\n  s.subpaths = clone(this.subpaths);\n  for (const schemaType of Object.values(s.paths)) {\n    if (schemaType.$isSingleNested) {\n      const path = schemaType.path;\n      for (const key of Object.keys(schemaType.schema.paths)) {\n        s.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n        s.singleNestedPaths[path + '.' + key] = schemaType.schema.singleNestedPaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.subpaths)) {\n        s.singleNestedPaths[path + '.' + key] = schemaType.schema.subpaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.nested)) {\n        s.singleNestedPaths[path + '.' + key] = 'nested';\n      }\n    }\n  }\n  s._gatherChildSchemas();\n  s.virtuals = clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = new Map(this._applyDiscriminators);\n  }\n  s.aliases = Object.assign({}, this.aliases);\n  s.encryptedFields = clone(this.encryptedFields);\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to pick for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function (paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' + 'got \"' + typeof paths + '\"');\n  }\n  for (const path of paths) {\n    if (this._hasEncryptedField(path)) {\n      const encrypt = this.encryptedFields[path];\n      const schemaType = this.path(path);\n      newSchema.add({\n        [path]: {\n          encrypt,\n          [this.options.typeKey]: schemaType\n        }\n      });\n    } else if (this.nested[path]) {\n      newSchema.add({\n        [path]: get(this.tree, path)\n      });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({\n        [path]: schematype\n      });\n    }\n  }\n  if (!this._hasEncryptedFields()) {\n    newSchema.options.encryptionType = null;\n  }\n  return newSchema;\n};\n\n/**\n * Returns a new schema that has the `paths` from the original schema, minus the omitted ones.\n *\n * This method is analagous to [Lodash's `omit()` function](https://lodash.com/docs/#omit) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema omitting the `age` path\n *     const newSchema = schema.omit(['age']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to omit for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.omit = function (paths, options) {\n  const newSchema = new Schema(this, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#omit() only accepts an array argument, ' + 'got \"' + typeof paths + '\"');\n  }\n  newSchema.remove(paths);\n  for (const nested in newSchema.singleNestedPaths) {\n    if (paths.includes(nested)) {\n      delete newSchema.singleNestedPaths[nested];\n    }\n  }\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} [options] Options to overwrite the default options\n * @return {Object} The merged options of `options` and the default options\n * @api private\n */\n\nSchema.prototype.defaultOptions = function (options) {\n  this._userProvidedOptions = options == null ? {} : clone(options);\n  const baseOptions = this.base?.options || {};\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  const strictQuery = 'strictQuery' in baseOptions ? baseOptions.strictQuery : false;\n  const id = 'id' in baseOptions ? baseOptions.id : true;\n  options = {\n    strict,\n    strictQuery,\n    bufferCommands: true,\n    capped: false,\n    // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    validateModifiedOnly: false,\n    // the following are only applied at construction time\n    _id: true,\n    id: id,\n    typeKey: 'type',\n    ...options\n  };\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + typeof options.versionKey + '`');\n  }\n  if (typeof options.read === 'string') {\n    options.read = handleReadPreferenceAliases(options.read);\n  } else if (Array.isArray(options.read) && typeof options.read[0] === 'string') {\n    options.read = {\n      mode: handleReadPreferenceAliases(options.read[0]),\n      tags: options.read[1]\n    };\n  }\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n  return options;\n};\n\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * #### Example:\n *\n *     const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });\n *\n *     const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });\n *     const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);\n *\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.discriminators['clicked']; // Model { clicked }\n *\n *     const doc = await Event.create({ kind: 'clicked', element: '#hero' });\n *     doc.element; // '#hero'\n *     doc instanceof ClickedModel; // true\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the discriminated Schema\n * @param {Object} [options] discriminator options\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.discriminator = function (name, schema, options) {\n  this._applyDiscriminators = this._applyDiscriminators || new Map();\n  this._applyDiscriminators.set(name, {\n    schema,\n    options\n  });\n  return this;\n};\n\n/*!\n * Get the document middleware for this schema, filtering out any hooks that are specific to queries.\n */\nSchema.prototype._getDocumentMiddleware = function _getDocumentMiddleware() {\n  return this.s.hooks.filter(hook => {\n    if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n      return !!hook['document'];\n    }\n    if (hook.name === 'remove' || hook.name === 'init') {\n      return hook['document'] == null || !!hook['document'];\n    }\n    if (hook.query != null || hook.document != null) {\n      return hook.document !== false;\n    }\n    return true;\n  }).filter(hook => {\n    // If user has overwritten the method, don't apply built-in middleware\n    if (this.methods[hook.name]) {\n      return !hook.fn[symbols.builtInMiddleware];\n    }\n    return true;\n  });\n};\n\n/*!\n * Get this schema's default toObject/toJSON options, including Mongoose global\n * options.\n */\n\nSchema.prototype._defaultToObjectOptions = function (json) {\n  const path = json ? 'toJSON' : 'toObject';\n  if (this._defaultToObjectOptionsMap && this._defaultToObjectOptionsMap[path]) {\n    return this._defaultToObjectOptionsMap[path];\n  }\n  const baseOptions = this.base?.options?.[path] || {};\n  const schemaOptions = this.options[path] || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  const defaultOptions = Object.assign({}, baseOptions, schemaOptions);\n  this._defaultToObjectOptionsMap = this._defaultToObjectOptionsMap || {};\n  this._defaultToObjectOptionsMap[path] = defaultOptions;\n  return defaultOptions;\n};\n\n/**\n * Sets the encryption type of the schema, if a value is provided, otherwise\n * returns the encryption type.\n *\n * @param {'csfle' | 'queryableEncryption' | null | undefined} encryptionType plain object with paths to add, or another schema\n */\nSchema.prototype.encryptionType = function encryptionType(encryptionType) {\n  if (arguments.length === 0) {\n    return this.options.encryptionType;\n  }\n  if (!(typeof encryptionType === 'string' || encryptionType === null)) {\n    throw new Error('invalid `encryptionType`: ${encryptionType}');\n  }\n  this.options.encryptionType = encryptionType;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || obj?.instanceOfSchema) {\n    merge(this, obj);\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    if (utils.specialProperties.has(key)) {\n      continue;\n    }\n    const fullPath = prefix + key;\n    const val = obj[key];\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath + '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    // Deprecate setting schema paths to primitive types (gh-7558)\n    let isMongooseTypeString = false;\n    if (typeof val === 'string') {\n      // Handle the case in which the type is specified as a string (eg. 'date', 'oid', ...)\n      const MongooseTypes = this.base?.Schema.Types ?? Schema.Types;\n      const upperVal = val.charAt(0).toUpperCase() + val.substring(1);\n      isMongooseTypeString = MongooseTypes[upperVal] != null;\n    }\n    if (key !== '_id' && (typeof val !== 'object' && typeof val !== 'function' && !isMongooseTypeString || val == null)) {\n      throw new TypeError(`Invalid schema configuration: \\`${val}\\` is not ` + `a valid type at path \\`${key}\\`. See ` + 'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n    }\n    if (val instanceof VirtualType || (val.constructor?.name ?? null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath + '`, got value \"' + val[0] + '\"');\n    }\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (!val[0]?.instanceOfSchema && utils.isPOJO(val[0]?.discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      }\n    } else if (utils.hasOwnKeys(val) === false) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || typeKey === 'type' && isPOJO(val.type) && val.type.type) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && utils.hasOwnKeys(_typeDef)) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        const childSchemaOptions = {};\n        if (this._userProvidedOptions.typeKey) {\n          childSchemaOptions.typeKey = this._userProvidedOptions.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (this._userProvidedOptions.strict != null) {\n          childSchemaOptions.strict = this._userProvidedOptions.strict;\n        }\n        if (this._userProvidedOptions.toObject != null) {\n          childSchemaOptions.toObject = utils.omit(this._userProvidedOptions.toObject, ['transform']);\n        }\n        if (this._userProvidedOptions.toJSON != null) {\n          childSchemaOptions.toJSON = utils.omit(this._userProvidedOptions.toJSON, ['transform']);\n        }\n        const _schema = new Schema(_typeDef, childSchemaOptions);\n        _schema.$implicitlyCreated = true;\n        const schemaWrappedPath = Object.assign({}, val, {\n          [typeKey]: _schema\n        });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (!val?.instanceOfSchema && utils.isPOJO(val?.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n    if (val.instanceOfSchema && val.encryptionType() != null) {\n      // schema.add({ field: <instance of encrypted schema> })\n      if (this.encryptionType() != val.encryptionType()) {\n        throw new Error('encryptionType of a nested schema must match the encryption type of the parent schema.');\n      }\n      for (const [encryptedField, encryptedFieldConfig] of Object.entries(val.encryptedFields)) {\n        const path = fullPath + '.' + encryptedField;\n        this._addEncryptedField(path, encryptedFieldConfig);\n      }\n    } else if (typeof val === 'object' && 'encrypt' in val) {\n      // schema.add({ field: { type: <schema type>, encrypt: { ... }}})\n      const {\n        encrypt\n      } = val;\n      if (this.encryptionType() == null) {\n        throw new Error('encryptionType must be provided');\n      }\n      this._addEncryptedField(fullPath, encrypt);\n    } else {\n      // if the field was already encrypted and we re-configure it to be unencrypted, remove\n      // the encrypted field configuration\n      this._removeEncryptedField(fullPath);\n    }\n  }\n  const aliasObj = Object.fromEntries(Object.entries(obj).map(([key]) => [prefix + key, null]));\n  aliasFields(this, aliasObj);\n  return this;\n};\n\n/**\n * @param {string} path\n * @param {object} fieldConfig\n *\n * @api private\n */\nSchema.prototype._addEncryptedField = function _addEncryptedField(path, fieldConfig) {\n  const type = this.path(path).autoEncryptionType();\n  if (type == null) {\n    throw new Error(`Invalid BSON type for FLE field: '${path}'`);\n  }\n  this.encryptedFields[path] = clone(fieldConfig);\n};\n\n/**\n * @param {string} path\n *\n * @api private\n */\nSchema.prototype._removeEncryptedField = function _removeEncryptedField(path) {\n  delete this.encryptedFields[path];\n};\n\n/**\n * @api private\n *\n * @returns {boolean}\n */\nSchema.prototype._hasEncryptedFields = function _hasEncryptedFields() {\n  return utils.hasOwnKeys(this.encryptedFields);\n};\n\n/**\n * @param {string} path\n * @returns {boolean}\n *\n * @api private\n */\nSchema.prototype._hasEncryptedField = function _hasEncryptedField(path) {\n  return path in this.encryptedFields;\n};\n\n/**\n * Builds an encryptedFieldsMap for the schema.\n *\n * @api private\n */\nSchema.prototype._buildEncryptedFields = function () {\n  const fields = Object.entries(this.encryptedFields).map(([path, config]) => {\n    const bsonType = this.path(path).autoEncryptionType();\n    // { path, bsonType, keyId, queries? }\n    return {\n      path,\n      bsonType,\n      ...config\n    };\n  });\n  return {\n    fields\n  };\n};\n\n/**\n * Builds a schemaMap for the schema, if the schema is configured for client-side field level encryption.\n *\n * @api private\n */\nSchema.prototype._buildSchemaMap = function () {\n  /**\n   * `schemaMap`s are JSON schemas, which use the following structure to represent objects:\n   *    { field: { bsonType: 'object', properties: { ... } } }\n   *\n   * for example, a schema that looks like this `{ a: { b: int32 } }` would be encoded as\n   * `{ a: { bsonType: 'object', properties: { b: < encryption configuration > } } }`\n   *\n   * This function takes an array of path segments, an output object (that gets mutated) and\n   * a value to be associated with the full path, and constructs a valid CSFLE JSON schema path for\n   * the object.  This works for deeply nested properties as well.\n   *\n   * @param {string[]} path array of path components\n   * @param {object} object the object in which to build a JSON schema of `path`'s properties\n   * @param {object} value the value to associate with the path in object\n   */\n  function buildNestedPath(path, object, value) {\n    let i = 0,\n      component = path[i];\n    for (; i < path.length - 1; ++i, component = path[i]) {\n      object[component] = object[component] == null ? {\n        bsonType: 'object',\n        properties: {}\n      } : object[component];\n      object = object[component].properties;\n    }\n    object[component] = value;\n  }\n  const schemaMapPropertyReducer = (accum, [path, propertyConfig]) => {\n    const bsonType = this.path(path).autoEncryptionType();\n    const pathComponents = path.split('.');\n    const configuration = {\n      encrypt: {\n        ...propertyConfig,\n        bsonType\n      }\n    };\n    buildNestedPath(pathComponents, accum, configuration);\n    return accum;\n  };\n  const properties = Object.entries(this.encryptedFields).reduce(schemaMapPropertyReducer, {});\n  return {\n    bsonType: 'object',\n    properties\n  };\n};\n\n/**\n * Add an alias for `path`. This means getting or setting the `alias`\n * is equivalent to getting or setting the `path`.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ n: String });\n *\n *     // Make 'name' an alias for 'n'\n *     toySchema.alias('n', 'name');\n *\n *     const Toy = mongoose.model('Toy', toySchema);\n *     const turboMan = new Toy({ n: 'Turbo Man' });\n *\n *     turboMan.name; // 'Turbo Man'\n *     turboMan.n; // 'Turbo Man'\n *\n *     turboMan.name = 'Turbo Man Action Figure';\n *     turboMan.n; // 'Turbo Man Action Figure'\n *\n *     await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }\n *\n *\n * @param {String} path real path to alias\n * @param {String|String[]} alias the path(s) to use as an alias for `path`\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.alias = function alias(path, alias) {\n  aliasFields(this, {\n    [path]: alias\n  });\n  return this;\n};\n\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (isIndexSpecEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n  return this;\n};\n\n/**\n * Add an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) that Mongoose will create using `Model.createSearchIndex()`.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.searchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *\n * @param {Object} description index options, including `name` and `definition`\n * @param {String} description.name\n * @param {Object} description.definition\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.searchIndex = function searchIndex(description) {\n  this._searchIndexes.push(description);\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n *\n * @property reserved\n * @memberOf Schema\n * @static\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit = reserved.listeners = reserved.removeListener =\n// document properties and functions\nreserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;\nreserved.collection = 1;\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example:\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path The name of the Path to get / set\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n * @api public\n */\n\nSchema.prototype.path = function (path, obj) {\n  if (obj === undefined) {\n    if (this.paths[path] != null) {\n      return this.paths[path];\n    }\n    // Convert to '.$' to check subpaths re: gh-6405\n    const cleanPath = _pathToPositionalSyntax(path);\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return hasNumericSubpathRegex.test(path) ? getPositionalPath(this, path, cleanPath) : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.suppressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` + 'You are allowed to use it, but use at your own risk. ' + 'To disable this warning pass `suppressReservedKeysWarning` as a schema option.';\n    utils.warn(errorMessage);\n  }\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n  for (const sub of subpaths) {\n    if (utils.specialProperties.has(sub)) {\n      throw new Error('Cannot set special property `' + sub + '` on a schema');\n    }\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. ' + 'Parent path `' + fullPath + '` already set to type ' + branch[sub].name + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n  branch[last] = clone(obj);\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  // If overwriting an existing path, make sure to clear the childSchemas\n  this.childSchemas = this.childSchemas.filter(childSchema => childSchema.path !== path);\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n    if (schemaType.$__schemaType.$isSingleNested) {\n      this.childSchemas.push({\n        schema: schemaType.$__schemaType.schema,\n        model: schemaType.$__schemaType.Constructor,\n        path: path\n      });\n    }\n  }\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n    schemaType.Constructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.Constructor,\n      path: path\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n    schemaType.Constructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.Constructor,\n      path: path\n    });\n  }\n  if (schemaType.$isMongooseArray && !schemaType.$isMongooseDocumentArray) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n      _schemaType.embeddedSchemaType._arrayPath = arrayPath;\n      _schemaType.embeddedSchemaType._arrayParentPath = path;\n      _schemaType = _schemaType.embeddedSchemaType;\n      this.subpaths[arrayPath] = _schemaType;\n    }\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._gatherChildSchemas = function _gatherChildSchemas() {\n  const childSchemas = [];\n  for (const path of Object.keys(this.paths)) {\n    if (typeof path !== 'string') {\n      continue;\n    }\n    const schematype = this.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({\n        schema: schematype.schema,\n        model: schematype.Constructor,\n        path: path\n      });\n    } else if (schematype.$isSchemaMap && schematype.$__schemaType.$isSingleNested) {\n      childSchemas.push({\n        schema: schematype.$__schemaType.schema,\n        model: schematype.$__schemaType.Constructor,\n        path: path\n      });\n    }\n  }\n  this.childSchemas = childSchemas;\n  return childSchemas;\n};\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (Object.hasOwn(schema.paths, path)) {\n    return schema.paths[path];\n  }\n  if (Object.hasOwn(schema.subpaths, cleanPath)) {\n    const subpath = schema.subpaths[cleanPath];\n    if (subpath === 'nested') {\n      return undefined;\n    }\n    return subpath;\n  }\n  if (Object.hasOwn(schema.singleNestedPaths, cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    const singleNestedPath = schema.singleNestedPaths[cleanPath];\n    if (singleNestedPath === 'nested') {\n      return undefined;\n    }\n    return singleNestedPath;\n  }\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const cleanPath = val.path.replace(/\\.\\$\\*/g, '');\n    if (path === cleanPath || path.startsWith(cleanPath + '.') && path.slice(cleanPath.length + 1).indexOf('.') === -1) {\n      return val;\n    } else if (val.schema && path.startsWith(cleanPath + '.')) {\n      let remnant = path.slice(cleanPath.length + 1);\n      remnant = remnant.slice(remnant.indexOf('.') + 1);\n      return val.schema.paths[remnant];\n    } else if (val.$isSchemaMap && path.startsWith(cleanPath + '.')) {\n      let remnant = path.slice(cleanPath.length + 1);\n      remnant = remnant.slice(remnant.indexOf('.') + 1);\n      const presplitPath = val.$__schemaType._presplitPath;\n      if (remnant.indexOf('.') === -1 && presplitPath[presplitPath.length - 1] === '$*') {\n        // Handle map of map of primitives\n        return val.$__schemaType;\n      } else if (remnant.indexOf('.') !== -1 && val.$__schemaType.schema && presplitPath[presplitPath.length - 1] === '$*') {\n        // map of map of subdocs (recursive)\n        return val.$__schemaType.schema.path(remnant.slice(remnant.indexOf('.') + 1));\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @param {Object} options schema options\n * @api private\n */\n\nSchema.prototype.interpretAsType = function (path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base?.Schema.Types ?? Schema.Types;\n  const Types = this.base?.Types ?? require('./types');\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type) ? obj[options.typeKey] : {};\n  if (type instanceof SchemaType) {\n    if (type.path === path) {\n      return type;\n    }\n    const clone = type.clone();\n    clone.path = path;\n    return clone;\n  }\n  let name;\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj, null, this);\n  }\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = type === Array || type === 'array' ? obj.cast || obj.of : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast?.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast = new Schema(cast);\n        } else {\n          throw new TypeError('Schema for array path `' + path + '` is from a different copy of the Mongoose module. ' + 'Please make sure you\\'re using the same version ' + 'of Mongoose everywhere with `npm list mongoose`. If you are still ' + 'getting this error, please add `new Schema()` around the path: ' + `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj, null, this);\n    }\n    if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast[options.typeKey] = new Schema(cast[options.typeKey]);\n        } else {\n          throw new TypeError('Schema for array path `' + path + '` is from a different copy of the Mongoose module. ' + 'Please make sure you\\'re using the same version ' + 'of Mongoose everywhere with `npm list mongoose`. If you are still ' + 'getting this error, please add `new Schema()` around the path: ' + `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast, this);\n    }\n    if (typeof cast !== 'undefined') {\n      if (Array.isArray(cast) || cast.type === Array || cast.type == 'Array') {\n        if (cast?.type == 'Array') {\n          cast.type = Array;\n        }\n        return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj, null, this);\n      }\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type) ? cast[options.typeKey] : cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (utils.hasOwnKeys(castFromTypeKey)) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = {\n          minimize: options.minimize\n        };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (Object.hasOwn(options, 'strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        if (Object.hasOwn(options, 'strictQuery')) {\n          childSchemaOptions.strictQuery = options.strictQuery;\n        }\n        if (Object.hasOwn(options, 'toObject')) {\n          childSchemaOptions.toObject = utils.omit(options.toObject, ['transform']);\n        }\n        if (Object.hasOwn(options, 'toJSON')) {\n          childSchemaOptions.toJSON = utils.omit(options.toJSON, ['transform']);\n        }\n        if (Object.hasOwn(this._userProvidedOptions, '_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj, null, this);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj, null, this);\n      }\n    }\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type) ? cast[options.typeKey] : cast;\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj, null, this);\n      }\n      name = typeof type === 'string' ? type : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' + `Could not determine the embedded type for array \\`${path}\\`. ` + 'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!Object.hasOwn(MongooseTypes, name)) {\n        throw new TypeError('Invalid schema configuration: ' + `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` + 'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n      if (name === 'Union' && typeof cast === 'object') {\n        cast.parentSchema = this;\n      }\n    }\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options, this);\n  }\n  if (type?.instanceOfSchema) {\n    return new MongooseTypes.Subdocument(type, path, obj, this);\n  }\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else if (type === Types.ObjectId) {\n    name = 'ObjectId';\n  } else if (type === Types.Decimal128) {\n    name = 'Decimal128';\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` + 'invalid. See ' + 'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` + `a valid type at path \\`${path}\\`. See ` + 'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n  const schemaType = new MongooseTypes[name](path, obj, options, this);\n  return schemaType;\n};\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function (fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate Refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function (path) {\n  if (Object.hasOwn(this.paths, path)) {\n    return 'real';\n  }\n  if (Object.hasOwn(this.virtuals, path)) {\n    return 'virtual';\n  }\n  if (Object.hasOwn(this.nested, path)) {\n    return 'nested';\n  }\n\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n  if (Object.hasOwn(this.subpaths, cleanPath) || Object.hasOwn(this.subpaths, path)) {\n    return 'real';\n  }\n  const singleNestedPath = Object.hasOwn(this.singleNestedPaths, cleanPath) || Object.hasOwn(this.singleNestedPaths, path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path, cleanPath);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function (path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (Object.hasOwn(this.paths, path) && this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function (timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/**\n * ignore. Deprecated re: #6405\n * @param {Any} self\n * @param {String} path\n * @api private\n */\n\nfunction getPositionalPathType(self, path, cleanPath) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return Object.hasOwn(self.paths, subpaths[0]) ? self.paths[subpaths[0]] : 'adhocOrUndefined';\n  }\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n  const last = subpaths.length - 1;\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.embeddedSchemaType;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.embeddedSchemaType;\n      }\n      continue;\n    }\n    if (!val?.schema) {\n      val = undefined;\n      break;\n    }\n    const type = val.schema.pathType(subpath);\n    isNested = type === 'nested';\n    val = val.schema.path(subpath);\n  }\n  self.subpaths[cleanPath] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path, cleanPath) {\n  getPositionalPathType(self, path, cleanPath);\n  return self.subpaths[cleanPath];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function (name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the model.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function() {\n *       if (!this.created) this.created = new Date;\n *     });\n *\n *     toySchema.pre('validate', function() {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function() {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function() {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function (name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     await m.save();\n *     console.log('this fires after the `post` hook');\n *\n *     await m.find();\n *     console.log('this fires after the post find hook');\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function (name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * Or with Options:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\n *\n * @param {Function} plugin The Plugin's callback\n * @param {Object} [opts] Options to pass to the plugin\n * @param {Boolean} [opts.deduplicate=false] If true, ignore duplicate plugins (same `fn` argument using `===`)\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nSchema.prototype.plugin = function (fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' + 'got \"' + typeof fn + '\"');\n  }\n  if (opts?.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({\n    fn: fn,\n    opts: opts\n  });\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     const fizz = new Kitty;\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](https://mongoosejs.com/docs/guide.html#methods)\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n */\n\nSchema.prototype.method = function (name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.static({\n *         findByName: function () {..}\n *       , findByCost: function () {..}\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *     await Drink.findByCost(3);\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n * @see Statics https://mongoosejs.com/docs/guide.html#statics\n */\n\nSchema.prototype.static = function (name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example:\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @param {String} [options.language_override=null] Tells mongodb to use the specified field instead of `language` for parsing text indexes.\n * @api public\n */\n\nSchema.prototype.index = function (fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n  if (options.expires) {\n    utils.expires(options);\n  }\n  for (const key in fields) {\n    if (this.aliases[key]) {\n      fields = utils.renameObjKey(fields, key, this.aliases[key]);\n    }\n  }\n  for (const field of Object.keys(fields)) {\n    if (fields[field] === 'ascending' || fields[field] === 'asc') {\n      fields[field] = 1;\n    } else if (fields[field] === 'descending' || fields[field] === 'desc') {\n      fields[field] = -1;\n    }\n  }\n  for (const existingIndex of this.indexes()) {\n    if (options.name == null && existingIndex[1].name == null && isIndexSpecEqual(existingIndex[0], fields)) {\n      utils.warn(`Duplicate schema index on ${JSON.stringify(fields)} found. This is often due to declaring an index using both \"index: true\" and \"schema.index()\". Please remove the duplicate index definition.`);\n    }\n  }\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets a schema option.\n *\n * #### Example:\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key The name of the option to set the value to\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\n * @param {Array<string>} [tags] tags to add to read preference if key === 'read'\n * @see Schema https://mongoosejs.com/docs/api/schema.html#Schema()\n * @api public\n */\n\nSchema.prototype.set = function (key, value, tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n  switch (key) {\n    case 'read':\n      if (typeof value === 'string') {\n        this.options[key] = {\n          mode: handleReadPreferenceAliases(value),\n          tags\n        };\n      } else if (Array.isArray(value) && typeof value[0] === 'string') {\n        this.options[key] = {\n          mode: handleReadPreferenceAliases(value[0]),\n          tags: value[1]\n        };\n      } else {\n        this.options[key] = value;\n      }\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  // Propagate `strict` and `strictQuery` changes down to implicitly created schemas\n  if (key === 'strict') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, {\n      strict: value\n    });\n  }\n  if (key === 'strictQuery') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, {\n      strictQuery: value\n    });\n  }\n  if (key === 'toObject') {\n    value = {\n      ...value\n    };\n    // Avoid propagating transform to implicitly created schemas re: gh-3279\n    delete value.transform;\n    _propagateOptionsToImplicitlyCreatedSchemas(this, {\n      toObject: value\n    });\n  }\n  if (key === 'toJSON') {\n    value = {\n      ...value\n    };\n    // Avoid propagating transform to implicitly created schemas re: gh-3279\n    delete value.transform;\n    _propagateOptionsToImplicitlyCreatedSchemas(this, {\n      toJSON: value\n    });\n  }\n  return this;\n};\n\n/*!\n * Recursively set options on implicitly created schemas\n */\n\nfunction _propagateOptionsToImplicitlyCreatedSchemas(baseSchema, options) {\n  for (const {\n    schema\n  } of baseSchema.childSchemas) {\n    if (!schema.$implicitlyCreated) {\n      continue;\n    }\n    Object.assign(schema.options, options);\n    _propagateOptionsToImplicitlyCreatedSchemas(schema, options);\n  }\n}\n\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key The name of the Option to get the current value for\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function (key) {\n  return this.options[key];\n};\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\n/**\n * The allowed index types\n *\n * @property {String[]} indexTypes\n * @memberOf Schema\n * @static\n * @api public\n */\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function () {\n    return indexTypes;\n  },\n  set: function () {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true } ],\n *     //   [ { registeredAt: 1 }, {} ] ]\n *     userSchema.indexes();\n *\n * [Plugins](https://mongoosejs.com/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function () {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name The name of the Virtual\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](https://mongoosejs.com/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @param {Object|Function} [options.match=null] Apply a default [`match` option to populate](https://mongoosejs.com/docs/populate.html#match), adding an additional filter to the populate query.\n * @param {Boolean} [options.applyToArray=false] If true and the given `name` is a direct child of an array, apply the virtual to the array rather than the elements.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function (name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n    const virtual = this.virtual(name);\n    virtual.options = options;\n    this.pre('init', function virtualPreInit(obj, opts) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];\n        }\n        if (opts?.hydratedPopulatedDocs && !options.count) {\n          const modelNames = virtual._getModelNamesForPopulate(this);\n          const populatedVal = this.$$populatedVirtuals[name];\n          if (!Array.isArray(populatedVal) && !populatedVal.$__ && modelNames?.length === 1) {\n            const PopulateModel = this.db.model(modelNames[0]);\n            this.$$populatedVirtuals[name] = PopulateModel.hydrate(populatedVal);\n          } else if (Array.isArray(populatedVal) && modelNames?.length === 1) {\n            const PopulateModel = this.db.model(modelNames[0]);\n            for (let i = 0; i < populatedVal.length; ++i) {\n              if (!populatedVal[i].$__) {\n                populatedVal[i] = PopulateModel.hydrate(populatedVal[i], null, {\n                  hydratedPopulatedDocs: true\n                });\n              }\n            }\n            const foreignField = options.foreignField;\n            this.$populated(name, populatedVal.map(doc => doc == null ? doc : doc.get(typeof foreignField === 'function' ? foreignField.call(doc, doc) : foreignField)), {\n              populateModelSymbol: PopulateModel\n            });\n          }\n        }\n        mpath.unset(name, obj);\n      }\n    });\n    virtual.set(function (v) {\n      if (!this.$$populatedVirtuals) {\n        this.$$populatedVirtuals = {};\n      }\n      return setPopulatedVirtualValue(this.$$populatedVirtuals, name, v, options);\n    });\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210, gh-13189\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] == null) {\n        continue;\n      }\n      if (this.paths[cur].$isMongooseDocumentArray || this.paths[cur].$isSingleNested) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      } else if (this.paths[cur].$isSchemaMap) {\n        const remnant = parts.slice(i + 2).join('.');\n        this.paths[cur].$__schemaType.schema.virtual(remnant, options);\n        break;\n      }\n      cur += '.' + parts[i + 1];\n    }\n    return virtual;\n  }\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' + ' conflicts with a real path in the schema');\n  }\n  virtuals[name] = parts.reduce(function (mem, part, i) {\n    mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});\n    return mem[part];\n  }, this.tree);\n  if (options?.applyToArray && parts.length > 1) {\n    const path = this.path(parts.slice(0, -1).join('.'));\n    if (path?.$isMongooseArray) {\n      return path.virtual(parts[parts.length - 1], options);\n    } else {\n      throw new MongooseError(`Path \"${path}\" is not an array`);\n    }\n  }\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name The name of the Virtual to get\n * @return {VirtualType|null}\n */\n\nSchema.prototype.virtualpath = function (name) {\n  return Object.hasOwn(this.virtuals, name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * Or as a Array:\n *\n *     schema.remove(['name', 'age']);\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // Undefined\n *\n * @param {String|Array} path The Path(s) to remove\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function (path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function (name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n      delete this.paths[name];\n      _deletePath(this, name);\n      this._removeEncryptedField(name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n  let branch = schema.tree;\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n  delete branch[last];\n}\n\n/**\n * Removes the given virtual or virtuals from the schema.\n *\n * @param {String|Array} path The virutal path(s) to remove.\n * @returns {Schema} the Schema instance, or a mongoose error if the virtual does not exist.\n * @api public\n */\n\nSchema.prototype.removeVirtual = function (path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    for (const virtual of path) {\n      if (this.virtuals[virtual] == null) {\n        throw new MongooseError(`Attempting to remove virtual \"${virtual}\" that does not exist.`);\n      }\n    }\n    for (const virtual of path) {\n      delete this.paths[virtual];\n      delete this.virtuals[virtual];\n      if (virtual.indexOf('.') !== -1) {\n        mpath.unset(virtual, this.tree);\n      } else {\n        delete this.tree[virtual];\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](https://mongoosejs.com/docs/guide.html#virtuals),\n * [statics](https://mongoosejs.com/docs/guide.html#statics), and\n * [methods](https://mongoosejs.com/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model The Class to load\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function (model, virtualsOnly) {\n  // Stop copying when hit certain base classes\n  if (model === Object.prototype || model === Function.prototype || Object.hasOwn(model.prototype, '$isMongooseModelPrototype') || Object.hasOwn(model.prototype, '$isMongooseDocumentPrototype')) {\n    return this;\n  }\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function (name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (Object.hasOwn(prop, 'value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function (name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function (path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n        if (foundschema.embeddedSchemaType || foundschema.Constructor) {\n          // array of Mixed?\n          if (foundschema.embeddedSchemaType instanceof MongooseTypes.Mixed) {\n            foundschema.embeddedSchemaType.$fullPath = resultPath.join('.');\n            return foundschema.embeddedSchemaType;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (p + 1 === parts.length && foundschema.embeddedSchemaType && (parts[p] === '$' || isArrayFilter(parts[p]))) {\n              return foundschema.embeddedSchemaType;\n            }\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema.embeddedSchemaType;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n          if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {\n            return foundschema.$__schemaType;\n          }\n          if (foundschema.$__schemaType.schema != null) {\n            // Map of docs\n            const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n            return ret;\n          }\n        }\n        foundschema.$fullPath = resultPath.join('.');\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n    if (numberRE.test(parts[i])) {\n      parts[i] = '$';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function (path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  if (pathschema) {\n    return 'real';\n  }\n  function search(parts, schema) {\n    let p = parts.length + 1,\n      foundschema,\n      trypath;\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.embeddedSchemaType || foundschema.Constructor) {\n          // array of Mixed?\n          if (foundschema.embeddedSchemaType instanceof MongooseTypes.Mixed) {\n            return {\n              schema: foundschema,\n              pathType: 'mixed'\n            };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return {\n                  schema: foundschema,\n                  pathType: 'nested'\n                };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return {\n          schema: foundschema,\n          pathType: 'real'\n        };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return {\n          schema: schema,\n          pathType: 'nested'\n        };\n      }\n    }\n    return {\n      schema: foundschema || schema,\n      pathType: 'undefined'\n    };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/**\n * Transforms the duplicate key error by checking for duplicate key error messages by path.\n * If no duplicate key error messages are found, returns the original error.\n *\n * @param {Error} error The error to transform\n * @returns {Error} The transformed error\n * @api private\n */\n\nSchema.prototype._transformDuplicateKeyError = function _transformDuplicateKeyError(error) {\n  if (!this._duplicateKeyErrorMessagesByPath) {\n    return error;\n  }\n  if (error.code !== 11000 && error.code !== 11001) {\n    return error;\n  }\n  if (error.keyPattern != null) {\n    const keyPattern = error.keyPattern;\n    const keys = Object.keys(keyPattern);\n    if (keys.length !== 1) {\n      return error;\n    }\n    const firstKey = keys[0];\n    if (!Object.hasOwn(this._duplicateKeyErrorMessagesByPath, firstKey)) {\n      return error;\n    }\n    return new MongooseError(this._duplicateKeyErrorMessagesByPath[firstKey], {\n      cause: error\n    });\n  }\n  return error;\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/**\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n * @method _preCompile\n * @memberOf Schema\n * @instance\n * @api private\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  this.plugin(idGetter, {\n    deduplicate: true\n  });\n};\n\n/**\n * Returns a JSON schema representation of this Schema.\n *\n * By default, returns normal [JSON schema representation](https://json-schema.org/learn/getting-started-step-by-step), which is not typically what you want to use with\n * [MongoDB's `$jsonSchema` collection option](https://www.mongodb.com/docs/manual/core/schema-validation/specify-json-schema/).\n * Use the `useBsonType: true` option to return MongoDB `$jsonSchema` syntax instead.\n *\n * In addition to types, `jsonSchema()` supports the following Mongoose validators:\n * - `enum` for strings and numbers\n *\n * #### Example:\n *    const schema = new Schema({ name: String });\n *    // { required: ['_id'], properties: { name: { type: ['string', 'null'] }, _id: { type: 'string' } } }\n *    schema.toJSONSchema();\n *\n *    // { required: ['_id'], properties: { name: { bsonType: ['string', 'null'] }, _id: { bsonType: 'objectId' } } }\n *    schema.toJSONSchema({ useBsonType: true });\n *\n * @param {Object} [options]\n * @param [Boolean] [options.useBsonType=false] if true, specify each path's type using `bsonType` rather than `type` for MongoDB $jsonSchema support\n */\n\nSchema.prototype.toJSONSchema = function toJSONSchema(options) {\n  const useBsonType = options?.useBsonType ?? false;\n  const result = useBsonType ? {\n    required: [],\n    properties: {}\n  } : {\n    type: 'object',\n    required: [],\n    properties: {}\n  };\n  for (const path of Object.keys(this.paths)) {\n    const schemaType = this.paths[path];\n\n    // Skip Map embedded paths, maps will be handled seperately.\n    if (schemaType._presplitPath.indexOf('$*') !== -1) {\n      continue;\n    }\n\n    // Nested paths are stored as `nested.path` in the schema type, so create nested paths in the json schema\n    // when necessary.\n    const isNested = schemaType._presplitPath.length > 1;\n    let jsonSchemaForPath = result;\n    if (isNested) {\n      for (let i = 0; i < schemaType._presplitPath.length - 1; ++i) {\n        const subpath = schemaType._presplitPath[i];\n        if (jsonSchemaForPath.properties[subpath] == null) {\n          jsonSchemaForPath.properties[subpath] = useBsonType ? {\n            bsonType: ['object', 'null'],\n            properties: {}\n          } : {\n            type: ['object', 'null'],\n            properties: {}\n          };\n        }\n        jsonSchemaForPath = jsonSchemaForPath.properties[subpath];\n      }\n    }\n    const lastSubpath = schemaType._presplitPath[schemaType._presplitPath.length - 1];\n    let isRequired = false;\n    if (path === '_id') {\n      if (!jsonSchemaForPath.required) {\n        jsonSchemaForPath.required = [];\n      }\n      jsonSchemaForPath.required.push('_id');\n      isRequired = true;\n    } else if (schemaType.options.required && typeof schemaType.options.required !== 'function') {\n      if (!jsonSchemaForPath.required) {\n        jsonSchemaForPath.required = [];\n      }\n      // Only `required: true` paths are required, conditional required is not required\n      jsonSchemaForPath.required.push(lastSubpath);\n      isRequired = true;\n    }\n    jsonSchemaForPath.properties[lastSubpath] = schemaType.toJSONSchema(options);\n    if (schemaType.options.enum) {\n      jsonSchemaForPath.properties[lastSubpath].enum = isRequired ? schemaType.options.enum : [...schemaType.options.enum, null];\n    }\n  }\n\n  // Otherwise MongoDB errors with \"$jsonSchema keyword 'required' cannot be an empty array\"\n  if (result.required.length === 0) {\n    delete result.required;\n  }\n  return result;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](https://mongoosejs.com/docs/schematypes.html#strings)\n * - [Number](https://mongoosejs.com/docs/schematypes.html#numbers)\n * - [Boolean](https://mongoosejs.com/docs/schematypes.html#booleans) | Bool\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Date](https://mongoosejs.com/docs/schematypes.html#dates)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids) | Oid\n * - [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed)\n * - [UUID](https://mongoosejs.com/docs/schematypes.html#uuid)\n * - [BigInt](https://mongoosejs.com/docs/schematypes.html#bigint)\n * - [Double] (https://mongoosejs.com/docs/schematypes.html#double)\n * - [Int32](https://mongoosejs.com/docs/schematypes.html#int32)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;","map":{"version":3,"names":["EventEmitter","require","Kareem","MongooseError","SchemaType","SchemaTypeOptions","VirtualOptions","VirtualType","addAutoId","clone","get","getConstructorName","getIndexes","handleReadPreferenceAliases","idGetter","isIndexSpecEqual","merge","mpath","setPopulatedVirtualValue","setupTimestamps","symbols","utils","validateRef","hasNumericSubpathRegex","MongooseTypes","queryHooks","queryMiddlewareFunctions","documentHooks","documentMiddlewareFunctions","hookNames","concat","reduce","s","hook","add","Set","isPOJO","id","numberRE","Schema","obj","options","paths","aliases","subpaths","virtuals","singleNestedPaths","nested","inherits","callQueue","_indexes","_searchIndexes","methods","methodOptions","statics","tree","query","childSchemas","plugins","$id","mapPaths","encryptedFields","hooks","defaultOptions","Array","isArray","definition","pathNames","Object","keys","pathName","pathOptions","undefined","virtual","set","_idSubDoc","_id","isObject","auto_id","setupTimestamp","timestamps","aliasFields","schema","path","alias","prop","a","Error","p","v","$set","prototype","create","constructor","instanceOfSchema","defineProperty","configurable","enumerable","writable","_clone","on","emit","Constructor","base","_userProvidedOptions","map","f","slice","call","fromEntries","entries","key","value","schemaType","values","$isSingleNested","_gatherChildSchemas","$globalPluginsApplied","$isRootDiscriminator","$implicitlyCreated","$originalSchemaId","discriminatorMapping","assign","discriminators","_applyDiscriminators","Map","pick","newSchema","_hasEncryptedField","encrypt","typeKey","schematype","_hasEncryptedFields","encryptionType","omit","remove","includes","baseOptions","strict","strictQuery","bufferCommands","capped","versionKey","optimisticConcurrency","minimize","autoIndex","discriminatorKey","shardKey","read","validateBeforeSave","validateModifiedOnly","mode","tags","discriminator","name","_getDocumentMiddleware","filter","document","fn","builtInMiddleware","_defaultToObjectOptions","json","_defaultToObjectOptionsMap","schemaOptions","arguments","length","prefix","specialProperties","has","fullPath","val","TypeError","isMongooseTypeString","Types","upperVal","charAt","toUpperCase","substring","hasOwnKeys","type","_typeDef","childSchemaOptions","toObject","toJSON","_schema","schemaWrappedPath","encryptedField","encryptedFieldConfig","_addEncryptedField","_removeEncryptedField","aliasObj","fieldConfig","autoEncryptionType","_buildEncryptedFields","fields","config","bsonType","_buildSchemaMap","buildNestedPath","object","i","component","properties","schemaMapPropertyReducer","accum","propertyConfig","pathComponents","split","configuration","removeIndex","index","splice","clearIndexes","searchIndex","description","push","reserved","listeners","removeListener","collection","errors","init","isModified","isNew","populated","save","validate","cleanPath","_pathToPositionalSyntax","_getPath","mapPath","getMapPath","hasMixedParent","test","getPositionalPath","firstPieceOfPath","suppressReservedKeysWarning","errorMessage","warn","hasUserDefinedProperty","ref","last","pop","branch","sub","msg","interpretAsType","childSchema","$isSchemaMap","$__schemaType","model","$isMongooseDocumentArray","$isMongooseArray","arrayPath","_schemaType","toAdd","embeddedSchemaType","_arrayPath","_arrayParentPath","$parentSchemaDocArray","hasOwn","subpath","singleNestedPath","replace","startsWith","indexOf","remnant","presplitPath","_presplitPath","constructorName","getFunctionName","oldObj","Function","Mixed","cast","of","_isMerging","DocumentArray","castFromTypeKey","schemaName","parentSchema","Subdocument","Buffer","isBuffer","ObjectId","Decimal128","toString","eachPath","len","requiredPaths","invalidate","_requiredpaths","ret","isRequired","indexedPaths","_indexedpaths","indexes","pathType","getPositionalPathType","self","Boolean","isNested","queue","args","pre","RegExp","remainingArgs","apply","el","post","plugin","opts","deduplicate","method","static","expires","renameObjKey","field","existingIndex","JSON","stringify","auto","_propagateOptionsToImplicitlyCreatedSchemas","transform","baseSchema","indexTypes","localField","foreignField","virtualPreInit","_v","$$populatedVirtuals","justOne","count","hydratedPopulatedDocs","modelNames","_getModelNamesForPopulate","populatedVal","$__","PopulateModel","db","hydrate","$populated","doc","populateModelSymbol","unset","parts","cur","join","mem","part","applyToArray","virtualpath","forEach","allKeys","_deletePath","pieces","piece","removeVirtual","loadClass","virtualsOnly","getPrototypeOf","getOwnPropertyNames","match","getOwnPropertyDescriptor","getters","setters","_getSchema","_this","pathschema","resultPath","$fullPath","search","foundschema","trypath","isArrayFilter","_getPathType","_transformDuplicateKeyError","error","_duplicateKeyErrorMessagesByPath","code","keyPattern","firstKey","cause","endsWith","_preCompile","toJSONSchema","useBsonType","result","required","jsonSchemaForPath","lastSubpath","enum","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/schema.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseError = require('./error/mongooseError');\nconst SchemaType = require('./schemaType');\nconst SchemaTypeOptions = require('./options/schemaTypeOptions');\nconst VirtualOptions = require('./options/virtualOptions');\nconst VirtualType = require('./virtualType');\nconst addAutoId = require('./helpers/schema/addAutoId');\nconst clone = require('./helpers/clone');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getIndexes = require('./helpers/schema/getIndexes');\nconst handleReadPreferenceAliases = require('./helpers/query/handleReadPreferenceAliases');\nconst idGetter = require('./helpers/schema/idGetter');\nconst isIndexSpecEqual = require('./helpers/indexes/isIndexSpecEqual');\nconst merge = require('./helpers/schema/merge');\nconst mpath = require('mpath');\nconst setPopulatedVirtualValue = require('./helpers/populate/setPopulatedVirtualValue');\nconst setupTimestamps = require('./helpers/timestamps/setupTimestamps');\nconst symbols = require('./schema/symbols');\nconst utils = require('./utils');\nconst validateRef = require('./helpers/populate/validateRef');\n\nconst hasNumericSubpathRegex = /\\.\\d+(\\.|$)/;\n\nlet MongooseTypes;\n\nconst queryHooks = require('./constants').queryMiddlewareFunctions;\nconst documentHooks = require('./constants').documentMiddlewareFunctions;\nconst hookNames = queryHooks.concat(documentHooks).\n  reduce((s, hook) => s.add(hook), new Set());\n\nconst isPOJO = utils.isPOJO;\n\nlet id = 0;\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](https://mongoosejs.com/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](https://mongoosejs.com/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](https://mongoosejs.com/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](https://mongoosejs.com/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](https://mongoosejs.com/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](https://mongoosejs.com/docs/guide.html#collection): string - no default\n * - [discriminatorKey](https://mongoosejs.com/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](https://mongoosejs.com/docs/guide.html#id): bool - defaults to true\n * - [_id](https://mongoosejs.com/docs/guide.html#_id): bool - defaults to true\n * - [minimize](https://mongoosejs.com/docs/guide.html#minimize): bool - controls [document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) behavior when called manually - defaults to true\n * - [read](https://mongoosejs.com/docs/guide.html#read): string\n * - [readConcern](https://mongoosejs.com/docs/guide.html#readConcern): object - defaults to null, use to set a default [read concern](https://www.mongodb.com/docs/manual/reference/read-concern/) for all queries.\n * - [writeConcern](https://mongoosejs.com/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://www.mongodb.com/docs/manual/reference/write-concern/)\n * - [shardKey](https://mongoosejs.com/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](https://mongoosejs.com/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](https://mongoosejs.com/docs/guide.html#toJSON) - object - no default\n * - [toObject](https://mongoosejs.com/docs/guide.html#toObject) - object - no default\n * - [typeKey](https://mongoosejs.com/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](https://mongoosejs.com/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [validateModifiedOnly](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) - bool - defaults to `false`\n * - [versionKey](https://mongoosejs.com/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](https://mongoosejs.com/docs/guide.html#optimisticConcurrency): bool or string[] or { exclude: string[] } - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html) for all fields. Set to a string array to enable optimistic concurrency only for the specified fields; note that this **replaces** the default array versioning behavior. Set to `{ exclude: string[] }` to enable optimistic concurrency for all fields except the specified ones; this also replaces the default array versioning.\n * - [collation](https://mongoosejs.com/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](https://mongoosejs.com/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](https://mongoosejs.com/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](https://mongoosejs.com/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](https://mongoosejs.com/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n * - [virtuals](https://mongoosejs.com/docs/tutorials/virtuals.html#virtuals-via-schema-options): object - virtuals to define, alias for [`.virtual`](https://mongoosejs.com/docs/api/schema.html#Schema.prototype.virtual())\n * - [collectionOptions]: object with options passed to [`createCollection()`](https://www.mongodb.com/docs/manual/reference/method/db.createCollection/) when calling `Model.createCollection()` or `autoCreate` set to true.\n * - [encryptionType]: the encryption type for the schema.  Valid options are `csfle` or `queryableEncryption`.  See https://mongoosejs.com/docs/field-level-encryption.\n * - [lean]: boolean - set to true to make all queries use [lean](https://mongoosejs.com/docs/tutorials/lean.html) by default. Defaults to false.\n *\n * #### Options for Nested Schemas:\n *\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this._searchIndexes = [];\n  this.methods = options?.methods || {};\n  this.methodOptions = {};\n  this.statics = options?.statics || {};\n  this.tree = {};\n  this.query = options?.query || {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n  this.encryptedFields = {};\n\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // build virtual paths\n  if (options?.virtuals) {\n    const virtuals = options.virtuals;\n    const pathNames = Object.keys(virtuals);\n    for (const pathName of pathNames) {\n      const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;\n      const virtual = this.virtual(pathName, pathOptions);\n\n      if (virtuals[pathName].get) {\n        virtual.get(virtuals[pathName].get);\n      }\n\n      if (virtuals[pathName].set) {\n        virtual.set(virtuals[pathName].set);\n      }\n    }\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj?._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/**\n * Create virtual properties with alias field\n * @api private\n */\nfunction aliasFields(schema, paths) {\n  for (const path of Object.keys(paths)) {\n    let alias = null;\n    if (paths[path] != null) {\n      alias = paths[path];\n    } else {\n      const options = get(schema.paths[path], 'options');\n      if (options == null) {\n        continue;\n      }\n\n      alias = options.alias;\n    }\n\n    if (!alias) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    if (Array.isArray(alias)) {\n      for (const a of alias) {\n        if (typeof a !== 'string') {\n          throw new Error('Invalid value for alias option on ' + prop + ', got ' + a);\n        }\n\n        schema.aliases[a] = prop;\n\n        schema.\n          virtual(a).\n          get((function(p) {\n            return function() {\n              if (typeof this.get === 'function') {\n                return this.get(p);\n              }\n              return this[p];\n            };\n          })(prop)).\n          set((function(p) {\n            return function(v) {\n              return this.$set(p, v);\n            };\n          })(prop));\n      }\n\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.$set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * #### Example:\n *\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Creates a new schema with the given definition and options. Equivalent to `new Schema(definition, options)`.\n *\n * `Schema.create()` is primarily useful for automatic schema type inference in TypeScript.\n *\n * #### Example:\n *\n *     const schema = Schema.create({ name: String }, { toObject: { virtuals: true } });\n *     // Equivalent:\n *     const schema2 = new Schema({ name: String }, { toObject: { virtuals: true } });\n *\n * @param {Object} definition\n * @param {Object} [options]\n * @return {Schema} the new schema\n * @api public\n * @memberOf Schema\n * @static\n */\n\nSchema.create = function create(definition, options) {\n  return new Schema(definition, options);\n};\n\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = clone(this.methods);\n  s.methodOptions = clone(this.methodOptions);\n  s.statics = clone(this.statics);\n  s.query = clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = clone(this._indexes);\n  s._searchIndexes = clone(this._searchIndexes);\n  s.s.hooks = this.s.hooks.clone();\n\n  s.tree = clone(this.tree);\n  s.paths = Object.fromEntries(\n    Object.entries(this.paths).map(([key, value]) => ([key, value.clone()]))\n  );\n  s.nested = clone(this.nested);\n  s.subpaths = clone(this.subpaths);\n  for (const schemaType of Object.values(s.paths)) {\n    if (schemaType.$isSingleNested) {\n      const path = schemaType.path;\n      for (const key of Object.keys(schemaType.schema.paths)) {\n        s.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.singleNestedPaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.subpaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.subpaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.nested)) {\n        s.singleNestedPaths[path + '.' + key] = 'nested';\n      }\n    }\n  }\n  s._gatherChildSchemas();\n\n  s.virtuals = clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = new Map(this._applyDiscriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  s.encryptedFields = clone(this.encryptedFields);\n\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to pick for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function(paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\n      'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this._hasEncryptedField(path)) {\n      const encrypt = this.encryptedFields[path];\n      const schemaType = this.path(path);\n      newSchema.add({\n        [path]: {\n          encrypt,\n          [this.options.typeKey]: schemaType\n        }\n      });\n    } else if (this.nested[path]) {\n      newSchema.add({ [path]: get(this.tree, path) });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({ [path]: schematype });\n    }\n  }\n\n  if (!this._hasEncryptedFields()) {\n    newSchema.options.encryptionType = null;\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns a new schema that has the `paths` from the original schema, minus the omitted ones.\n *\n * This method is analagous to [Lodash's `omit()` function](https://lodash.com/docs/#omit) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema omitting the `age` path\n *     const newSchema = schema.omit(['age']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to omit for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.omit = function(paths, options) {\n  const newSchema = new Schema(this, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError(\n      'Schema#omit() only accepts an array argument, ' +\n        'got \"' +\n        typeof paths +\n        '\"'\n    );\n  }\n\n  newSchema.remove(paths);\n\n  for (const nested in newSchema.singleNestedPaths) {\n    if (paths.includes(nested)) {\n      delete newSchema.singleNestedPaths[nested];\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} [options] Options to overwrite the default options\n * @return {Object} The merged options of `options` and the default options\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  this._userProvidedOptions = options == null ? {} : clone(options);\n  const baseOptions = this.base?.options || {};\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  const strictQuery = 'strictQuery' in baseOptions ? baseOptions.strictQuery : false;\n  const id = 'id' in baseOptions ? baseOptions.id : true;\n  options = {\n    strict,\n    strictQuery,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    validateModifiedOnly: false,\n    // the following are only applied at construction time\n    _id: true,\n    id: id,\n    typeKey: 'type',\n    ...options\n  };\n\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + (typeof options.versionKey) + '`');\n  }\n\n  if (typeof options.read === 'string') {\n    options.read = handleReadPreferenceAliases(options.read);\n  } else if (Array.isArray(options.read) && typeof options.read[0] === 'string') {\n    options.read = {\n      mode: handleReadPreferenceAliases(options.read[0]),\n      tags: options.read[1]\n    };\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * #### Example:\n *\n *     const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });\n *\n *     const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });\n *     const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);\n *\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.discriminators['clicked']; // Model { clicked }\n *\n *     const doc = await Event.create({ kind: 'clicked', element: '#hero' });\n *     doc.element; // '#hero'\n *     doc instanceof ClickedModel; // true\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the discriminated Schema\n * @param {Object} [options] discriminator options\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.discriminator = function(name, schema, options) {\n  this._applyDiscriminators = this._applyDiscriminators || new Map();\n  this._applyDiscriminators.set(name, { schema, options });\n\n  return this;\n};\n\n/*!\n * Get the document middleware for this schema, filtering out any hooks that are specific to queries.\n */\nSchema.prototype._getDocumentMiddleware = function _getDocumentMiddleware() {\n  return this.s.hooks.\n    filter(hook => {\n      if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n        return !!hook['document'];\n      }\n      if (hook.name === 'remove' || hook.name === 'init') {\n        return hook['document'] == null || !!hook['document'];\n      }\n      if (hook.query != null || hook.document != null) {\n        return hook.document !== false;\n      }\n      return true;\n    }).\n    filter(hook => {\n      // If user has overwritten the method, don't apply built-in middleware\n      if (this.methods[hook.name]) {\n        return !hook.fn[symbols.builtInMiddleware];\n      }\n\n      return true;\n    });\n};\n\n/*!\n * Get this schema's default toObject/toJSON options, including Mongoose global\n * options.\n */\n\nSchema.prototype._defaultToObjectOptions = function(json) {\n  const path = json ? 'toJSON' : 'toObject';\n  if (this._defaultToObjectOptionsMap && this._defaultToObjectOptionsMap[path]) {\n    return this._defaultToObjectOptionsMap[path];\n  }\n\n  const baseOptions = this.base?.options?.[path] || {};\n  const schemaOptions = this.options[path] || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  const defaultOptions = Object.assign({}, baseOptions, schemaOptions);\n\n  this._defaultToObjectOptionsMap = this._defaultToObjectOptionsMap || {};\n  this._defaultToObjectOptionsMap[path] = defaultOptions;\n  return defaultOptions;\n};\n\n/**\n * Sets the encryption type of the schema, if a value is provided, otherwise\n * returns the encryption type.\n *\n * @param {'csfle' | 'queryableEncryption' | null | undefined} encryptionType plain object with paths to add, or another schema\n */\nSchema.prototype.encryptionType = function encryptionType(encryptionType) {\n  if (arguments.length === 0) {\n    return this.options.encryptionType;\n  }\n  if (!(typeof encryptionType === 'string' || encryptionType === null)) {\n    throw new Error('invalid `encryptionType`: ${encryptionType}');\n  }\n  this.options.encryptionType = encryptionType;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || obj?.instanceOfSchema) {\n    merge(this, obj);\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    if (utils.specialProperties.has(key)) {\n      continue;\n    }\n\n    const fullPath = prefix + key;\n    const val = obj[key];\n\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath +\n        '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    // Deprecate setting schema paths to primitive types (gh-7558)\n    let isMongooseTypeString = false;\n    if (typeof val === 'string') {\n      // Handle the case in which the type is specified as a string (eg. 'date', 'oid', ...)\n      const MongooseTypes = this.base?.Schema.Types ?? Schema.Types;\n      const upperVal = val.charAt(0).toUpperCase() + val.substring(1);\n      isMongooseTypeString = MongooseTypes[upperVal] != null;\n    }\n    if (\n      key !== '_id' &&\n      ((typeof val !== 'object' && typeof val !== 'function' && !isMongooseTypeString) ||\n      val == null)\n    ) {\n      throw new TypeError(`Invalid schema configuration: \\`${val}\\` is not ` +\n        `a valid type at path \\`${key}\\`. See ` +\n        'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n    }\n    if (val instanceof VirtualType || (val.constructor?.name ?? null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\n        '`, got value \"' + val[0] + '\"');\n    }\n\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (!val[0]?.instanceOfSchema && utils.isPOJO(val[0]?.discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      }\n    } else if (utils.hasOwnKeys(val) === false) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || (typeKey === 'type' && isPOJO(val.type) && val.type.type)) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && utils.hasOwnKeys(_typeDef)) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n\n        const childSchemaOptions = {};\n        if (this._userProvidedOptions.typeKey) {\n          childSchemaOptions.typeKey = this._userProvidedOptions.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (this._userProvidedOptions.strict != null) {\n          childSchemaOptions.strict = this._userProvidedOptions.strict;\n        }\n        if (this._userProvidedOptions.toObject != null) {\n          childSchemaOptions.toObject = utils.omit(this._userProvidedOptions.toObject, ['transform']);\n        }\n        if (this._userProvidedOptions.toJSON != null) {\n          childSchemaOptions.toJSON = utils.omit(this._userProvidedOptions.toJSON, ['transform']);\n        }\n\n        const _schema = new Schema(_typeDef, childSchemaOptions);\n        _schema.$implicitlyCreated = true;\n        const schemaWrappedPath = Object.assign({}, val, { [typeKey]: _schema });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (!val?.instanceOfSchema && utils.isPOJO(val?.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n\n    if (val.instanceOfSchema && val.encryptionType() != null) {\n      // schema.add({ field: <instance of encrypted schema> })\n      if (this.encryptionType() != val.encryptionType()) {\n        throw new Error('encryptionType of a nested schema must match the encryption type of the parent schema.');\n      }\n\n      for (const [encryptedField, encryptedFieldConfig] of Object.entries(val.encryptedFields)) {\n        const path = fullPath + '.' + encryptedField;\n        this._addEncryptedField(path, encryptedFieldConfig);\n      }\n    } else if (typeof val === 'object' && 'encrypt' in val) {\n      // schema.add({ field: { type: <schema type>, encrypt: { ... }}})\n      const { encrypt } = val;\n\n      if (this.encryptionType() == null) {\n        throw new Error('encryptionType must be provided');\n      }\n\n      this._addEncryptedField(fullPath, encrypt);\n    } else {\n      // if the field was already encrypted and we re-configure it to be unencrypted, remove\n      // the encrypted field configuration\n      this._removeEncryptedField(fullPath);\n    }\n  }\n\n  const aliasObj = Object.fromEntries(\n    Object.entries(obj).map(([key]) => ([prefix + key, null]))\n  );\n  aliasFields(this, aliasObj);\n  return this;\n};\n\n/**\n * @param {string} path\n * @param {object} fieldConfig\n *\n * @api private\n */\nSchema.prototype._addEncryptedField = function _addEncryptedField(path, fieldConfig) {\n  const type = this.path(path).autoEncryptionType();\n  if (type == null) {\n    throw new Error(`Invalid BSON type for FLE field: '${path}'`);\n  }\n\n  this.encryptedFields[path] = clone(fieldConfig);\n};\n\n/**\n * @param {string} path\n *\n * @api private\n */\nSchema.prototype._removeEncryptedField = function _removeEncryptedField(path) {\n  delete this.encryptedFields[path];\n};\n\n/**\n * @api private\n *\n * @returns {boolean}\n */\nSchema.prototype._hasEncryptedFields = function _hasEncryptedFields() {\n  return utils.hasOwnKeys(this.encryptedFields);\n};\n\n/**\n * @param {string} path\n * @returns {boolean}\n *\n * @api private\n */\nSchema.prototype._hasEncryptedField = function _hasEncryptedField(path) {\n  return path in this.encryptedFields;\n};\n\n\n/**\n * Builds an encryptedFieldsMap for the schema.\n *\n * @api private\n */\nSchema.prototype._buildEncryptedFields = function() {\n  const fields = Object.entries(this.encryptedFields).map(\n    ([path, config]) => {\n      const bsonType = this.path(path).autoEncryptionType();\n      // { path, bsonType, keyId, queries? }\n      return { path, bsonType, ...config };\n    });\n\n  return { fields };\n};\n\n/**\n * Builds a schemaMap for the schema, if the schema is configured for client-side field level encryption.\n *\n * @api private\n */\nSchema.prototype._buildSchemaMap = function() {\n  /**\n   * `schemaMap`s are JSON schemas, which use the following structure to represent objects:\n   *    { field: { bsonType: 'object', properties: { ... } } }\n   *\n   * for example, a schema that looks like this `{ a: { b: int32 } }` would be encoded as\n   * `{ a: { bsonType: 'object', properties: { b: < encryption configuration > } } }`\n   *\n   * This function takes an array of path segments, an output object (that gets mutated) and\n   * a value to be associated with the full path, and constructs a valid CSFLE JSON schema path for\n   * the object.  This works for deeply nested properties as well.\n   *\n   * @param {string[]} path array of path components\n   * @param {object} object the object in which to build a JSON schema of `path`'s properties\n   * @param {object} value the value to associate with the path in object\n   */\n  function buildNestedPath(path, object, value) {\n    let i = 0, component = path[i];\n    for (; i < path.length - 1; ++i, component = path[i]) {\n      object[component] = object[component] == null ? {\n        bsonType: 'object',\n        properties: {}\n      } : object[component];\n      object = object[component].properties;\n    }\n    object[component] = value;\n  }\n\n  const schemaMapPropertyReducer = (accum, [path, propertyConfig]) => {\n    const bsonType = this.path(path).autoEncryptionType();\n    const pathComponents = path.split('.');\n    const configuration = { encrypt: { ...propertyConfig, bsonType } };\n    buildNestedPath(pathComponents, accum, configuration);\n    return accum;\n  };\n\n  const properties = Object.entries(this.encryptedFields).reduce(\n    schemaMapPropertyReducer,\n    {});\n\n  return {\n    bsonType: 'object',\n    properties\n  };\n};\n\n/**\n * Add an alias for `path`. This means getting or setting the `alias`\n * is equivalent to getting or setting the `path`.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ n: String });\n *\n *     // Make 'name' an alias for 'n'\n *     toySchema.alias('n', 'name');\n *\n *     const Toy = mongoose.model('Toy', toySchema);\n *     const turboMan = new Toy({ n: 'Turbo Man' });\n *\n *     turboMan.name; // 'Turbo Man'\n *     turboMan.n; // 'Turbo Man'\n *\n *     turboMan.name = 'Turbo Man Action Figure';\n *     turboMan.n; // 'Turbo Man Action Figure'\n *\n *     await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }\n *\n *\n * @param {String} path real path to alias\n * @param {String|String[]} alias the path(s) to use as an alias for `path`\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.alias = function alias(path, alias) {\n  aliasFields(this, { [path]: alias });\n  return this;\n};\n\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (isIndexSpecEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n\n  return this;\n};\n\n/**\n * Add an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) that Mongoose will create using `Model.createSearchIndex()`.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.searchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *\n * @param {Object} description index options, including `name` and `definition`\n * @param {String} description.name\n * @param {Object} description.definition\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.searchIndex = function searchIndex(description) {\n  this._searchIndexes.push(description);\n\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n *\n * @property reserved\n * @memberOf Schema\n * @static\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\n\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.listeners =\nreserved.removeListener =\n\n// document properties and functions\nreserved.collection =\nreserved.errors =\nreserved.get =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.populated =\nreserved.remove =\nreserved.save =\nreserved.toObject =\nreserved.validate = 1;\nreserved.collection = 1;\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example:\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path The name of the Path to get / set\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  if (obj === undefined) {\n    if (this.paths[path] != null) {\n      return this.paths[path];\n    }\n    // Convert to '.$' to check subpaths re: gh-6405\n    const cleanPath = _pathToPositionalSyntax(path);\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return hasNumericSubpathRegex.test(path)\n      ? getPositionalPath(this, path, cleanPath)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.suppressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` +\n      'You are allowed to use it, but use at your own risk. ' +\n      'To disable this warning pass `suppressReservedKeysWarning` as a schema option.';\n\n    utils.warn(errorMessage);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    if (utils.specialProperties.has(sub)) {\n      throw new Error('Cannot set special property `' + sub + '` on a schema');\n    }\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + fullPath\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n\n  branch[last] = clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  // If overwriting an existing path, make sure to clear the childSchemas\n  this.childSchemas = this.childSchemas.filter(childSchema => childSchema.path !== path);\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n    if (schemaType.$__schemaType.$isSingleNested) {\n      this.childSchemas.push({\n        schema: schemaType.$__schemaType.schema,\n        model: schemaType.$__schemaType.Constructor,\n        path: path\n      });\n    }\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.Constructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.Constructor,\n      path: path\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.Constructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.Constructor,\n      path: path\n    });\n  }\n\n  if (schemaType.$isMongooseArray && !schemaType.$isMongooseDocumentArray) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      _schemaType.embeddedSchemaType._arrayPath = arrayPath;\n      _schemaType.embeddedSchemaType._arrayParentPath = path;\n      _schemaType = _schemaType.embeddedSchemaType;\n\n      this.subpaths[arrayPath] = _schemaType;\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._gatherChildSchemas = function _gatherChildSchemas() {\n  const childSchemas = [];\n\n  for (const path of Object.keys(this.paths)) {\n    if (typeof path !== 'string') {\n      continue;\n    }\n    const schematype = this.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({\n        schema: schematype.schema,\n        model: schematype.Constructor,\n        path: path\n      });\n    } else if (schematype.$isSchemaMap && schematype.$__schemaType.$isSingleNested) {\n      childSchemas.push({\n        schema: schematype.$__schemaType.schema,\n        model: schematype.$__schemaType.Constructor,\n        path: path\n      });\n    }\n  }\n\n  this.childSchemas = childSchemas;\n  return childSchemas;\n};\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (Object.hasOwn(schema.paths, path)) {\n    return schema.paths[path];\n  }\n  if (Object.hasOwn(schema.subpaths, cleanPath)) {\n    const subpath = schema.subpaths[cleanPath];\n    if (subpath === 'nested') {\n      return undefined;\n    }\n    return subpath;\n  }\n  if (Object.hasOwn(schema.singleNestedPaths, cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    const singleNestedPath = schema.singleNestedPaths[cleanPath];\n    if (singleNestedPath === 'nested') {\n      return undefined;\n    }\n    return singleNestedPath;\n  }\n\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const cleanPath = val.path.replace(/\\.\\$\\*/g, '');\n    if (path === cleanPath || (path.startsWith(cleanPath + '.') && path.slice(cleanPath.length + 1).indexOf('.') === -1)) {\n      return val;\n    } else if (val.schema && path.startsWith(cleanPath + '.')) {\n      let remnant = path.slice(cleanPath.length + 1);\n      remnant = remnant.slice(remnant.indexOf('.') + 1);\n      return val.schema.paths[remnant];\n    } else if (val.$isSchemaMap && path.startsWith(cleanPath + '.')) {\n      let remnant = path.slice(cleanPath.length + 1);\n      remnant = remnant.slice(remnant.indexOf('.') + 1);\n      const presplitPath = val.$__schemaType._presplitPath;\n      if (remnant.indexOf('.') === -1 && presplitPath[presplitPath.length - 1] === '$*') {\n        // Handle map of map of primitives\n        return val.$__schemaType;\n      } else if (remnant.indexOf('.') !== -1 && val.$__schemaType.schema && presplitPath[presplitPath.length - 1] === '$*') {\n        // map of map of subdocs (recursive)\n        return val.$__schemaType.schema.path(remnant.slice(remnant.indexOf('.') + 1));\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @param {Object} options schema options\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base?.Schema.Types ?? Schema.Types;\n  const Types = this.base?.Types ?? require('./types');\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n\n  if (type instanceof SchemaType) {\n    if (type.path === path) {\n      return type;\n    }\n    const clone = type.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj, null, this);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = (type === Array || type === 'array')\n      ? obj.cast || obj.of\n      : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast?.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast = new Schema(cast);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj, null, this);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast[options.typeKey] = new Schema(cast[options.typeKey]);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast, this);\n    }\n    if (typeof cast !== 'undefined') {\n      if (Array.isArray(cast) || cast.type === Array || cast.type == 'Array') {\n        if (cast?.type == 'Array') {\n          cast.type = Array;\n        }\n        return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj, null, this);\n      }\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = (cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)) ?\n      cast[options.typeKey] :\n      cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (utils.hasOwnKeys(castFromTypeKey)) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = { minimize: options.minimize };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (Object.hasOwn(options, 'strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        if (Object.hasOwn(options, 'strictQuery')) {\n          childSchemaOptions.strictQuery = options.strictQuery;\n        }\n        if (Object.hasOwn(options, 'toObject')) {\n          childSchemaOptions.toObject = utils.omit(options.toObject, ['transform']);\n        }\n        if (Object.hasOwn(options, 'toJSON')) {\n          childSchemaOptions.toJSON = utils.omit(options.toJSON, ['transform']);\n        }\n\n        if (Object.hasOwn(this._userProvidedOptions, '_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj, null, this);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj, null, this);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj, null, this);\n      }\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `Could not determine the embedded type for array \\`${path}\\`. ` +\n          'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!Object.hasOwn(MongooseTypes, name)) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\n          'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n\n      if (name === 'Union' && typeof cast === 'object') {\n        cast.parentSchema = this;\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options, this);\n  }\n\n  if (type?.instanceOfSchema) {\n    return new MongooseTypes.Subdocument(type, path, obj, this);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else if (type === Types.ObjectId) {\n    name = 'ObjectId';\n  } else if (type === Types.Decimal128) {\n    name = 'Decimal128';\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` +\n      'invalid. See ' +\n      'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\n      `a valid type at path \\`${path}\\`. See ` +\n      'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  const schemaType = new MongooseTypes[name](path, obj, options, this);\n\n  return schemaType;\n};\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate Refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  if (Object.hasOwn(this.paths, path)) {\n    return 'real';\n  }\n  if (Object.hasOwn(this.virtuals, path)) {\n    return 'virtual';\n  }\n  if (Object.hasOwn(this.nested, path)) {\n    return 'nested';\n  }\n\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (Object.hasOwn(this.subpaths, cleanPath) || Object.hasOwn(this.subpaths, path)) {\n    return 'real';\n  }\n\n  const singleNestedPath = Object.hasOwn(this.singleNestedPaths, cleanPath) || Object.hasOwn(this.singleNestedPaths, path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path, cleanPath);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (Object.hasOwn(this.paths, path) &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/**\n * ignore. Deprecated re: #6405\n * @param {Any} self\n * @param {String} path\n * @api private\n */\n\nfunction getPositionalPathType(self, path, cleanPath) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return Object.hasOwn(self.paths, subpaths[0]) ?\n      self.paths[subpaths[0]] :\n      'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.embeddedSchemaType;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.embeddedSchemaType;\n      }\n      continue;\n    }\n\n    if (!val?.schema) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[cleanPath] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path, cleanPath) {\n  getPositionalPathType(self, path, cleanPath);\n  return self.subpaths[cleanPath];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the model.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function() {\n *       if (!this.created) this.created = new Date;\n *     });\n *\n *     toySchema.pre('validate', function() {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function() {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function() {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     await m.save();\n *     console.log('this fires after the `post` hook');\n *\n *     await m.find();\n *     console.log('this fires after the post find hook');\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * Or with Options:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\n *\n * @param {Function} plugin The Plugin's callback\n * @param {Object} [opts] Options to pass to the plugin\n * @param {Boolean} [opts.deduplicate=false] If true, ignore duplicate plugins (same `fn` argument using `===`)\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n\n  if (opts?.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     const fizz = new Kitty;\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](https://mongoosejs.com/docs/guide.html#methods)\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.static({\n *         findByName: function () {..}\n *       , findByCost: function () {..}\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *     await Drink.findByCost(3);\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n * @see Statics https://mongoosejs.com/docs/guide.html#statics\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example:\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @param {String} [options.language_override=null] Tells mongodb to use the specified field instead of `language` for parsing text indexes.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n  for (const key in fields) {\n    if (this.aliases[key]) {\n      fields = utils.renameObjKey(fields, key, this.aliases[key]);\n    }\n  }\n  for (const field of Object.keys(fields)) {\n    if (fields[field] === 'ascending' || fields[field] === 'asc') {\n      fields[field] = 1;\n    } else if (fields[field] === 'descending' || fields[field] === 'desc') {\n      fields[field] = -1;\n    }\n  }\n\n  for (const existingIndex of this.indexes()) {\n    if (options.name == null && existingIndex[1].name == null && isIndexSpecEqual(existingIndex[0], fields)) {\n      utils.warn(`Duplicate schema index on ${JSON.stringify(fields)} found. This is often due to declaring an index using both \"index: true\" and \"schema.index()\". Please remove the duplicate index definition.`);\n    }\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets a schema option.\n *\n * #### Example:\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key The name of the option to set the value to\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\n * @param {Array<string>} [tags] tags to add to read preference if key === 'read'\n * @see Schema https://mongoosejs.com/docs/api/schema.html#Schema()\n * @api public\n */\n\nSchema.prototype.set = function(key, value, tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      if (typeof value === 'string') {\n        this.options[key] = { mode: handleReadPreferenceAliases(value), tags };\n      } else if (Array.isArray(value) && typeof value[0] === 'string') {\n        this.options[key] = {\n          mode: handleReadPreferenceAliases(value[0]),\n          tags: value[1]\n        };\n      } else {\n        this.options[key] = value;\n      }\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  // Propagate `strict` and `strictQuery` changes down to implicitly created schemas\n  if (key === 'strict') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strict: value });\n  }\n  if (key === 'strictQuery') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strictQuery: value });\n  }\n  if (key === 'toObject') {\n    value = { ...value };\n    // Avoid propagating transform to implicitly created schemas re: gh-3279\n    delete value.transform;\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { toObject: value });\n  }\n  if (key === 'toJSON') {\n    value = { ...value };\n    // Avoid propagating transform to implicitly created schemas re: gh-3279\n    delete value.transform;\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { toJSON: value });\n  }\n\n  return this;\n};\n\n/*!\n * Recursively set options on implicitly created schemas\n */\n\nfunction _propagateOptionsToImplicitlyCreatedSchemas(baseSchema, options) {\n  for (const { schema } of baseSchema.childSchemas) {\n    if (!schema.$implicitlyCreated) {\n      continue;\n    }\n    Object.assign(schema.options, options);\n    _propagateOptionsToImplicitlyCreatedSchemas(schema, options);\n  }\n}\n\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key The name of the Option to get the current value for\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\n/**\n * The allowed index types\n *\n * @property {String[]} indexTypes\n * @memberOf Schema\n * @static\n * @api public\n */\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true } ],\n *     //   [ { registeredAt: 1 }, {} ] ]\n *     userSchema.indexes();\n *\n * [Plugins](https://mongoosejs.com/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name The name of the Virtual\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](https://mongoosejs.com/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @param {Object|Function} [options.match=null] Apply a default [`match` option to populate](https://mongoosejs.com/docs/populate.html#match), adding an additional filter to the populate query.\n * @param {Boolean} [options.applyToArray=false] If true and the given `name` is a direct child of an array, apply the virtual to the array rather than the elements.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n\n    this.pre('init', function virtualPreInit(obj, opts) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        if (opts?.hydratedPopulatedDocs && !options.count) {\n          const modelNames = virtual._getModelNamesForPopulate(this);\n          const populatedVal = this.$$populatedVirtuals[name];\n          if (!Array.isArray(populatedVal) && !populatedVal.$__ && modelNames?.length === 1) {\n            const PopulateModel = this.db.model(modelNames[0]);\n            this.$$populatedVirtuals[name] = PopulateModel.hydrate(populatedVal);\n          } else if (Array.isArray(populatedVal) && modelNames?.length === 1) {\n            const PopulateModel = this.db.model(modelNames[0]);\n            for (let i = 0; i < populatedVal.length; ++i) {\n              if (!populatedVal[i].$__) {\n                populatedVal[i] = PopulateModel.hydrate(populatedVal[i], null, { hydratedPopulatedDocs: true });\n              }\n            }\n            const foreignField = options.foreignField;\n            this.$populated(\n              name,\n              populatedVal.map(doc => doc == null ? doc : doc.get(typeof foreignField === 'function' ? foreignField.call(doc, doc) : foreignField)),\n              { populateModelSymbol: PopulateModel }\n            );\n          }\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    virtual.\n      set(function(v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        return setPopulatedVirtualValue(\n          this.$$populatedVirtuals,\n          name,\n          v,\n          options\n        );\n      });\n\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210, gh-13189\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] == null) {\n        continue;\n      }\n\n      if (this.paths[cur].$isMongooseDocumentArray || this.paths[cur].$isSingleNested) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      } else if (this.paths[cur].$isSchemaMap) {\n        const remnant = parts.slice(i + 2).join('.');\n        this.paths[cur].$__schemaType.schema.virtual(remnant, options);\n        break;\n      }\n\n      cur += '.' + parts[i + 1];\n    }\n\n    return virtual;\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  if (options?.applyToArray && parts.length > 1) {\n    const path = this.path(parts.slice(0, -1).join('.'));\n    if (path?.$isMongooseArray) {\n      return path.virtual(parts[parts.length - 1], options);\n    } else {\n      throw new MongooseError(`Path \"${path}\" is not an array`);\n    }\n  }\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name The name of the Virtual to get\n * @return {VirtualType|null}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return Object.hasOwn(this.virtuals, name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * Or as a Array:\n *\n *     schema.remove(['name', 'age']);\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // Undefined\n *\n * @param {String|Array} path The Path(s) to remove\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).\n          concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n\n      delete this.paths[name];\n      _deletePath(this, name);\n\n      this._removeEncryptedField(name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n\n/**\n * Removes the given virtual or virtuals from the schema.\n *\n * @param {String|Array} path The virutal path(s) to remove.\n * @returns {Schema} the Schema instance, or a mongoose error if the virtual does not exist.\n * @api public\n */\n\nSchema.prototype.removeVirtual = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    for (const virtual of path) {\n      if (this.virtuals[virtual] == null) {\n        throw new MongooseError(`Attempting to remove virtual \"${virtual}\" that does not exist.`);\n      }\n    }\n\n    for (const virtual of path) {\n      delete this.paths[virtual];\n      delete this.virtuals[virtual];\n      if (virtual.indexOf('.') !== -1) {\n        mpath.unset(virtual, this.tree);\n      } else {\n        delete this.tree[virtual];\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](https://mongoosejs.com/docs/guide.html#virtuals),\n * [statics](https://mongoosejs.com/docs/guide.html#statics), and\n * [methods](https://mongoosejs.com/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model The Class to load\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  // Stop copying when hit certain base classes\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      Object.hasOwn(model.prototype, '$isMongooseModelPrototype') ||\n      Object.hasOwn(model.prototype, '$isMongooseDocumentPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (Object.hasOwn(prop, 'value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.embeddedSchemaType || foundschema.Constructor) {\n          // array of Mixed?\n          if (foundschema.embeddedSchemaType instanceof MongooseTypes.Mixed) {\n            foundschema.embeddedSchemaType.$fullPath = resultPath.join('.');\n            return foundschema.embeddedSchemaType;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (p + 1 === parts.length && foundschema.embeddedSchemaType && (parts[p] === '$' || isArrayFilter(parts[p]))) {\n              return foundschema.embeddedSchemaType;\n            }\n\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema.embeddedSchemaType;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                    (foundschema.schema.$isSingleNested ? null : foundschema);\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n\n          if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {\n            return foundschema.$__schemaType;\n          }\n          if (foundschema.$__schemaType.schema != null) {\n            // Map of docs\n            const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n            return ret;\n          }\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n    if (numberRE.test(parts[i])) {\n      parts[i] = '$';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.embeddedSchemaType || foundschema.Constructor) {\n          // array of Mixed?\n          if (foundschema.embeddedSchemaType instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/**\n * Transforms the duplicate key error by checking for duplicate key error messages by path.\n * If no duplicate key error messages are found, returns the original error.\n *\n * @param {Error} error The error to transform\n * @returns {Error} The transformed error\n * @api private\n */\n\nSchema.prototype._transformDuplicateKeyError = function _transformDuplicateKeyError(error) {\n  if (!this._duplicateKeyErrorMessagesByPath) {\n    return error;\n  }\n  if (error.code !== 11000 && error.code !== 11001) {\n    return error;\n  }\n\n  if (error.keyPattern != null) {\n    const keyPattern = error.keyPattern;\n    const keys = Object.keys(keyPattern);\n    if (keys.length !== 1) {\n      return error;\n    }\n    const firstKey = keys[0];\n    if (!Object.hasOwn(this._duplicateKeyErrorMessagesByPath, firstKey)) {\n      return error;\n    }\n    return new MongooseError(this._duplicateKeyErrorMessagesByPath[firstKey], { cause: error });\n  }\n\n  return error;\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/**\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n * @method _preCompile\n * @memberOf Schema\n * @instance\n * @api private\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  this.plugin(idGetter, { deduplicate: true });\n};\n\n/**\n * Returns a JSON schema representation of this Schema.\n *\n * By default, returns normal [JSON schema representation](https://json-schema.org/learn/getting-started-step-by-step), which is not typically what you want to use with\n * [MongoDB's `$jsonSchema` collection option](https://www.mongodb.com/docs/manual/core/schema-validation/specify-json-schema/).\n * Use the `useBsonType: true` option to return MongoDB `$jsonSchema` syntax instead.\n *\n * In addition to types, `jsonSchema()` supports the following Mongoose validators:\n * - `enum` for strings and numbers\n *\n * #### Example:\n *    const schema = new Schema({ name: String });\n *    // { required: ['_id'], properties: { name: { type: ['string', 'null'] }, _id: { type: 'string' } } }\n *    schema.toJSONSchema();\n *\n *    // { required: ['_id'], properties: { name: { bsonType: ['string', 'null'] }, _id: { bsonType: 'objectId' } } }\n *    schema.toJSONSchema({ useBsonType: true });\n *\n * @param {Object} [options]\n * @param [Boolean] [options.useBsonType=false] if true, specify each path's type using `bsonType` rather than `type` for MongoDB $jsonSchema support\n */\n\nSchema.prototype.toJSONSchema = function toJSONSchema(options) {\n  const useBsonType = options?.useBsonType ?? false;\n  const result = useBsonType ? { required: [], properties: {} } : { type: 'object', required: [], properties: {} };\n  for (const path of Object.keys(this.paths)) {\n    const schemaType = this.paths[path];\n\n    // Skip Map embedded paths, maps will be handled seperately.\n    if (schemaType._presplitPath.indexOf('$*') !== -1) {\n      continue;\n    }\n\n    // Nested paths are stored as `nested.path` in the schema type, so create nested paths in the json schema\n    // when necessary.\n    const isNested = schemaType._presplitPath.length > 1;\n    let jsonSchemaForPath = result;\n    if (isNested) {\n      for (let i = 0; i < schemaType._presplitPath.length - 1; ++i) {\n        const subpath = schemaType._presplitPath[i];\n        if (jsonSchemaForPath.properties[subpath] == null) {\n          jsonSchemaForPath.properties[subpath] = useBsonType\n            ? {\n              bsonType: ['object', 'null'],\n              properties: {}\n            }\n            : {\n              type: ['object', 'null'],\n              properties: {}\n            };\n        }\n        jsonSchemaForPath = jsonSchemaForPath.properties[subpath];\n      }\n    }\n\n    const lastSubpath = schemaType._presplitPath[schemaType._presplitPath.length - 1];\n    let isRequired = false;\n    if (path === '_id') {\n      if (!jsonSchemaForPath.required) {\n        jsonSchemaForPath.required = [];\n      }\n      jsonSchemaForPath.required.push('_id');\n      isRequired = true;\n    } else if (schemaType.options.required && typeof schemaType.options.required !== 'function') {\n      if (!jsonSchemaForPath.required) {\n        jsonSchemaForPath.required = [];\n      }\n      // Only `required: true` paths are required, conditional required is not required\n      jsonSchemaForPath.required.push(lastSubpath);\n      isRequired = true;\n    }\n    jsonSchemaForPath.properties[lastSubpath] = schemaType.toJSONSchema(options);\n    if (schemaType.options.enum) {\n      jsonSchemaForPath.properties[lastSubpath].enum = isRequired\n        ? schemaType.options.enum\n        : [...schemaType.options.enum, null];\n    }\n  }\n\n  // Otherwise MongoDB errors with \"$jsonSchema keyword 'required' cannot be an empty array\"\n  if (result.required.length === 0) {\n    delete result.required;\n  }\n  return result;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](https://mongoosejs.com/docs/schematypes.html#strings)\n * - [Number](https://mongoosejs.com/docs/schematypes.html#numbers)\n * - [Boolean](https://mongoosejs.com/docs/schematypes.html#booleans) | Bool\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Date](https://mongoosejs.com/docs/schematypes.html#dates)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids) | Oid\n * - [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed)\n * - [UUID](https://mongoosejs.com/docs/schematypes.html#uuid)\n * - [BigInt](https://mongoosejs.com/docs/schematypes.html#bigint)\n * - [Double] (https://mongoosejs.com/docs/schematypes.html#double)\n * - [Int32](https://mongoosejs.com/docs/schematypes.html#int32)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n"],"mappings":"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BAAgB,GAAG,IAAI;;AAExC;AACA;AACA;;AAEA1B,MAAM,CAAC2B,cAAc,CAACxD,MAAM,CAACoD,SAAS,EAAE,aAAa,EAAE;EACrDK,YAAY,EAAE,KAAK;EACnBC,UAAU,EAAE,KAAK;EACjBC,QAAQ,EAAE;AACZ,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA9B,MAAM,CAAC2B,cAAc,CAACxD,MAAM,CAACoD,SAAS,EAAE,cAAc,EAAE;EACtDK,YAAY,EAAE,KAAK;EACnBC,UAAU,EAAE,IAAI;EAChBC,QAAQ,EAAE;AACZ,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA9B,MAAM,CAAC2B,cAAc,CAACxD,MAAM,CAACoD,SAAS,EAAE,UAAU,EAAE;EAClDK,YAAY,EAAE,KAAK;EACnBC,UAAU,EAAE,IAAI;EAChBC,QAAQ,EAAE;AACZ,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA3D,MAAM,CAACoD,SAAS,CAACnD,GAAG;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAD,MAAM,CAACoD,SAAS,CAACjD,KAAK;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,MAAM,CAACoD,SAAS,CAACpC,IAAI;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAhB,MAAM,CAACqD,MAAM,GAAG,SAASA,MAAMA,CAAC1B,UAAU,EAAEzB,OAAO,EAAE;EACnD,OAAO,IAAIF,MAAM,CAAC2B,UAAU,EAAEzB,OAAO,CAAC;AACxC,CAAC;;AAED;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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}