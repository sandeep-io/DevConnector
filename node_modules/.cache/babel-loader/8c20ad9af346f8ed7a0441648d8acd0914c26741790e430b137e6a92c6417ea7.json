{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst ValidationError = require('../error/validation');\nconst cleanPositionalOperators = require('./schema/cleanPositionalOperators');\nconst flatten = require('./common').flatten;\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = async function updateValidators(query, schema, castedDoc, options) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  let currentUpdate;\n  let key;\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate?.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' || key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n  if (!hasDollarUpdate) {\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n  const alreadyValidated = [];\n  const context = query;\n  for (let i = 0; i < numUpdates; ++i) {\n    const v = updatedValues[updates[i]];\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      continue;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      continue;\n    }\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(schemaPath.doValidate(v, context, {\n          updateValidator: true\n        }).catch(err => {\n          err.path = updates[i] + '.$in.' + i;\n          validationErrors.push(err);\n        }));\n      });\n    } else {\n      if (isPull[updates[i]] && schemaPath.$isMongooseArray) {\n        continue;\n      }\n      if (schemaPath.$isMongooseDocumentArrayElement && v?.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(schemaPath.doValidate(v, context, {\n          updateValidator: true\n        }).catch(err => {\n          if (err.errors) {\n            for (const key of Object.keys(err.errors)) {\n              const _err = err.errors[key];\n              _err.path = updates[i] + '.' + key;\n              validationErrors.push(_err);\n            }\n          } else {\n            err.path = updates[i];\n            validationErrors.push(err);\n          }\n        }));\n      } else {\n        const isAlreadyValidated = alreadyValidated.find(path => updates[i].startsWith(path + '.'));\n        if (isAlreadyValidated) {\n          continue;\n        }\n        if (schemaPath.$isSingleNested) {\n          alreadyValidated.push(updates[i]);\n        }\n        validatorsToExecute.push(schemaPath.doValidate(v, context, {\n          updateValidator: true\n        }).catch(err => {\n          if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {\n            return;\n          }\n          if (err) {\n            err.path = updates[i];\n            validationErrors.push(err);\n          }\n        }));\n      }\n    }\n  }\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], options?.context === 'query' ? query : null).catch(err => {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }));\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(schemaPath.doValidate(atomicUpdate, options?.context === 'query' ? query : null, {\n          updateValidator: true\n        }).catch(err => {\n          err.path = arrayUpdate;\n          validationErrors.push(err);\n        }));\n      }\n    }\n  }\n  await Promise.all(validatorsToExecute);\n  if (validationErrors.length) {\n    const err = new ValidationError(null);\n    for (const validationError of validationErrors) {\n      err.addError(validationError.path, validationError);\n    }\n    throw err;\n  }\n};","map":{"version":3,"names":["ValidationError","require","cleanPositionalOperators","flatten","module","exports","updateValidators","query","schema","castedDoc","options","keys","Object","updatedKeys","updatedValues","isPull","arrayAtomicUpdates","numKeys","length","hasDollarUpdate","currentUpdate","key","i","startsWith","_keys","ii","$each","concat","flat","paths","numPaths","j","updatedPath","includes","undefined","updates","numUpdates","validatorsToExecute","validationErrors","alreadyValidated","context","v","schemaPath","_getSchema","instance","path","Array","isArray","$in","forEach","push","doValidate","updateValidator","catch","err","$isMongooseArray","$isMongooseDocumentArrayElement","$__","errors","_err","isAlreadyValidated","find","$isSingleNested","storeSubdocValidationError","arrayUpdates","arrayUpdate","$isMongooseDocumentArray","atomicUpdate","Promise","all","validationError","addError"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/updateValidators.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ValidationError = require('../error/validation');\nconst cleanPositionalOperators = require('./schema/cleanPositionalOperators');\nconst flatten = require('./common').flatten;\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = async function updateValidators(query, schema, castedDoc, options) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  let currentUpdate;\n  let key;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate?.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' ||\n            key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n\n  const alreadyValidated = [];\n\n  const context = query;\n  for (let i = 0; i < numUpdates; ++i) {\n    const v = updatedValues[updates[i]];\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      continue;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      continue;\n    }\n\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(\n          schemaPath.doValidate(v, context, { updateValidator: true }).catch(err => {\n            err.path = updates[i] + '.$in.' + i;\n            validationErrors.push(err);\n          })\n        );\n      });\n    } else {\n      if (isPull[updates[i]] &&\n          schemaPath.$isMongooseArray) {\n        continue;\n      }\n\n      if (schemaPath.$isMongooseDocumentArrayElement && v?.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(\n          schemaPath.doValidate(v, context, { updateValidator: true }).catch(err => {\n            if (err.errors) {\n              for (const key of Object.keys(err.errors)) {\n                const _err = err.errors[key];\n                _err.path = updates[i] + '.' + key;\n                validationErrors.push(_err);\n              }\n            } else {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n          })\n        );\n      } else {\n        const isAlreadyValidated = alreadyValidated.find(path => updates[i].startsWith(path + '.'));\n        if (isAlreadyValidated) {\n          continue;\n        }\n        if (schemaPath.$isSingleNested) {\n          alreadyValidated.push(updates[i]);\n        }\n        validatorsToExecute.push(\n          schemaPath.doValidate(v, context, { updateValidator: true }).catch(err => {\n            if (schemaPath.schema != null &&\n                schemaPath.schema.options.storeSubdocValidationError === false &&\n                err instanceof ValidationError) {\n              return;\n            }\n\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n          })\n        );\n      }\n    }\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(\n        schemaPath.doValidate(\n          arrayAtomicUpdates[arrayUpdate],\n          options?.context === 'query' ? query : null\n        ).catch(err => {\n          err.path = arrayUpdate;\n          validationErrors.push(err);\n        })\n      );\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(\n          schemaPath.doValidate(\n            atomicUpdate,\n            options?.context === 'query' ? query : null,\n            { updateValidator: true }\n          ).catch(err => {\n            err.path = arrayUpdate;\n            validationErrors.push(err);\n          })\n        );\n      }\n    }\n  }\n\n  await Promise.all(validatorsToExecute);\n  if (validationErrors.length) {\n    const err = new ValidationError(null);\n\n    for (const validationError of validationErrors) {\n      err.addError(validationError.path, validationError);\n    }\n    throw err;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}