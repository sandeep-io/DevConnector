{"ast":null,"code":"'use strict';\n\nconst MongooseMap = require('../../types/map');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');\nconst get = require('../get');\nconst getVirtual = require('./getVirtual');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst markArraySubdocsPopulated = require('./markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst sift = require('sift').default;\nconst utils = require('../../utils');\nconst {\n  populateModelSymbol\n} = require('../symbols');\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne,\n    isVirtual: o.isVirtual\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n  let setValueIndex = 0;\n  function setValue(val) {\n    ++setValueIndex;\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n    const _allIds = o.allIds[i];\n    if (o.path.endsWith('.$*')) {\n      // Skip maps re: gh-12494\n      return valueFilter(val, options, populateOptions, _allIds);\n    }\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    } else if (o.justOne === true && !Array.isArray(val) && Array.isArray(_allIds)) {\n      return valueFilter(val, options, populateOptions, val == null ? val : _allIds[setValueIndex - 1]);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n  for (i = 0; i < docs.length; ++i) {\n    setValueIndex = 0;\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(v => v == null || sift(o.match[i])(v)) : [rawIds[i]].filter(v => v == null || sift(o.match[i])(v))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val?.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet?.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(_path, valueToSet, docs[i],\n      // Handle setting paths underneath maps using $* by converting arrays into maps of values\n      function lookup(obj, part, val) {\n        if (arguments.length >= 3) {\n          obj[part] = val;\n          return obj[part];\n        }\n        if (obj instanceof Map && part === '$*') {\n          return [...obj.values()];\n        }\n        return obj[part];\n      }, setValue, false);\n      continue;\n    }\n    const parts = _path.split('.');\n    let cur = docs[i];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n      if (parts[j] === '$*') {\n        break;\n      }\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const curPath = parts.slice(0, j + 1).join('.');\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype?.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n      if (valueToSet?.$__ != null) {\n        valueToSet.$__.wasPopulated = {\n          value: o.unpopulatedValues[i]\n        };\n      }\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/**\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n * @param {Any} val\n * @param {Object} assignmentOpts\n * @param {Object} populateOptions\n * @param {Function} [populateOptions.transform]\n * @param {Boolean} allIds\n * @api private\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : v => v;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (!populateOptions.retainNullValues && subdoc == null) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit && ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/**\n * Remove _id from `subdoc` if user specified \"lean\" query option\n * @param {Document} subdoc\n * @param {Object} assignmentOpts\n * @api private\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/**\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n * @param {Any} obj\n * @api private\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n  return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);\n}","map":{"version":3,"names":["MongooseMap","require","SkipPopulateValue","assignRawDocsToIdStructure","get","getVirtual","leanPopulateMap","lookupLocalFields","markArraySubdocsPopulated","mpath","sift","default","utils","populateModelSymbol","module","exports","assignVals","o","userOptions","Object","assign","populateOptions","options","justOne","isVirtual","$nullIfNotFound","populatedModel","originalIds","concat","rawIds","allIds","rawDocs","rawOrder","docs","count","i","setValueIndex","setValue","val","_allIds","path","endsWith","valueFilter","Array","isArray","ret","doc","_docPopulatedModel","push","length","prototype","pop","apply","_path","slice","existingVal","originalModel","schema","valueToSet","numDocs","match","filter","v","originalSchema","isDoc","isMap","Map","isPOJO","_getSchema","_keys","from","keys","reduce","cur","set","$__","parent","$populated","allOptions","map","lookup","obj","part","arguments","values","parts","split","j","isArrayIndex","curPath","join","schematype","$isMongooseArray","model","unpopulatedValues","wasPopulated","value","$isMongooseMap","$__schemaType","some","el","assignmentOpts","userSpecifiedTransform","transform","numValues","subdoc","isPopulatedObject","retainNullValues","maybeRemoveId","originalLimit","rLen","isMongooseArray","excludeId","$__setValue","_doc","_id","has"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/populate/assignVals.js"],"sourcesContent":["'use strict';\n\nconst MongooseMap = require('../../types/map');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');\nconst get = require('../get');\nconst getVirtual = require('./getVirtual');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst markArraySubdocsPopulated = require('./markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst sift = require('sift').default;\nconst utils = require('../../utils');\nconst { populateModelSymbol } = require('../symbols');\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne,\n    isVirtual: o.isVirtual\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n  let setValueIndex = 0;\n\n  function setValue(val) {\n    ++setValueIndex;\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.path.endsWith('.$*')) {\n      // Skip maps re: gh-12494\n      return valueFilter(val, options, populateOptions, _allIds);\n    }\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    } else if (o.justOne === true && !Array.isArray(val) && Array.isArray(_allIds)) {\n      return valueFilter(val, options, populateOptions, val == null ? val : _allIds[setValueIndex - 1]);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    setValueIndex = 0;\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ?\n        rawIds[i].filter(v => v == null || sift(o.match[i])(v)) :\n        [rawIds[i]].filter(v => v == null || sift(o.match[i])(v))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val?.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet?.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(\n        _path,\n        valueToSet,\n        docs[i],\n        // Handle setting paths underneath maps using $* by converting arrays into maps of values\n        function lookup(obj, part, val) {\n          if (arguments.length >= 3) {\n            obj[part] = val;\n            return obj[part];\n          }\n          if (obj instanceof Map && part === '$*') {\n            return [...obj.values()];\n          }\n          return obj[part];\n        },\n        setValue,\n        false\n      );\n      continue;\n    }\n\n    const parts = _path.split('.');\n    let cur = docs[i];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const curPath = parts.slice(0, j + 1).join('.');\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype?.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n\n      if (valueToSet?.$__ != null) {\n        valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };\n      }\n\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/**\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n * @param {Any} val\n * @param {Object} assignmentOpts\n * @param {Object} populateOptions\n * @param {Function} [populateOptions.transform]\n * @param {Boolean} allIds\n * @api private\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : v => v;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (!populateOptions.retainNullValues && subdoc == null) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/**\n * Remove _id from `subdoc` if user specified \"lean\" query option\n * @param {Document} subdoc\n * @param {Object} assignmentOpts\n * @api private\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/**\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n * @param {Any} obj\n * @api private\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) ||\n    obj.$isMongooseMap ||\n    obj.$__ != null ||\n    leanPopulateMap.has(obj);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}