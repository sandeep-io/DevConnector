{"ast":null,"code":"'use strict';\n\n/*!\n * ignore\n */\nconst SchemaUnionOptions = require('../options/schemaUnionOptions');\nconst SchemaType = require('../schemaType');\nconst firstValueSymbol = Symbol('firstValue');\n\n/*!\n * ignore\n */\n\nclass Union extends SchemaType {\n  /**\n   * Create a Union schema type.\n   *\n   * @param {String} key the path in the schema for this schema type\n   * @param {Object} options SchemaType-specific options (must have 'of' as array)\n   * @param {Object} schemaOptions additional options from the schema this schematype belongs to\n   * @param {Schema} parentSchema the schema this schematype belongs to\n   */\n  constructor(key, options, schemaOptions, parentSchema) {\n    super(key, options, 'Union', parentSchema);\n    if (!Array.isArray(options?.of) || options.of.length === 0) {\n      throw new Error('Union schema type requires an array of types');\n    }\n    this.schemaTypes = options.of.map(obj => parentSchema.interpretAsType(key, obj, schemaOptions));\n  }\n  cast(val, doc, init, prev, options) {\n    let firstValue = firstValueSymbol;\n    let lastError;\n    // Loop through each schema type in the union. If one of the schematypes returns a value that is `=== val`, then\n    // use `val`. Otherwise, if one of the schematypes casted successfully, use the first successfully casted value.\n    // Finally, if none of the schematypes casted successfully, throw the error from the last schema type in the union.\n    // The `=== val` check is a workaround to ensure that the original value is returned if it matches one of the schema types,\n    // avoiding cases like where numbers are casted to strings or dates even if the schema type is a number.\n    for (let i = 0; i < this.schemaTypes.length; ++i) {\n      try {\n        const casted = this.schemaTypes[i].cast(val, doc, init, prev, options);\n        if (casted === val) {\n          return casted;\n        }\n        if (firstValue === firstValueSymbol) {\n          firstValue = casted;\n        }\n      } catch (error) {\n        lastError = error;\n      }\n    }\n    if (firstValue !== firstValueSymbol) {\n      return firstValue;\n    }\n    throw lastError;\n  }\n\n  // Setters also need to be aware of casting - we need to apply the setters of the entry in the union we choose.\n  applySetters(val, doc, init, prev, options) {\n    let firstValue = firstValueSymbol;\n    let lastError;\n    // Loop through each schema type in the union. If one of the schematypes returns a value that is `=== val`, then\n    // use `val`. Otherwise, if one of the schematypes casted successfully, use the first successfully casted value.\n    // Finally, if none of the schematypes casted successfully, throw the error from the last schema type in the union.\n    // The `=== val` check is a workaround to ensure that the original value is returned if it matches one of the schema types,\n    // avoiding cases like where numbers are casted to strings or dates even if the schema type is a number.\n    for (let i = 0; i < this.schemaTypes.length; ++i) {\n      try {\n        let castedVal = this.schemaTypes[i]._applySetters(val, doc, init, prev, options);\n        if (castedVal == null) {\n          castedVal = this.schemaTypes[i]._castNullish(castedVal);\n        } else {\n          castedVal = this.schemaTypes[i].cast(castedVal, doc, init, prev, options);\n        }\n        if (castedVal === val) {\n          return castedVal;\n        }\n        if (firstValue === firstValueSymbol) {\n          firstValue = castedVal;\n        }\n      } catch (error) {\n        lastError = error;\n      }\n    }\n    if (firstValue !== firstValueSymbol) {\n      return firstValue;\n    }\n    throw lastError;\n  }\n  clone() {\n    const schematype = super.clone();\n    schematype.schemaTypes = this.schemaTypes.map(schemaType => schemaType.clone());\n    return schematype;\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nUnion.schemaName = 'Union';\nUnion.defaultOptions = {};\nUnion.prototype.OptionsConstructor = SchemaUnionOptions;\nmodule.exports = Union;","map":{"version":3,"names":["SchemaUnionOptions","require","SchemaType","firstValueSymbol","Symbol","Union","constructor","key","options","schemaOptions","parentSchema","Array","isArray","of","length","Error","schemaTypes","map","obj","interpretAsType","cast","val","doc","init","prev","firstValue","lastError","i","casted","error","applySetters","castedVal","_applySetters","_castNullish","clone","schematype","schemaType","schemaName","defaultOptions","prototype","OptionsConstructor","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/schema/union.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst SchemaUnionOptions = require('../options/schemaUnionOptions');\nconst SchemaType = require('../schemaType');\n\nconst firstValueSymbol = Symbol('firstValue');\n\n/*!\n * ignore\n */\n\nclass Union extends SchemaType {\n  /**\n   * Create a Union schema type.\n   *\n   * @param {String} key the path in the schema for this schema type\n   * @param {Object} options SchemaType-specific options (must have 'of' as array)\n   * @param {Object} schemaOptions additional options from the schema this schematype belongs to\n   * @param {Schema} parentSchema the schema this schematype belongs to\n   */\n  constructor(key, options, schemaOptions, parentSchema) {\n    super(key, options, 'Union', parentSchema);\n    if (!Array.isArray(options?.of) || options.of.length === 0) {\n      throw new Error('Union schema type requires an array of types');\n    }\n    this.schemaTypes = options.of.map(obj => parentSchema.interpretAsType(key, obj, schemaOptions));\n  }\n\n  cast(val, doc, init, prev, options) {\n    let firstValue = firstValueSymbol;\n    let lastError;\n    // Loop through each schema type in the union. If one of the schematypes returns a value that is `=== val`, then\n    // use `val`. Otherwise, if one of the schematypes casted successfully, use the first successfully casted value.\n    // Finally, if none of the schematypes casted successfully, throw the error from the last schema type in the union.\n    // The `=== val` check is a workaround to ensure that the original value is returned if it matches one of the schema types,\n    // avoiding cases like where numbers are casted to strings or dates even if the schema type is a number.\n    for (let i = 0; i < this.schemaTypes.length; ++i) {\n      try {\n        const casted = this.schemaTypes[i].cast(val, doc, init, prev, options);\n        if (casted === val) {\n          return casted;\n        }\n        if (firstValue === firstValueSymbol) {\n          firstValue = casted;\n        }\n      } catch (error) {\n        lastError = error;\n      }\n    }\n    if (firstValue !== firstValueSymbol) {\n      return firstValue;\n    }\n    throw lastError;\n  }\n\n  // Setters also need to be aware of casting - we need to apply the setters of the entry in the union we choose.\n  applySetters(val, doc, init, prev, options) {\n    let firstValue = firstValueSymbol;\n    let lastError;\n    // Loop through each schema type in the union. If one of the schematypes returns a value that is `=== val`, then\n    // use `val`. Otherwise, if one of the schematypes casted successfully, use the first successfully casted value.\n    // Finally, if none of the schematypes casted successfully, throw the error from the last schema type in the union.\n    // The `=== val` check is a workaround to ensure that the original value is returned if it matches one of the schema types,\n    // avoiding cases like where numbers are casted to strings or dates even if the schema type is a number.\n    for (let i = 0; i < this.schemaTypes.length; ++i) {\n      try {\n        let castedVal = this.schemaTypes[i]._applySetters(val, doc, init, prev, options);\n        if (castedVal == null) {\n          castedVal = this.schemaTypes[i]._castNullish(castedVal);\n        } else {\n          castedVal = this.schemaTypes[i].cast(castedVal, doc, init, prev, options);\n        }\n        if (castedVal === val) {\n          return castedVal;\n        }\n        if (firstValue === firstValueSymbol) {\n          firstValue = castedVal;\n        }\n      } catch (error) {\n        lastError = error;\n      }\n    }\n    if (firstValue !== firstValueSymbol) {\n      return firstValue;\n    }\n    throw lastError;\n  }\n\n  clone() {\n    const schematype = super.clone();\n\n    schematype.schemaTypes = this.schemaTypes.map(schemaType => schemaType.clone());\n    return schematype;\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nUnion.schemaName = 'Union';\n\nUnion.defaultOptions = {};\n\nUnion.prototype.OptionsConstructor = SchemaUnionOptions;\n\nmodule.exports = Union;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}