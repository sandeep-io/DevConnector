{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;\nconst responses_1 = require(\"../cmap/wire_protocol/responses\");\nconst error_1 = require(\"../error\");\nconst write_concern_1 = require(\"../write_concern\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nexports.DB_AGGREGATE_COLLECTION = 1;\n/** @internal */\nclass AggregateOperation extends command_1.CommandOperation {\n  constructor(ns, pipeline, options) {\n    super(undefined, {\n      ...options,\n      dbName: ns.db\n    });\n    this.SERVER_COMMAND_RESPONSE_TYPE = responses_1.CursorResponse;\n    this.options = {\n      ...options\n    };\n    // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n    this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;\n    this.pipeline = pipeline;\n    // determine if we have a write stage, override read preference if so\n    this.hasWriteStage = false;\n    if (typeof options?.out === 'string') {\n      this.pipeline = this.pipeline.concat({\n        $out: options.out\n      });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n    if (!this.hasWriteStage) {\n      delete this.options.writeConcern;\n    }\n    if (options?.cursor != null && typeof options.cursor !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');\n    }\n    this.SERVER_COMMAND_RESPONSE_TYPE = this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse;\n  }\n  get commandName() {\n    return 'aggregate';\n  }\n  get canRetryRead() {\n    return !this.hasWriteStage;\n  }\n  addToPipeline(stage) {\n    this.pipeline.push(stage);\n  }\n  buildCommandDocument() {\n    const options = this.options;\n    const command = {\n      aggregate: this.target,\n      pipeline: this.pipeline\n    };\n    if (this.hasWriteStage && this.writeConcern) {\n      write_concern_1.WriteConcern.apply(command, this.writeConcern);\n    }\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n    if (options.let) {\n      command.let = options.let;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n    command.cursor = options.cursor || {};\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n    return command;\n  }\n  handleOk(response) {\n    return response;\n  }\n}\nexports.AggregateOperation = AggregateOperation;\n(0, operation_1.defineAspects)(AggregateOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING, operation_1.Aspect.SUPPORTS_RAW_DATA]);","map":{"version":3,"names":["responses_1","require","error_1","write_concern_1","command_1","operation_1","exports","DB_AGGREGATE_COLLECTION","AggregateOperation","CommandOperation","constructor","ns","pipeline","options","undefined","dbName","db","SERVER_COMMAND_RESPONSE_TYPE","CursorResponse","target","collection","hasWriteStage","out","concat","$out","length","finalStage","$merge","writeConcern","cursor","MongoInvalidArgumentError","explain","ExplainedCursorResponse","commandName","canRetryRead","addToPipeline","stage","push","buildCommandDocument","command","aggregate","WriteConcern","apply","bypassDocumentValidation","allowDiskUse","hint","let","comment","batchSize","handleOk","response","defineAspects","Aspect","READ_OPERATION","RETRYABLE","EXPLAINABLE","CURSOR_CREATING","SUPPORTS_RAW_DATA"],"sources":["C:\\DEVC\\node_modules\\mongodb\\src\\operations\\aggregate.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { CursorResponse, ExplainedCursorResponse } from '../cmap/wire_protocol/responses';\nimport { type CursorTimeoutMode } from '../cursor/abstract_cursor';\nimport { MongoInvalidArgumentError } from '../error';\nimport { type ExplainOptions } from '../explain';\nimport { type MongoDBNamespace } from '../utils';\nimport { WriteConcern } from '../write_concern';\nimport { type CollationOptions, CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects, type Hint } from './operation';\n\n/** @internal */\nexport const DB_AGGREGATE_COLLECTION = 1 as const;\n\n/** @public */\nexport interface AggregateOptions extends Omit<CommandOperationOptions, 'explain'> {\n  /** allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 \\>). */\n  allowDiskUse?: boolean;\n  /** The number of documents to return per batch. See [aggregation documentation](https://www.mongodb.com/docs/manual/reference/command/aggregate). */\n  batchSize?: number;\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** Return the query as cursor, on 2.6 \\> it returns as a real cursor on pre 2.6 it returns as an emulated cursor. */\n  cursor?: Document;\n  /**\n   * Specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.\n   */\n  maxTimeMS?: number;\n  /** The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. */\n  maxAwaitTimeMS?: number;\n  /** Specify collation. */\n  collation?: CollationOptions;\n  /** Add an index selection hint to an aggregation command */\n  hint?: Hint;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n\n  out?: string;\n\n  /**\n   * Specifies the verbosity mode for the explain output.\n   * @deprecated This API is deprecated in favor of `collection.aggregate().explain()`\n   * or `db.aggregate().explain()`.\n   */\n  explain?: ExplainOptions['explain'];\n  /** @internal */\n  timeoutMode?: CursorTimeoutMode;\n}\n\n/** @internal */\nexport class AggregateOperation extends CommandOperation<CursorResponse> {\n  override SERVER_COMMAND_RESPONSE_TYPE = CursorResponse;\n  override options: AggregateOptions;\n  target: string | typeof DB_AGGREGATE_COLLECTION;\n  pipeline: Document[];\n  hasWriteStage: boolean;\n\n  constructor(ns: MongoDBNamespace, pipeline: Document[], options?: AggregateOptions) {\n    super(undefined, { ...options, dbName: ns.db });\n\n    this.options = { ...options };\n\n    // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n    this.target = ns.collection || DB_AGGREGATE_COLLECTION;\n\n    this.pipeline = pipeline;\n\n    // determine if we have a write stage, override read preference if so\n    this.hasWriteStage = false;\n    if (typeof options?.out === 'string') {\n      this.pipeline = this.pipeline.concat({ $out: options.out });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n\n    if (!this.hasWriteStage) {\n      delete this.options.writeConcern;\n    }\n\n    if (options?.cursor != null && typeof options.cursor !== 'object') {\n      throw new MongoInvalidArgumentError('Cursor options must be an object');\n    }\n\n    this.SERVER_COMMAND_RESPONSE_TYPE = this.explain ? ExplainedCursorResponse : CursorResponse;\n  }\n\n  override get commandName() {\n    return 'aggregate' as const;\n  }\n\n  override get canRetryRead(): boolean {\n    return !this.hasWriteStage;\n  }\n\n  addToPipeline(stage: Document): void {\n    this.pipeline.push(stage);\n  }\n\n  override buildCommandDocument(): Document {\n    const options = this.options;\n    const command: Document = { aggregate: this.target, pipeline: this.pipeline };\n\n    if (this.hasWriteStage && this.writeConcern) {\n      WriteConcern.apply(command, this.writeConcern);\n    }\n\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n\n    if (options.let) {\n      command.let = options.let;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    command.cursor = options.cursor || {};\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n\n    return command;\n  }\n\n  override handleOk(\n    response: InstanceType<typeof this.SERVER_COMMAND_RESPONSE_TYPE>\n  ): CursorResponse {\n    return response;\n  }\n}\n\ndefineAspects(AggregateOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.EXPLAINABLE,\n  Aspect.CURSOR_CREATING,\n  Aspect.SUPPORTS_RAW_DATA\n]);\n"],"mappings":";;;;;;AACA,MAAAA,WAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AAGA,MAAAE,eAAA,GAAAF,OAAA;AACA,MAAAG,SAAA,GAAAH,OAAA;AACA,MAAAI,WAAA,GAAAJ,OAAA;AAEA;AACaK,OAAA,CAAAC,uBAAuB,GAAG,CAAU;AAqCjD;AACA,MAAaC,kBAAmB,SAAQJ,SAAA,CAAAK,gBAAgC;EAOtEC,YAAYC,EAAoB,EAAEC,QAAoB,EAAEC,OAA0B;IAChF,KAAK,CAACC,SAAS,EAAE;MAAE,GAAGD,OAAO;MAAEE,MAAM,EAAEJ,EAAE,CAACK;IAAE,CAAE,CAAC;IAPxC,KAAAC,4BAA4B,GAAGjB,WAAA,CAAAkB,cAAc;IASpD,IAAI,CAACL,OAAO,GAAG;MAAE,GAAGA;IAAO,CAAE;IAE7B;IACA,IAAI,CAACM,MAAM,GAAGR,EAAE,CAACS,UAAU,IAAId,OAAA,CAAAC,uBAAuB;IAEtD,IAAI,CAACK,QAAQ,GAAGA,QAAQ;IAExB;IACA,IAAI,CAACS,aAAa,GAAG,KAAK;IAC1B,IAAI,OAAOR,OAAO,EAAES,GAAG,KAAK,QAAQ,EAAE;MACpC,IAAI,CAACV,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACW,MAAM,CAAC;QAAEC,IAAI,EAAEX,OAAO,CAACS;MAAG,CAAE,CAAC;MAC3D,IAAI,CAACD,aAAa,GAAG,IAAI;IAC3B,CAAC,MAAM,IAAIT,QAAQ,CAACa,MAAM,GAAG,CAAC,EAAE;MAC9B,MAAMC,UAAU,GAAGd,QAAQ,CAACA,QAAQ,CAACa,MAAM,GAAG,CAAC,CAAC;MAChD,IAAIC,UAAU,CAACF,IAAI,IAAIE,UAAU,CAACC,MAAM,EAAE;QACxC,IAAI,CAACN,aAAa,GAAG,IAAI;MAC3B;IACF;IAEA,IAAI,CAAC,IAAI,CAACA,aAAa,EAAE;MACvB,OAAO,IAAI,CAACR,OAAO,CAACe,YAAY;IAClC;IAEA,IAAIf,OAAO,EAAEgB,MAAM,IAAI,IAAI,IAAI,OAAOhB,OAAO,CAACgB,MAAM,KAAK,QAAQ,EAAE;MACjE,MAAM,IAAI3B,OAAA,CAAA4B,yBAAyB,CAAC,kCAAkC,CAAC;IACzE;IAEA,IAAI,CAACb,4BAA4B,GAAG,IAAI,CAACc,OAAO,GAAG/B,WAAA,CAAAgC,uBAAuB,GAAGhC,WAAA,CAAAkB,cAAc;EAC7F;EAEA,IAAae,WAAWA,CAAA;IACtB,OAAO,WAAoB;EAC7B;EAEA,IAAaC,YAAYA,CAAA;IACvB,OAAO,CAAC,IAAI,CAACb,aAAa;EAC5B;EAEAc,aAAaA,CAACC,KAAe;IAC3B,IAAI,CAACxB,QAAQ,CAACyB,IAAI,CAACD,KAAK,CAAC;EAC3B;EAESE,oBAAoBA,CAAA;IAC3B,MAAMzB,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAM0B,OAAO,GAAa;MAAEC,SAAS,EAAE,IAAI,CAACrB,MAAM;MAAEP,QAAQ,EAAE,IAAI,CAACA;IAAQ,CAAE;IAE7E,IAAI,IAAI,CAACS,aAAa,IAAI,IAAI,CAACO,YAAY,EAAE;MAC3CzB,eAAA,CAAAsC,YAAY,CAACC,KAAK,CAACH,OAAO,EAAE,IAAI,CAACX,YAAY,CAAC;IAChD;IAEA,IAAIf,OAAO,CAAC8B,wBAAwB,KAAK,IAAI,EAAE;MAC7CJ,OAAO,CAACI,wBAAwB,GAAG9B,OAAO,CAAC8B,wBAAwB;IACrE;IAEA,IAAI,OAAO9B,OAAO,CAAC+B,YAAY,KAAK,SAAS,EAAE;MAC7CL,OAAO,CAACK,YAAY,GAAG/B,OAAO,CAAC+B,YAAY;IAC7C;IAEA,IAAI/B,OAAO,CAACgC,IAAI,EAAE;MAChBN,OAAO,CAACM,IAAI,GAAGhC,OAAO,CAACgC,IAAI;IAC7B;IAEA,IAAIhC,OAAO,CAACiC,GAAG,EAAE;MACfP,OAAO,CAACO,GAAG,GAAGjC,OAAO,CAACiC,GAAG;IAC3B;IAEA;IACA;IACA,IAAIjC,OAAO,CAACkC,OAAO,KAAKjC,SAAS,EAAE;MACjCyB,OAAO,CAACQ,OAAO,GAAGlC,OAAO,CAACkC,OAAO;IACnC;IAEAR,OAAO,CAACV,MAAM,GAAGhB,OAAO,CAACgB,MAAM,IAAI,EAAE;IACrC,IAAIhB,OAAO,CAACmC,SAAS,IAAI,CAAC,IAAI,CAAC3B,aAAa,EAAE;MAC5CkB,OAAO,CAACV,MAAM,CAACmB,SAAS,GAAGnC,OAAO,CAACmC,SAAS;IAC9C;IAEA,OAAOT,OAAO;EAChB;EAESU,QAAQA,CACfC,QAAgE;IAEhE,OAAOA,QAAQ;EACjB;;AA9FF5C,OAAA,CAAAE,kBAAA,GAAAA,kBAAA;AAiGA,IAAAH,WAAA,CAAA8C,aAAa,EAAC3C,kBAAkB,EAAE,CAChCH,WAAA,CAAA+C,MAAM,CAACC,cAAc,EACrBhD,WAAA,CAAA+C,MAAM,CAACE,SAAS,EAChBjD,WAAA,CAAA+C,MAAM,CAACG,WAAW,EAClBlD,WAAA,CAAA+C,MAAM,CAACI,eAAe,EACtBnD,WAAA,CAAA+C,MAAM,CAACK,iBAAiB,CACzB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}