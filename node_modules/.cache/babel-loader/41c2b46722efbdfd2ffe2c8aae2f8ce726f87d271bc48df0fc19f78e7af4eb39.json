{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst EachAsyncMultiError = require('../../error/eachAsyncMultiError');\nconst immediate = require('../immediate');\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel\n * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = async function eachAsync(next, fn, options) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const signal = options.signal;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n  let aborted = false;\n  return new Promise((resolve, reject) => {\n    if (signal != null) {\n      if (signal.aborted) {\n        return resolve(null);\n      }\n      signal.addEventListener('abort', () => {\n        aborted = true;\n        return resolve(null);\n      }, {\n        once: true\n      });\n    }\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n    iterate((err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n  function iterate(finalCallback) {\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(createFetch());\n    }\n    function createFetch() {\n      let documentsBatch = [];\n      let drained = false;\n      return fetch;\n      function fetch(done) {\n        if (drained || aborted) {\n          return done();\n        } else if (error) {\n          return done();\n        }\n        next(function (err, doc) {\n          if (error != null) {\n            return done();\n          }\n          if (err != null) {\n            if (err.name === 'MongoCursorExhaustedError') {\n              // We may end up calling `next()` multiple times on an exhausted\n              // cursor, which leads to an error. In case cursor is exhausted,\n              // just treat it as if the cursor returned no document, which is\n              // how a cursor indicates it is exhausted.\n              doc = null;\n            } else if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              finalCallback(err);\n              return done();\n            }\n          }\n          if (doc == null) {\n            drained = true;\n            if (handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;\n              finalCallback(finalErr);\n            } else if (batchSize && documentsBatch.length) {\n              handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n            }\n            return done();\n          }\n          ++handleResultsInProgress;\n\n          // Kick off the subsequent `next()` before handling the result, but\n          // make sure we know that we still have a result to handle re: #8422\n          immediate(() => done());\n          if (batchSize) {\n            documentsBatch.push(doc);\n          }\n\n          // If the current documents size is less than the provided batch size don't process the documents yet\n          if (batchSize && documentsBatch.length !== batchSize) {\n            immediate(() => enqueue(fetch));\n            return;\n          }\n          const docsToProcess = batchSize ? documentsBatch : doc;\n          function handleNextResultCallBack(err) {\n            if (batchSize) {\n              handleResultsInProgress -= documentsBatch.length;\n              documentsBatch = [];\n            } else {\n              --handleResultsInProgress;\n            }\n            if (err != null) {\n              if (continueOnError) {\n                aggregatedErrors.push(err);\n              } else {\n                error = err;\n                return finalCallback(err);\n              }\n            }\n            if ((drained || aborted) && handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;\n              return finalCallback(finalErr);\n            }\n            immediate(() => enqueue(fetch));\n          }\n          handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n        });\n      }\n    }\n  }\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n    if (typeof maybePromise?.then === 'function') {\n      maybePromise.then(function () {\n        callback(null);\n      }, function (error) {\n        callback(error || new Error('`eachAsync()` promise rejected without error'));\n      });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n  return function enqueue(fn) {\n    if (inProgress === null && _queue.length === 0) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n  return new EachAsyncMultiError(aggregatedErrors);\n}","map":{"version":3,"names":["EachAsyncMultiError","require","immediate","module","exports","eachAsync","next","fn","options","parallel","batchSize","signal","continueOnError","aggregatedErrors","enqueue","asyncQueue","aborted","Promise","resolve","reject","addEventListener","once","TypeError","Number","isInteger","iterate","err","res","finalCallback","handleResultsInProgress","currentDocumentIndex","error","i","createFetch","documentsBatch","drained","fetch","done","doc","name","push","finalErr","createEachAsyncMultiError","length","handleNextResult","handleNextResultCallBack","docsToProcess","callback","maybePromise","then","Error","_queue","inProgress","id","_step","shift"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/cursor/eachAsync.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EachAsyncMultiError = require('../../error/eachAsyncMultiError');\nconst immediate = require('../immediate');\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel\n * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = async function eachAsync(next, fn, options) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const signal = options.signal;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n\n  let aborted = false;\n\n  return new Promise((resolve, reject) => {\n    if (signal != null) {\n      if (signal.aborted) {\n        return resolve(null);\n      }\n\n      signal.addEventListener('abort', () => {\n        aborted = true;\n        return resolve(null);\n      }, { once: true });\n    }\n\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n\n    iterate((err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n\n  function iterate(finalCallback) {\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(createFetch());\n    }\n\n    function createFetch() {\n      let documentsBatch = [];\n      let drained = false;\n\n      return fetch;\n\n      function fetch(done) {\n        if (drained || aborted) {\n          return done();\n        } else if (error) {\n          return done();\n        }\n\n        next(function(err, doc) {\n          if (error != null) {\n            return done();\n          }\n          if (err != null) {\n            if (err.name === 'MongoCursorExhaustedError') {\n              // We may end up calling `next()` multiple times on an exhausted\n              // cursor, which leads to an error. In case cursor is exhausted,\n              // just treat it as if the cursor returned no document, which is\n              // how a cursor indicates it is exhausted.\n              doc = null;\n            } else if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              finalCallback(err);\n              return done();\n            }\n          }\n          if (doc == null) {\n            drained = true;\n            if (handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n\n              finalCallback(finalErr);\n            } else if (batchSize && documentsBatch.length) {\n              handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n            }\n            return done();\n          }\n\n          ++handleResultsInProgress;\n\n          // Kick off the subsequent `next()` before handling the result, but\n          // make sure we know that we still have a result to handle re: #8422\n          immediate(() => done());\n\n          if (batchSize) {\n            documentsBatch.push(doc);\n          }\n\n          // If the current documents size is less than the provided batch size don't process the documents yet\n          if (batchSize && documentsBatch.length !== batchSize) {\n            immediate(() => enqueue(fetch));\n            return;\n          }\n\n          const docsToProcess = batchSize ? documentsBatch : doc;\n\n          function handleNextResultCallBack(err) {\n            if (batchSize) {\n              handleResultsInProgress -= documentsBatch.length;\n              documentsBatch = [];\n            } else {\n              --handleResultsInProgress;\n            }\n            if (err != null) {\n              if (continueOnError) {\n                aggregatedErrors.push(err);\n              } else {\n                error = err;\n                return finalCallback(err);\n              }\n            }\n            if ((drained || aborted) && handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n              return finalCallback(finalErr);\n            }\n\n            immediate(() => enqueue(fetch));\n          }\n\n          handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n        });\n      }\n    }\n  }\n\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n    if (typeof maybePromise?.then === 'function') {\n      maybePromise.then(\n        function() { callback(null); },\n        function(error) {\n          callback(error || new Error('`eachAsync()` promise rejected without error'));\n        });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n\n  return function enqueue(fn) {\n    if (\n      inProgress === null &&\n      _queue.length === 0\n    ) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\n\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n\n  return new EachAsyncMultiError(aggregatedErrors);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}