{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst clone = require('../clone');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model?.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  let modelNamesSet;\n  const available = {};\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n    if (doc.$__ != null && doc.populated(options.path)) {\n      const forceRepopulate = options.forceRepopulate ?? doc.constructor.base.options.forceRepopulate;\n      if (forceRepopulate === false) {\n        continue;\n      }\n    }\n    const docSchema = doc?.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema?.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path + ' because it is a subproperty of a document array');\n    }\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n    if (schema?.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        modelNamesSet = modelNamesSet || new Set();\n        for (const modelName of _modelNames) {\n          if (modelNamesSet.has(modelName) === false) {\n            modelNamesSet.add(modelName);\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n      if (!modelNames) {\n        continue;\n      }\n    }\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ? schema.every(schema => !schema.$isMongooseArray) : !schema.$isMongooseArray;\n      }\n    }\n    if (!modelNames) {\n      continue;\n    }\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n    let match = get(options, 'match', null);\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    throwOn$where(match);\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret);\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n    const originalSchema = schema;\n    if (schema?.instance === 'Array') {\n      schema = schema.embeddedSchemaType;\n    }\n    if (schema?.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n    const ref = schema?.options?.ref;\n    refPath = schema?.options?.refPath;\n    if (schema != null && schema[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery) {\n      return {\n        modelNames: null\n      };\n    }\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n        if (schemaForCurrentDoc?.embeddedSchemaType) {\n          schemaForCurrentDoc = schemaForCurrentDoc.embeddedSchemaType;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null && typeof ref === 'function' && options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return {\n          modelNames: modelNames,\n          justOne: justOne,\n          isRefPath: isRefPath,\n          refPath: refPath\n        };\n      }\n    }\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n    return {\n      modelNames: modelNames,\n      justOne: justOne,\n      isRefPath: isRefPath,\n      refPath: refPath\n    };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n    if (virtual.options.skip != null && !Object.hasOwn(options, 'skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !Object.hasOwn(options, 'limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !Object.hasOwn(options, 'perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    // Use the correct target doc/sub-doc for dynamic ref on nested schema. See gh-12363\n    if (_virtualRes.nestedSchemaPath && typeof virtual.options.ref === 'function') {\n      const subdocs = utils.getValue(_virtualRes.nestedSchemaPath, doc);\n      modelNames = Array.isArray(subdocs) ? subdocs.flatMap(subdoc => virtual._getModelNamesForPopulate(subdoc)) : virtual._getModelNamesForPopulate(subdocs);\n    } else {\n      modelNames = virtual._getModelNamesForPopulate(doc);\n    }\n    if (virtual.options.refPath) {\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      justOne = !!virtual.options.justOne;\n    }\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) || get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    throwOn$where(match);\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection ?? model.db;\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n  if (modelNames == null) {\n    return;\n  }\n  const flatModelNames = utils.array.flatten(modelNames);\n  let k = flatModelNames.length;\n  while (k--) {\n    let modelName = flatModelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n    let ids = ret;\n    const modelNamesForRefPath = data.modelNamesInOrder || modelNames;\n    if (data.isRefPath && Array.isArray(ret) && ret.length === modelNamesForRefPath.length) {\n      ids = matchIdsToRefPaths(ret, modelNamesForRefPath, modelName);\n    }\n    const perDocumentLimit = options.perDocumentLimit == null ? get(options, 'options.perDocumentLimit', null) : options.perDocumentLimit;\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n  return conn.model(modelName);\n}\nfunction matchIdsToRefPaths(ids, refPaths, refPathToFind) {\n  if (!Array.isArray(refPaths)) {\n    return refPaths === refPathToFind ? Array.isArray(ids) ? utils.array.flatten(ids) : [ids] : [];\n  }\n  if (Array.isArray(ids) && Array.isArray(refPaths)) {\n    return ids.flatMap((id, index) => matchIdsToRefPaths(id, refPaths[index], refPathToFind));\n  }\n  return [];\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ? model.schema.path(localField) : localFieldPathType.schema;\n  const localFieldGetters = localFieldPath?.getters || [];\n  localField = localFieldPath?.instance === 'Embedded' ? localField + '._id' : localField;\n  const _populateOptions = get(options, 'options', {});\n  const getters = 'getters' in _populateOptions ? _populateOptions.getters : get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val?.$__ != null) {\n    return val._doc._id;\n  }\n  if (val?._id != null && !schema?.$isSchemaMap) {\n    return val._id;\n  }\n  if (Array.isArray(val)) {\n    const rawVal = val.__array ?? val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i]?.$__ != null) {\n        rawVal[i] = rawVal[i]._doc._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n  // The intent here is we should only flatten the object if we expect\n  // to get a Map in the end. Avoid doing this for mixed types.\n  schema?.[schemaMixedSymbol] == null) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null && schematype.$isMongooseDocumentArray && schematype.Constructor.discriminators != null && utils.hasOwnKeys(schematype.Constructor.discriminators)) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.Constructor.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.Constructor.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator?.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n  return modelNames;\n}\n\n/**\n * Throw an error if there are any $where keys\n */\n\nfunction throwOn$where(match) {\n  if (match == null) {\n    return;\n  }\n  if (typeof match !== 'object') {\n    return;\n  }\n  for (const key of Object.keys(match)) {\n    if (key === '$where') {\n      throw new MongooseError('Cannot use $where filter with populate() match');\n    }\n    if (match[key] != null && typeof match[key] === 'object') {\n      throwOn$where(match[key]);\n    }\n  }\n}","map":{"version":3,"names":["MongooseError","require","SkipPopulateValue","clone","get","getDiscriminatorByValue","getConstructorName","getSchemaTypes","getVirtual","lookupLocalFields","mpath","modelNamesFromRefPath","utils","modelSymbol","populateModelSymbol","schemaMixedSymbol","StrictPopulate","module","exports","getModelsMapForPopulate","model","docs","options","doc","len","length","map","modelNameFromQuery","modelName","schema","refPath","modelNames","modelNamesSet","available","modelSchema","_localModel","nested","path","_virtualRes","virtual","_virtualPopulate","allSchemaTypes","Array","isArray","filter","v","isStrictPopulateDisabled","strictPopulate","_fullPath","i","justOne","$__","populated","forceRepopulate","constructor","base","docSchema","$__schema","$isMongooseDocumentArray","ref","isUnderneathDocArray","$parentSchemaDocArray","isRefPath","normalizedRefPath","schemaOptions","modelNamesInOrder","instance","data","localField","foreignField","res","_getModelNames","unpopulatedValue","id","addModelNamesToMap","schemasArray","_schema","_modelNames","error","Set","has","add","push","from","endsWith","every","$isMongooseArray","isVirtual","ret","_getLocalFieldValues","String","getValue","_docs","slice","match","hasMatchFunction","call","throwOn$where","embeddedDiscriminatorModelNames","_findRefPathForDiscriminators","err","originalSchema","embeddedSchemaType","$isSchemaMap","$__schemaType","subdocPath","vals","subdocsBeingPopulated","array","flatten","subdoc","_queryProjection","forEach","name","schemaForCurrentDoc","discriminatorValue","modelForCurrentDoc","discriminatorKey","discriminatorModel","discriminators","_getModelFromConn","db","_getSchema","_arrayPath","handleRefFunction","virtualPrefix","nestedSchemaPath","field","count","skip","Object","hasOwn","limit","perDocumentLimit","subdocs","flatMap","_getModelNamesForPopulate","baseMatch","assign","convertTo_id","connection","cloneArrays","flatModelNames","k","Model","ids","modelNamesForRefPath","matchIdsToRefPaths","currentOptions","merge","allIds","unpopulatedValues","conn","models","_parent","refPaths","refPathToFind","index","localFieldPathType","_getPathType","localFieldPath","localFieldGetters","getters","_populateOptions","hydratedDoc","hydrate","localFieldValue","localFieldHydratedValue","split","localFieldArrVal","localFieldArrIndex","applyGetters","val","_doc","_id","rawVal","__array","isMongooseArray","$schema","_castForPopulate","$parent","concat","key","keys","Map","values","pieces","cur","piece","schematype","Constructor","hasOwnKeys","remnant","substring","discriminatorName","discriminator","discriminatorSchema","_path","docValue","join"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst clone = require('../clone');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\n\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model?.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  let modelNamesSet;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    if (doc.$__ != null && doc.populated(options.path)) {\n      const forceRepopulate = options.forceRepopulate ?? doc.constructor.base.options.forceRepopulate;\n      if (forceRepopulate === false) {\n        continue;\n      }\n    }\n\n    const docSchema = doc?.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema?.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema?.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        modelNamesSet = modelNamesSet || new Set();\n        for (const modelName of _modelNames) {\n          if (modelNamesSet.has(modelName) === false) {\n            modelNamesSet.add(modelName);\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    throwOn$where(match);\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    const originalSchema = schema;\n    if (schema?.instance === 'Array') {\n      schema = schema.embeddedSchemaType;\n    }\n    if (schema?.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema?.options?.ref;\n    refPath = schema?.options?.refPath;\n    if (schema != null &&\n        schema[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ?\n          utils.array.flatten(vals) :\n          (vals ? [vals] : []);\n\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n            forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc?.embeddedSchemaType) {\n          schemaForCurrentDoc = schemaForCurrentDoc.embeddedSchemaType;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n              forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !Object.hasOwn(options, 'skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !Object.hasOwn(options, 'limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !Object.hasOwn(options, 'perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    // Use the correct target doc/sub-doc for dynamic ref on nested schema. See gh-12363\n    if (_virtualRes.nestedSchemaPath && typeof virtual.options.ref === 'function') {\n      const subdocs = utils.getValue(_virtualRes.nestedSchemaPath, doc);\n      modelNames = Array.isArray(subdocs)\n        ? subdocs.flatMap(subdoc => virtual._getModelNamesForPopulate(subdoc))\n        : virtual._getModelNamesForPopulate(subdocs);\n    } else {\n      modelNames = virtual._getModelNamesForPopulate(doc);\n    }\n    if (virtual.options.refPath) {\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      justOne = !!virtual.options.justOne;\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    throwOn$where(match);\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection ?? model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  const flatModelNames = utils.array.flatten(modelNames);\n  let k = flatModelNames.length;\n  while (k--) {\n    let modelName = flatModelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n\n    const modelNamesForRefPath = data.modelNamesInOrder || modelNames;\n    if (data.isRefPath && Array.isArray(ret) && ret.length === modelNamesForRefPath.length) {\n      ids = matchIdsToRefPaths(ret, modelNamesForRefPath, modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\nfunction matchIdsToRefPaths(ids, refPaths, refPathToFind) {\n  if (!Array.isArray(refPaths)) {\n    return refPaths === refPathToFind\n      ? Array.isArray(ids)\n        ? utils.array.flatten(ids)\n        : [ids]\n      : [];\n  }\n  if (Array.isArray(ids) && Array.isArray(refPaths)) {\n    return ids.flatMap((id, index) => matchIdsToRefPaths(id, refPaths[index], refPathToFind));\n  }\n  return [];\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath?.getters || [];\n\n  localField = localFieldPath?.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val?.$__ != null) {\n    return val._doc._id;\n  }\n  if (val?._id != null && !schema?.$isSchemaMap) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array ?? val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i]?.$__ != null) {\n        rawVal[i] = rawVal[i]._doc._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      schema?.[schemaMixedSymbol] == null) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseDocumentArray &&\n        schematype.Constructor.discriminators != null &&\n        utils.hasOwnKeys(schematype.Constructor.discriminators)) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.Constructor.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.Constructor.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator?.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}\n\n/**\n * Throw an error if there are any $where keys\n */\n\nfunction throwOn$where(match) {\n  if (match == null) {\n    return;\n  }\n  if (typeof match !== 'object') {\n    return;\n  }\n  for (const key of Object.keys(match)) {\n    if (key === '$where') {\n      throw new MongooseError('Cannot use $where filter with populate() match');\n    }\n    if (match[key] != null && typeof match[key] === 'object') {\n      throwOn$where(match[key]);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}