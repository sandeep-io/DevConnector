{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\nconst StrictModeError = require('../../error/strict');\nconst castNumber = require('../../cast/number');\nconst omitUndefined = require('../omitUndefined');\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n// avoid casting '$add' or '$subtract', because expressions can be either number or date,\n// and we don't have a good way of inferring which arguments should be numbers and which should\n// be dates.\n'$multiply', '$divide', '$log', '$mod', '$trunc', '$avg', '$max', '$min', '$stdDevPop', '$stdDevSamp', '$sum']);\nconst arithmeticOperatorNumber = new Set(['$abs', '$exp', '$ceil', '$floor', '$ln', '$log10', '$sqrt', '$sin', '$cos', '$tan', '$asin', '$acos', '$atan', '$atan2', '$asinh', '$acosh', '$atanh', '$sinh', '$cosh', '$tanh', '$degreesToRadians', '$radiansToDegrees']);\nconst arrayElementOperators = new Set(['$arrayElemAt', '$first', '$last']);\nconst dateOperators = new Set(['$year', '$month', '$week', '$dayOfMonth', '$dayOfYear', '$hour', '$minute', '$second', '$isoDayOfWeek', '$isoWeekYear', '$isoWeek', '$millisecond']);\nconst expressionOperator = new Set(['$not']);\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val === 'boolean') {\n    return val;\n  }\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object or boolean literal');\n  }\n  return _castExpression(val, schema, strictQuery);\n};\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    if (Array.isArray(val.$switch.branches)) {\n      val.$switch.branches = val.$switch.branches.map(v => _castExpression(v, schema, strictQuery));\n    }\n    if ('default' in val.$switch) {\n      val.$switch.default = _castExpression(val.$switch.default, schema, strictQuery);\n    }\n  }\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  if (val.$round) {\n    const $round = val.$round;\n    if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {\n      throw new CastError('Array', $round, '$round');\n    }\n    val.$round = $round.map(v => castNumberOperator(v, schema, strictQuery));\n  }\n  omitUndefined(val);\n  return val;\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n  try {\n    return castNumber(val);\n  } catch {\n    throw new CastError('Number', val);\n  }\n}\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n    return void 0;\n  }\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n  return [schematype.embeddedSchemaType.cast(search), path];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch {\n      throw new CastError('Number', val);\n    }\n  }\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseArray) {\n              schematype = schematype.embeddedSchemaType;\n            }\n          }\n        }\n      }\n    }\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = {\n          $literal: schematype.cast(val[1].$literal)\n        };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = {\n            $literal: caster(val[1].$literal)\n          };\n        } catch {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n  return val;\n}\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://www.mongodb.com/docs/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}","map":{"version":3,"names":["CastError","require","StrictModeError","castNumber","omitUndefined","booleanComparison","Set","comparisonOperator","arithmeticOperatorArray","arithmeticOperatorNumber","arrayElementOperators","dateOperators","expressionOperator","module","exports","cast$expr","val","schema","strictQuery","Error","_castExpression","isPath","$cond","Array","isArray","map","expr","if","then","else","$ifNull","v","$switch","branches","default","keys","Object","key","has","castComparison","castArithmetic","castNumberOperator","$in","castIn","$size","$round","length","isLiteral","path","search","schematype","slice","$isMongooseArray","embeddedSchemaType","cast","lhs","caster","is$literal","$literal","name","replace","find"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/query/cast$expr.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst StrictModeError = require('../../error/strict');\nconst castNumber = require('../../cast/number');\nconst omitUndefined = require('../omitUndefined');\n\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n  // avoid casting '$add' or '$subtract', because expressions can be either number or date,\n  // and we don't have a good way of inferring which arguments should be numbers and which should\n  // be dates.\n  '$multiply',\n  '$divide',\n  '$log',\n  '$mod',\n  '$trunc',\n  '$avg',\n  '$max',\n  '$min',\n  '$stdDevPop',\n  '$stdDevSamp',\n  '$sum'\n]);\nconst arithmeticOperatorNumber = new Set([\n  '$abs',\n  '$exp',\n  '$ceil',\n  '$floor',\n  '$ln',\n  '$log10',\n  '$sqrt',\n  '$sin',\n  '$cos',\n  '$tan',\n  '$asin',\n  '$acos',\n  '$atan',\n  '$atan2',\n  '$asinh',\n  '$acosh',\n  '$atanh',\n  '$sinh',\n  '$cosh',\n  '$tanh',\n  '$degreesToRadians',\n  '$radiansToDegrees'\n]);\nconst arrayElementOperators = new Set([\n  '$arrayElemAt',\n  '$first',\n  '$last'\n]);\nconst dateOperators = new Set([\n  '$year',\n  '$month',\n  '$week',\n  '$dayOfMonth',\n  '$dayOfYear',\n  '$hour',\n  '$minute',\n  '$second',\n  '$isoDayOfWeek',\n  '$isoWeekYear',\n  '$isoWeek',\n  '$millisecond'\n]);\nconst expressionOperator = new Set(['$not']);\n\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val === 'boolean') {\n    return val;\n  }\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object or boolean literal');\n  }\n\n  return _castExpression(val, schema, strictQuery);\n};\n\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    if (Array.isArray(val.$switch.branches)) {\n      val.$switch.branches = val.$switch.branches.map(v => _castExpression(v, schema, strictQuery));\n    }\n    if ('default' in val.$switch) {\n      val.$switch.default = _castExpression(val.$switch.default, schema, strictQuery);\n    }\n  }\n\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  if (val.$round) {\n    const $round = val.$round;\n    if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {\n      throw new CastError('Array', $round, '$round');\n    }\n    val.$round = $round.map(v => castNumberOperator(v, schema, strictQuery));\n  }\n\n  omitUndefined(val);\n\n  return val;\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n\n  try {\n    return castNumber(val);\n  } catch {\n    throw new CastError('Number', val);\n  }\n}\n\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n\n    return void 0;\n  }\n\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n\n  return [\n    schematype.embeddedSchemaType.cast(search),\n    path\n  ];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch {\n      throw new CastError('Number', val);\n    }\n  }\n\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseArray) {\n              schematype = schematype.embeddedSchemaType;\n            }\n          }\n        }\n      }\n    }\n\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = { $literal: schematype.cast(val[1].$literal) };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = { $literal: caster(val[1].$literal) };\n        } catch {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n\n  return val;\n}\n\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\n\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://www.mongodb.com/docs/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}