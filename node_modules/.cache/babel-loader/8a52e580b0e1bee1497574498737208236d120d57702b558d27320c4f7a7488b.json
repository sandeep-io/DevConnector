{"ast":null,"code":"'use strict';\n\nconst mpath = require('mpath');\nconst utils = require('../../utils');\nmodule.exports = applyVirtuals;\n\n/**\n * Apply a given schema's virtuals to a given POJO\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Array<string>} [virtuals] optional whitelist of virtuals to apply\n * @returns\n */\n\nfunction applyVirtuals(schema, obj, virtuals) {\n  if (obj == null) {\n    return obj;\n  }\n  let virtualsForChildren = virtuals;\n  let toApply = null;\n  if (Array.isArray(virtuals)) {\n    virtualsForChildren = [];\n    toApply = [];\n    for (const virtual of virtuals) {\n      if (virtual.length === 1) {\n        toApply.push(virtual[0]);\n      } else {\n        virtualsForChildren.push(virtual);\n      }\n    }\n  }\n  applyVirtualsToChildren(schema, obj, virtualsForChildren);\n  return applyVirtualsToDoc(schema, obj, toApply);\n}\n\n/**\n * Apply virtuals to any subdocuments\n *\n * @param {Schema} schema subdocument schema\n * @param {Object} res subdocument\n * @param {Array<String>} [virtuals] optional whitelist of virtuals to apply\n */\n\nfunction applyVirtualsToChildren(schema, res, virtuals) {\n  let attachedVirtuals = false;\n  for (const childSchema of schema.childSchemas) {\n    const _path = childSchema.model.path;\n    const _schema = childSchema.schema;\n    if (!_path) {\n      continue;\n    }\n    const _obj = mpath.get(_path, res);\n    if (_obj == null || Array.isArray(_obj) && _obj.flat(Infinity).length === 0) {\n      continue;\n    }\n    let virtualsForChild = null;\n    if (Array.isArray(virtuals)) {\n      virtualsForChild = [];\n      for (const virtual of virtuals) {\n        if (virtual[0] == _path) {\n          virtualsForChild.push(virtual.slice(1));\n        }\n      }\n      if (virtualsForChild.length === 0) {\n        continue;\n      }\n    }\n    applyVirtuals(_schema, _obj, virtualsForChild);\n    attachedVirtuals = true;\n  }\n  if (virtuals?.length && !attachedVirtuals) {\n    applyVirtualsToDoc(schema, res, virtuals);\n  }\n}\n\n/**\n * Apply virtuals to a given document. Does not apply virtuals to subdocuments: use `applyVirtualsToChildren` instead\n *\n * @param {Schema} schema\n * @param {Object} doc\n * @param {Array<String>} [virtuals] optional whitelist of virtuals to apply\n * @returns\n */\n\nfunction applyVirtualsToDoc(schema, obj, virtuals) {\n  if (obj == null || typeof obj !== 'object') {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (const el of obj) {\n      applyVirtualsToDoc(schema, el, virtuals);\n    }\n    return;\n  }\n  if (schema.discriminators && utils.hasOwnKeys(schema.discriminators)) {\n    for (const discriminatorKey of Object.keys(schema.discriminators)) {\n      const discriminator = schema.discriminators[discriminatorKey];\n      const key = discriminator.discriminatorMapping.key;\n      const value = discriminator.discriminatorMapping.value;\n      if (obj[key] == value) {\n        schema = discriminator;\n        break;\n      }\n    }\n  }\n  if (virtuals == null) {\n    virtuals = Object.keys(schema.virtuals);\n  }\n  for (const virtual of virtuals) {\n    if (schema.virtuals[virtual] == null) {\n      continue;\n    }\n    const virtualType = schema.virtuals[virtual];\n    const sp = Array.isArray(virtual) ? virtual : virtual.indexOf('.') === -1 ? [virtual] : virtual.split('.');\n    let cur = obj;\n    for (let i = 0; i < sp.length - 1; ++i) {\n      cur[sp[i]] = sp[i] in cur ? cur[sp[i]] : {};\n      cur = cur[sp[i]];\n    }\n    let val = virtualType.applyGetters(cur[sp[sp.length - 1]], obj);\n    const isPopulateVirtual = virtualType.options?.ref || virtualType.options?.refPath;\n    if (isPopulateVirtual && val === undefined) {\n      if (virtualType.options.justOne) {\n        val = null;\n      } else {\n        val = [];\n      }\n    }\n    cur[sp[sp.length - 1]] = val;\n  }\n}","map":{"version":3,"names":["mpath","require","utils","module","exports","applyVirtuals","schema","obj","virtuals","virtualsForChildren","toApply","Array","isArray","virtual","length","push","applyVirtualsToChildren","applyVirtualsToDoc","res","attachedVirtuals","childSchema","childSchemas","_path","model","path","_schema","_obj","get","flat","Infinity","virtualsForChild","slice","el","discriminators","hasOwnKeys","discriminatorKey","Object","keys","discriminator","key","discriminatorMapping","value","virtualType","sp","indexOf","split","cur","i","val","applyGetters","isPopulateVirtual","options","ref","refPath","undefined","justOne"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/document/applyVirtuals.js"],"sourcesContent":["'use strict';\n\nconst mpath = require('mpath');\nconst utils = require('../../utils');\n\nmodule.exports = applyVirtuals;\n\n/**\n * Apply a given schema's virtuals to a given POJO\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Array<string>} [virtuals] optional whitelist of virtuals to apply\n * @returns\n */\n\nfunction applyVirtuals(schema, obj, virtuals) {\n  if (obj == null) {\n    return obj;\n  }\n\n  let virtualsForChildren = virtuals;\n  let toApply = null;\n\n  if (Array.isArray(virtuals)) {\n    virtualsForChildren = [];\n    toApply = [];\n    for (const virtual of virtuals) {\n      if (virtual.length === 1) {\n        toApply.push(virtual[0]);\n      } else {\n        virtualsForChildren.push(virtual);\n      }\n    }\n  }\n\n  applyVirtualsToChildren(schema, obj, virtualsForChildren);\n  return applyVirtualsToDoc(schema, obj, toApply);\n}\n\n/**\n * Apply virtuals to any subdocuments\n *\n * @param {Schema} schema subdocument schema\n * @param {Object} res subdocument\n * @param {Array<String>} [virtuals] optional whitelist of virtuals to apply\n */\n\nfunction applyVirtualsToChildren(schema, res, virtuals) {\n  let attachedVirtuals = false;\n  for (const childSchema of schema.childSchemas) {\n    const _path = childSchema.model.path;\n    const _schema = childSchema.schema;\n    if (!_path) {\n      continue;\n    }\n    const _obj = mpath.get(_path, res);\n    if (_obj == null || (Array.isArray(_obj) && _obj.flat(Infinity).length === 0)) {\n      continue;\n    }\n\n    let virtualsForChild = null;\n    if (Array.isArray(virtuals)) {\n      virtualsForChild = [];\n      for (const virtual of virtuals) {\n        if (virtual[0] == _path) {\n          virtualsForChild.push(virtual.slice(1));\n        }\n      }\n\n      if (virtualsForChild.length === 0) {\n        continue;\n      }\n    }\n\n    applyVirtuals(_schema, _obj, virtualsForChild);\n    attachedVirtuals = true;\n  }\n\n  if (virtuals?.length && !attachedVirtuals) {\n    applyVirtualsToDoc(schema, res, virtuals);\n  }\n}\n\n/**\n * Apply virtuals to a given document. Does not apply virtuals to subdocuments: use `applyVirtualsToChildren` instead\n *\n * @param {Schema} schema\n * @param {Object} doc\n * @param {Array<String>} [virtuals] optional whitelist of virtuals to apply\n * @returns\n */\n\nfunction applyVirtualsToDoc(schema, obj, virtuals) {\n  if (obj == null || typeof obj !== 'object') {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (const el of obj) {\n      applyVirtualsToDoc(schema, el, virtuals);\n    }\n    return;\n  }\n\n  if (schema.discriminators && utils.hasOwnKeys(schema.discriminators)) {\n    for (const discriminatorKey of Object.keys(schema.discriminators)) {\n      const discriminator = schema.discriminators[discriminatorKey];\n      const key = discriminator.discriminatorMapping.key;\n      const value = discriminator.discriminatorMapping.value;\n      if (obj[key] == value) {\n        schema = discriminator;\n        break;\n      }\n    }\n  }\n\n  if (virtuals == null) {\n    virtuals = Object.keys(schema.virtuals);\n  }\n  for (const virtual of virtuals) {\n    if (schema.virtuals[virtual] == null) {\n      continue;\n    }\n    const virtualType = schema.virtuals[virtual];\n    const sp = Array.isArray(virtual)\n      ? virtual\n      : virtual.indexOf('.') === -1\n        ? [virtual]\n        : virtual.split('.');\n    let cur = obj;\n    for (let i = 0; i < sp.length - 1; ++i) {\n      cur[sp[i]] = sp[i] in cur ? cur[sp[i]] : {};\n      cur = cur[sp[i]];\n    }\n    let val = virtualType.applyGetters(cur[sp[sp.length - 1]], obj);\n    const isPopulateVirtual =\n      virtualType.options?.ref || virtualType.options?.refPath;\n    if (isPopulateVirtual && val === undefined) {\n      if (virtualType.options.justOne) {\n        val = null;\n      } else {\n        val = [];\n      }\n    }\n    cur[sp[sp.length - 1]] = val;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}