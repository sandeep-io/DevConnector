{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst EventEmitter = require('events').EventEmitter;\nconst MongooseError = require('../error/mongooseError');\n\n/*!\n * ignore\n */\n\nconst driverChangeStreamEvents = ['close', 'change', 'end', 'error', 'resumeTokenChanged'];\n\n/*!\n * ignore\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(changeStreamThunk, pipeline, options) {\n    super();\n    this.driverChangeStream = null;\n    this.closed = false;\n    this.bindedEvents = false;\n    this.pipeline = pipeline;\n    this.options = options;\n    this.errored = false;\n    if (options?.hydrate && !options.model) {\n      throw new Error('Cannot create change stream with `hydrate: true` ' + 'unless calling `Model.watch()`');\n    }\n    let syncError = null;\n    this.$driverChangeStreamPromise = new Promise((resolve, reject) => {\n      // This wrapper is necessary because of buffering.\n      try {\n        changeStreamThunk((err, driverChangeStream) => {\n          if (err != null) {\n            this.errored = true;\n            this.emit('error', err);\n            return reject(err);\n          }\n          this.driverChangeStream = driverChangeStream;\n          this.emit('ready');\n          resolve();\n        });\n      } catch (err) {\n        syncError = err;\n        this.errored = true;\n        this.emit('error', err);\n        reject(err);\n      }\n    });\n\n    // Because a ChangeStream is an event emitter, there's no way to register an 'error' handler\n    // that catches errors which occur in the constructor, unless we force sync errors into async\n    // errors with setImmediate(). For cleaner stack trace, we just immediately throw any synchronous\n    // errors that occurred with changeStreamThunk().\n    if (syncError != null) {\n      throw syncError;\n    }\n  }\n  _bindEvents() {\n    if (this.bindedEvents) {\n      return;\n    }\n    this.bindedEvents = true;\n    if (this.driverChangeStream == null) {\n      this.$driverChangeStreamPromise.then(() => {\n        this.driverChangeStream.on('close', () => {\n          this.closed = true;\n        });\n        driverChangeStreamEvents.forEach(ev => {\n          this.driverChangeStream.on(ev, data => {\n            if (data?.fullDocument != null && this.options?.hydrate) {\n              data.fullDocument = this.options.model.hydrate(data.fullDocument);\n            }\n            this.emit(ev, data);\n          });\n        });\n      }, () => {} // No need to register events if opening change stream failed\n      );\n      return;\n    }\n    this.driverChangeStream.on('close', () => {\n      this.closed = true;\n    });\n    driverChangeStreamEvents.forEach(ev => {\n      this.driverChangeStream.on(ev, data => {\n        if (data?.fullDocument != null && this.options?.hydrate) {\n          data.fullDocument = this.options.model.hydrate(data.fullDocument);\n        }\n        this.emit(ev, data);\n      });\n    });\n  }\n  hasNext(cb) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call hasNext() on errored ChangeStream');\n    }\n    return this.driverChangeStream.hasNext(cb);\n  }\n  next(cb) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call next() on errored ChangeStream');\n    }\n    if (this.options?.hydrate) {\n      if (cb != null) {\n        const originalCb = cb;\n        cb = (err, data) => {\n          if (err != null) {\n            return originalCb(err);\n          }\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return originalCb(null, data);\n        };\n      }\n      let maybePromise = this.driverChangeStream.next(cb);\n      if (typeof maybePromise?.then === 'function') {\n        maybePromise = maybePromise.then(data => {\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return data;\n        });\n      }\n      return maybePromise;\n    }\n    return this.driverChangeStream.next(cb);\n  }\n  addListener(event, handler) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call addListener() on errored ChangeStream');\n    }\n    this._bindEvents();\n    return super.addListener(event, handler);\n  }\n  on(event, handler) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call on() on errored ChangeStream');\n    }\n    this._bindEvents();\n    return super.on(event, handler);\n  }\n  once(event, handler) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call once() on errored ChangeStream');\n    }\n    this._bindEvents();\n    return super.once(event, handler);\n  }\n  _queue(cb) {\n    this.once('ready', () => cb());\n  }\n  close() {\n    this.closed = true;\n    if (this.driverChangeStream) {\n      return this.driverChangeStream.close();\n    } else {\n      return this.$driverChangeStreamPromise.then(() => this.driverChangeStream.close(), () => {} // No need to close if opening the change stream failed\n      );\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = ChangeStream;","map":{"version":3,"names":["EventEmitter","require","MongooseError","driverChangeStreamEvents","ChangeStream","constructor","changeStreamThunk","pipeline","options","driverChangeStream","closed","bindedEvents","errored","hydrate","model","Error","syncError","$driverChangeStreamPromise","Promise","resolve","reject","err","emit","_bindEvents","then","on","forEach","ev","data","fullDocument","hasNext","cb","next","originalCb","maybePromise","addListener","event","handler","once","_queue","close","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/cursor/changeStream.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst MongooseError = require('../error/mongooseError');\n\n/*!\n * ignore\n */\n\nconst driverChangeStreamEvents = ['close', 'change', 'end', 'error', 'resumeTokenChanged'];\n\n/*!\n * ignore\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(changeStreamThunk, pipeline, options) {\n    super();\n\n    this.driverChangeStream = null;\n    this.closed = false;\n    this.bindedEvents = false;\n    this.pipeline = pipeline;\n    this.options = options;\n    this.errored = false;\n\n    if (options?.hydrate && !options.model) {\n      throw new Error(\n        'Cannot create change stream with `hydrate: true` ' +\n        'unless calling `Model.watch()`'\n      );\n    }\n\n    let syncError = null;\n    this.$driverChangeStreamPromise = new Promise((resolve, reject) => {\n      // This wrapper is necessary because of buffering.\n      try {\n        changeStreamThunk((err, driverChangeStream) => {\n          if (err != null) {\n            this.errored = true;\n            this.emit('error', err);\n            return reject(err);\n          }\n\n          this.driverChangeStream = driverChangeStream;\n          this.emit('ready');\n          resolve();\n        });\n      } catch (err) {\n        syncError = err;\n        this.errored = true;\n        this.emit('error', err);\n        reject(err);\n      }\n    });\n\n    // Because a ChangeStream is an event emitter, there's no way to register an 'error' handler\n    // that catches errors which occur in the constructor, unless we force sync errors into async\n    // errors with setImmediate(). For cleaner stack trace, we just immediately throw any synchronous\n    // errors that occurred with changeStreamThunk().\n    if (syncError != null) {\n      throw syncError;\n    }\n  }\n\n  _bindEvents() {\n    if (this.bindedEvents) {\n      return;\n    }\n\n    this.bindedEvents = true;\n\n    if (this.driverChangeStream == null) {\n      this.$driverChangeStreamPromise.then(\n        () => {\n          this.driverChangeStream.on('close', () => {\n            this.closed = true;\n          });\n\n          driverChangeStreamEvents.forEach(ev => {\n            this.driverChangeStream.on(ev, data => {\n              if (data?.fullDocument != null && this.options?.hydrate) {\n                data.fullDocument = this.options.model.hydrate(data.fullDocument);\n              }\n              this.emit(ev, data);\n            });\n          });\n        },\n        () => {} // No need to register events if opening change stream failed\n      );\n\n      return;\n    }\n\n    this.driverChangeStream.on('close', () => {\n      this.closed = true;\n    });\n\n    driverChangeStreamEvents.forEach(ev => {\n      this.driverChangeStream.on(ev, data => {\n        if (data?.fullDocument != null && this.options?.hydrate) {\n          data.fullDocument = this.options.model.hydrate(data.fullDocument);\n        }\n        this.emit(ev, data);\n      });\n    });\n  }\n\n  hasNext(cb) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call hasNext() on errored ChangeStream');\n    }\n    return this.driverChangeStream.hasNext(cb);\n  }\n\n  next(cb) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call next() on errored ChangeStream');\n    }\n    if (this.options?.hydrate) {\n      if (cb != null) {\n        const originalCb = cb;\n        cb = (err, data) => {\n          if (err != null) {\n            return originalCb(err);\n          }\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return originalCb(null, data);\n        };\n      }\n\n      let maybePromise = this.driverChangeStream.next(cb);\n      if (typeof maybePromise?.then === 'function') {\n        maybePromise = maybePromise.then(data => {\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return data;\n        });\n      }\n      return maybePromise;\n    }\n\n    return this.driverChangeStream.next(cb);\n  }\n\n  addListener(event, handler) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call addListener() on errored ChangeStream');\n    }\n    this._bindEvents();\n    return super.addListener(event, handler);\n  }\n\n  on(event, handler) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call on() on errored ChangeStream');\n    }\n    this._bindEvents();\n    return super.on(event, handler);\n  }\n\n  once(event, handler) {\n    if (this.errored) {\n      throw new MongooseError('Cannot call once() on errored ChangeStream');\n    }\n    this._bindEvents();\n    return super.once(event, handler);\n  }\n\n  _queue(cb) {\n    this.once('ready', () => cb());\n  }\n\n  close() {\n    this.closed = true;\n    if (this.driverChangeStream) {\n      return this.driverChangeStream.close();\n    } else {\n      return this.$driverChangeStreamPromise.then(\n        () => this.driverChangeStream.close(),\n        () => {} // No need to close if opening the change stream failed\n      );\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = ChangeStream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}