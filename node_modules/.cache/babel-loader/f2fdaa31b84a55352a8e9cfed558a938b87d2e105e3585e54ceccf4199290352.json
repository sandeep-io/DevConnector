{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst ChangeStream = require('./cursor/changeStream');\nconst EventEmitter = require('events').EventEmitter;\nconst Schema = require('./schema');\nconst STATES = require('./connectionState');\nconst MongooseBulkWriteError = require('./error/bulkWriteError');\nconst MongooseError = require('./error/index');\nconst ServerSelectionError = require('./error/serverSelection');\nconst SyncIndexesError = require('./error/syncIndexes');\nconst applyPlugins = require('./helpers/schema/applyPlugins');\nconst clone = require('./helpers/clone');\nconst driver = require('./driver');\nconst get = require('./helpers/get');\nconst getDefaultBulkwriteResult = require('./helpers/getDefaultBulkwriteResult');\nconst immediate = require('./helpers/immediate');\nconst utils = require('./utils');\nconst CreateCollectionsError = require('./error/createCollectionsError');\nconst castBulkWrite = require('./helpers/model/castBulkWrite');\nconst {\n  modelSymbol\n} = require('./helpers/symbols');\nconst isPromise = require('./helpers/isPromise');\nconst decorateBulkWriteResult = require('./helpers/model/decorateBulkWriteResult');\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst sessionNewDocuments = require('./helpers/symbols').sessionNewDocuments;\n\n// Snapshot the native Date constructor to ensure both Date.now() and new Date() (and other Date methods)\n// bypass timer mocks such as those set up by useFakeTimers().\nconst Date = globalThis.Date;\n\n/**\n * A list of authentication mechanisms that don't require a password for authentication.\n * This is used by the authMechanismDoesNotRequirePassword method.\n *\n * @api private\n */\nconst noPasswordAuthMechanisms = ['MONGODB-X509'];\n\n/**\n * Connection constructor\n *\n * For practical reasons, a Connection equals a Db.\n *\n * @param {Mongoose} base a mongoose instance\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `connecting`: Emitted when `connection.openUri()` is executed on this connection.\n * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.\n * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connection's models.\n * @event `disconnecting`: Emitted when `connection.close()` was executed.\n * @event `disconnected`: Emitted after getting disconnected from the db.\n * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connection's models.\n * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successful connection.\n * @event `error`: Emitted when an error occurs on this connection.\n * @event `operation-start`: Emitted when a call to the MongoDB Node.js driver, like a `find()` or `insertOne()`, happens on any collection tied to this connection.\n * @event `operation-end`: Emitted when a call to the MongoDB Node.js driver, like a `find()` or `insertOne()`, either succeeds or errors.\n * @api public\n */\n\nfunction Connection(base) {\n  this.base = base;\n  this.collections = {};\n  this.models = {};\n  this.config = {};\n  this.replica = false;\n  this.options = null;\n  this.otherDbs = []; // FIXME: To be replaced with relatedDbs\n  this.relatedDbs = {}; // Hashmap of other dbs that share underlying connection\n  this.states = STATES;\n  this._readyState = STATES.disconnected;\n  this._closeCalled = false;\n  this._hasOpened = false;\n  this.plugins = [];\n  if (typeof base === 'undefined' || !base.connections.length) {\n    this.id = 0;\n  } else {\n    this.id = base.nextConnectionId;\n  }\n\n  // Internal queue of objects `{ fn, ctx, args }` that Mongoose calls when this connection is successfully\n  // opened. In `onOpen()`, Mongoose calls every entry in `_queue` and empties the queue.\n  this._queue = [];\n}\n\n/*!\n * Inherit from EventEmitter\n */\n\nObject.setPrototypeOf(Connection.prototype, EventEmitter.prototype);\n\n/**\n * Connection ready state\n *\n * - 0 = disconnected\n * - 1 = connected\n * - 2 = connecting\n * - 3 = disconnecting\n *\n * Each state change emits its associated event name.\n *\n * #### Example:\n *\n *     conn.on('connected', callback);\n *     conn.on('disconnected', callback);\n *\n * @property readyState\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'readyState', {\n  get: function () {\n    // If connection thinks it is connected, but we haven't received a heartbeat in 2 heartbeat intervals,\n    // that likely means the connection is stale (potentially due to frozen AWS Lambda container)\n    if (this._readyState === STATES.connected && this._lastHeartbeatAt != null &&\n    // LoadBalanced topology (behind haproxy, including Atlas serverless instances) don't use heartbeats,\n    // so we can't use this check in that case.\n    this.client?.topology?.s?.description?.type !== 'LoadBalanced' && typeof this.client?.topology?.s?.description?.heartbeatFrequencyMS === 'number' && Date.now() - this._lastHeartbeatAt >= this.client.topology.s.description.heartbeatFrequencyMS * 2) {\n      return STATES.disconnected;\n    }\n    return this._readyState;\n  },\n  set: function (val) {\n    if (!(val in STATES)) {\n      throw new Error('Invalid connection state: ' + val);\n    }\n    if (this._readyState !== val) {\n      this._readyState = val;\n      // [legacy] loop over the otherDbs on this connection and change their state\n      for (const db of this.otherDbs) {\n        db.readyState = val;\n      }\n      if (STATES.connected === val) {\n        this._hasOpened = true;\n      }\n      this.emit(STATES[val]);\n    }\n  }\n});\n\n/**\n * Gets the value of the option `key`. Equivalent to `conn.options[key]`\n *\n * #### Example:\n *\n *     conn.get('test'); // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nConnection.prototype.get = function getOption(key) {\n  if (Object.hasOwn(this.config, key)) {\n    return this.config[key];\n  }\n  return get(this.options, key);\n};\n\n/**\n * Sets the value of the option `key`. Equivalent to `conn.options[key] = val`\n *\n * Supported options include:\n *\n * - `maxTimeMS`: Set [`maxTimeMS`](https://mongoosejs.com/docs/api/query.html#Query.prototype.maxTimeMS()) for all queries on this connection.\n * - 'debug': If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arugments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n *\n * #### Example:\n *\n *     conn.set('test', 'foo');\n *     conn.get('test'); // 'foo'\n *     conn.options.test; // 'foo'\n *\n * @param {String} key\n * @param {Any} val\n * @method set\n * @api public\n */\n\nConnection.prototype.set = function setOption(key, val) {\n  if (Object.hasOwn(this.config, key)) {\n    this.config[key] = val;\n    return val;\n  }\n  this.options = this.options || {};\n  this.options[key] = val;\n  return val;\n};\n\n/**\n * A hash of the collections associated with this connection\n *\n * @property collections\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.collections;\n\n/**\n * The name of the database this connection points to.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').name; // \"mydb\"\n *\n * @property name\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.name;\n\n/**\n * A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing\n * a map from model names to models. Contains all models that have been\n * added to this connection using [`Connection#model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()).\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection();\n *     const Test = conn.model('Test', mongoose.Schema({ name: String }));\n *\n *     Object.keys(conn.models).length; // 1\n *     conn.models.Test === Test; // true\n *\n * @property models\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.models;\n\n/**\n * A number identifier for this connection. Used for debugging when\n * you have [multiple connections](https://mongoosejs.com/docs/connections.html#multiple_connections).\n *\n * #### Example:\n *\n *     // The default connection has `id = 0`\n *     mongoose.connection.id; // 0\n *\n *     // If you create a new connection, Mongoose increments id\n *     const conn = mongoose.createConnection();\n *     conn.id; // 1\n *\n * @property id\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.id;\n\n/**\n * The plugins that will be applied to all models created on this connection.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @property plugins\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'plugins', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The host name portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the first host name in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').host; // \"127.0.0.1\"\n *\n * @property host\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'host', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The port portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the port from the first host name in the URI.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').port; // 27017\n *\n * @property port\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'port', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The username specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').user; // \"val\"\n *\n * @property user\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'user', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The password specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').pass; // \"psw\"\n *\n * @property pass\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'pass', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The mongodb.Db instance, set when the connection is opened\n *\n * @property db\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.db;\n\n/**\n * The MongoClient instance this connection uses to talk to MongoDB. Mongoose automatically sets this property\n * when the connection is opened.\n *\n * @property client\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.client;\n\n/**\n * A hash of the global options that are associated with this connection\n *\n * @property config\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.config;\n\n/**\n * Helper for `createCollection()`. Will explicitly create the given collection\n * with specified options. Used to create [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections/)\n * and [views](https://www.mongodb.com/docs/manual/core/views/) from mongoose.\n *\n * Options are passed down without modification to the [MongoDB driver's `createCollection()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n *\n * @method createCollection\n * @param {string} collection The collection to create\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.createCollection = async function createCollection(collection, options) {\n  if (typeof options === 'function' || arguments.length >= 3 && typeof arguments[2] === 'function') {\n    throw new MongooseError('Connection.prototype.createCollection() no longer accepts a callback');\n  }\n  await this._waitForConnect();\n  return this.db.createCollection(collection, options);\n};\n\n/**\n * _Requires MongoDB Server 8.0 or greater_. Executes bulk write operations across multiple models in a single operation.\n * You must specify the `model` for each operation: Mongoose will use `model` for casting and validation, as well as\n * determining which collection to apply the operation to.\n *\n * #### Example:\n *     const Test = mongoose.model('Test', new Schema({ name: String }));\n *\n *     await db.bulkWrite([\n *       { model: Test, name: 'insertOne', document: { name: 'test1' } }, // Can specify model as a Model class...\n *       { model: 'Test', name: 'insertOne', document: { name: 'test2' } } // or as a model name\n *     ], { ordered: false });\n *\n * @method bulkWrite\n * @param {Array} ops\n * @param {Object} [options]\n * @param {Boolean} [options.ordered] If false, perform unordered operations. If true, perform ordered operations.\n * @param {Session} [options.session] The session to use for the operation.\n * @return {Promise}\n * @see MongoDB https://www.mongodb.com/docs/manual/reference/command/bulkWrite/#mongodb-dbcommand-dbcmd.bulkWrite\n * @api public\n */\n\nConnection.prototype.bulkWrite = async function bulkWrite(ops, options) {\n  await this._waitForConnect();\n  options = options || {};\n  const ordered = options.ordered == null ? true : options.ordered;\n  const asyncLocalStorage = this.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !Object.hasOwn(options, 'session')) && asyncLocalStorage?.session != null) {\n    options = {\n      ...options,\n      session: asyncLocalStorage.session\n    };\n  }\n  const now = this.base.now();\n  let res = null;\n  if (ordered) {\n    const opsToSend = [];\n    for (const op of ops) {\n      if (typeof op.model !== 'string' && !op.model?.[modelSymbol]) {\n        throw new MongooseError('Must specify model in Connection.prototype.bulkWrite() operations');\n      }\n      const Model = op.model[modelSymbol] ? op.model : this.model(op.model);\n      if (op.name == null) {\n        throw new MongooseError('Must specify operation name in Connection.prototype.bulkWrite()');\n      }\n      if (!Object.hasOwn(castBulkWrite.cast, op.name)) {\n        throw new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);\n      }\n      await castBulkWrite.cast[op.name](Model, op, options, now);\n      opsToSend.push({\n        ...op,\n        namespace: Model.namespace()\n      });\n    }\n    res = await this.client.bulkWrite(opsToSend, options);\n  } else {\n    const validOps = [];\n    const validOpIndexes = [];\n    let validationErrors = [];\n    const asyncValidations = [];\n    const results = [];\n    for (let i = 0; i < ops.length; ++i) {\n      const op = ops[i];\n      if (typeof op.model !== 'string' && !op.model?.[modelSymbol]) {\n        const error = new MongooseError('Must specify model in Connection.prototype.bulkWrite() operations');\n        validationErrors.push({\n          index: i,\n          error: error\n        });\n        results[i] = error;\n        continue;\n      }\n      let Model;\n      try {\n        Model = op.model[modelSymbol] ? op.model : this.model(op.model);\n      } catch (error) {\n        validationErrors.push({\n          index: i,\n          error: error\n        });\n        continue;\n      }\n      if (op.name == null) {\n        const error = new MongooseError('Must specify operation name in Connection.prototype.bulkWrite()');\n        validationErrors.push({\n          index: i,\n          error: error\n        });\n        results[i] = error;\n        continue;\n      }\n      if (!Object.hasOwn(castBulkWrite.cast, op.name)) {\n        const error = new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);\n        validationErrors.push({\n          index: i,\n          error: error\n        });\n        results[i] = error;\n        continue;\n      }\n      let maybePromise = null;\n      try {\n        maybePromise = castBulkWrite.cast[op.name](Model, op, options, now);\n      } catch (error) {\n        validationErrors.push({\n          index: i,\n          error: error\n        });\n        results[i] = error;\n        continue;\n      }\n      if (isPromise(maybePromise)) {\n        asyncValidations.push(maybePromise.then(() => {\n          validOps.push({\n            ...op,\n            namespace: Model.namespace()\n          });\n          validOpIndexes.push(i);\n        }, error => {\n          validationErrors.push({\n            index: i,\n            error: error\n          });\n          results[i] = error;\n        }));\n      } else {\n        validOps.push({\n          ...op,\n          namespace: Model.namespace()\n        });\n        validOpIndexes.push(i);\n      }\n    }\n    if (asyncValidations.length > 0) {\n      await Promise.all(asyncValidations);\n    }\n    validationErrors = validationErrors.sort((v1, v2) => v1.index - v2.index).map(v => v.error);\n    if (validOps.length === 0) {\n      if (options.throwOnValidationError && validationErrors.length) {\n        throw new MongooseBulkWriteError(validationErrors, results, res, 'bulkWrite');\n      }\n      const BulkWriteResult = this.base.driver.get().BulkWriteResult;\n      const res = new BulkWriteResult(getDefaultBulkwriteResult(), false);\n      return decorateBulkWriteResult(res, validationErrors, results);\n    }\n    let error;\n    [res, error] = await this.client.bulkWrite(validOps, options).then(res => [res, null]).catch(err => [null, err]);\n    for (let i = 0; i < validOpIndexes.length; ++i) {\n      results[validOpIndexes[i]] = null;\n    }\n    if (error) {\n      if (validationErrors.length > 0) {\n        decorateBulkWriteResult(error, validationErrors, results);\n        error.mongoose = error.mongoose || {};\n        error.mongoose.validationErrors = validationErrors;\n      }\n    }\n    if (validationErrors.length > 0) {\n      if (options.throwOnValidationError) {\n        throw new MongooseBulkWriteError(validationErrors, results, res, 'bulkWrite');\n      } else {\n        decorateBulkWriteResult(res, validationErrors, results);\n      }\n    }\n  }\n  return res;\n};\n\n/**\n * Calls `createCollection()` on a models in a series.\n *\n * @method createCollections\n * @param {Boolean} continueOnError When true, will continue to create collections and create a new error class for the collections that errored.\n * @returns {Promise}\n * @api public\n */\n\nConnection.prototype.createCollections = async function createCollections(options = {}) {\n  const result = {};\n  const errorsMap = {};\n  const {\n    continueOnError\n  } = options;\n  delete options.continueOnError;\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.createCollection({});\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n  if (!continueOnError && utils.hasOwnKeys(errorsMap)) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const createCollectionsError = new CreateCollectionsError(message, errorsMap);\n    throw createCollectionsError;\n  }\n  return result;\n};\n\n/**\n * A convenience wrapper for `connection.client.withSession()`.\n *\n * #### Example:\n *\n *     await conn.withSession(async session => {\n *       const doc = await TestModel.findOne().session(session);\n *     });\n *\n * @method withSession\n * @param {Function} executor called with 1 argument: a `ClientSession` instance\n * @return {Promise} resolves to the return value of the executor function\n * @api public\n */\n\nConnection.prototype.withSession = async function withSession(executor) {\n  if (arguments.length === 0) {\n    throw new Error('Please provide an executor function');\n  }\n  return await this.client.withSession(executor);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * #### Example:\n *\n *     const session = await conn.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.deleteOne();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n *\n * @method startSession\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nConnection.prototype.startSession = async function startSession(options) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.startSession() no longer accepts a callback');\n  }\n  await this._waitForConnect();\n  const session = this.client.startSession(options);\n  return session;\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Executes the wrapped async function\n * in a transaction. Mongoose will commit the transaction if the\n * async function executes successfully and attempt to retry if\n * there was a retriable error.\n *\n * Calls the MongoDB driver's [`session.withTransaction()`](https://mongodb.github.io/node-mongodb-native/4.9/classes/ClientSession.html#withTransaction),\n * but also handles resetting Mongoose document state as shown below.\n *\n * #### Example:\n *\n *     const doc = new Person({ name: 'Will Riker' });\n *     await db.transaction(async function setRank(session) {\n *       doc.rank = 'Captain';\n *       await doc.save({ session });\n *       doc.isNew; // false\n *\n *       // Throw an error to abort the transaction\n *       throw new Error('Oops!');\n *     },{ readPreference: 'primary' }).catch(() => {});\n *\n *     // true, `transaction()` reset the document's state because the\n *     // transaction was aborted.\n *     doc.isNew;\n *\n * @method transaction\n * @param {Function} fn Function to execute in a transaction\n * @param {mongodb.TransactionOptions} [options] Optional settings for the transaction\n * @return {Promise<Any>} promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.\n * @api public\n */\n\nConnection.prototype.transaction = function transaction(fn, options) {\n  return this.startSession().then(session => {\n    session[sessionNewDocuments] = new Map();\n    return session.withTransaction(() => _wrapUserTransaction(fn, session, this.base), options).then(res => {\n      delete session[sessionNewDocuments];\n      return res;\n    }).catch(err => {\n      delete session[sessionNewDocuments];\n      throw err;\n    }).finally(() => {\n      session.endSession().catch(() => {});\n    });\n  });\n};\n\n/*!\n * Reset document state in between transaction retries re: gh-13698\n */\n\nasync function _wrapUserTransaction(fn, session, mongoose) {\n  try {\n    const res = mongoose.transactionAsyncLocalStorage == null ? await fn(session) : await new Promise(resolve => {\n      mongoose.transactionAsyncLocalStorage.run({\n        session\n      }, () => resolve(fn(session)));\n    });\n    return res;\n  } catch (err) {\n    _resetSessionDocuments(session);\n    throw err;\n  }\n}\n\n/*!\n * If transaction was aborted, we need to reset newly inserted documents' `isNew`.\n */\nfunction _resetSessionDocuments(session) {\n  for (const doc of session[sessionNewDocuments].keys()) {\n    const state = session[sessionNewDocuments].get(doc);\n    if (Object.hasOwn(state, 'isNew')) {\n      doc.$isNew = state.isNew;\n    }\n    if (Object.hasOwn(state, 'versionKey')) {\n      doc.set(doc.schema.options.versionKey, state.versionKey);\n    }\n    if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {\n      doc.$__.activePaths.states.modify = {};\n    }\n    for (const path of state.modifiedPaths) {\n      const currentState = doc.$__.activePaths.paths[path];\n      if (currentState != null) {\n        delete doc.$__.activePaths[currentState][path];\n      }\n      doc.$__.activePaths.paths[path] = 'modify';\n      doc.$__.activePaths.states.modify[path] = true;\n    }\n    for (const path of state.atomics.keys()) {\n      const val = doc.$__getValue(path);\n      if (val == null) {\n        continue;\n      }\n      val[arrayAtomicsSymbol] = state.atomics.get(path);\n    }\n  }\n}\n\n/**\n * Helper for `dropCollection()`. Will delete the given collection, including\n * all documents and indexes.\n *\n * @method dropCollection\n * @param {string} collection The collection to delete\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropCollection = async function dropCollection(collection) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.dropCollection() no longer accepts a callback');\n  }\n  await this._waitForConnect();\n  return this.db.dropCollection(collection);\n};\n\n/**\n * Waits for connection to be established, so the connection has a `client`\n *\n * @param {Boolean} [noTimeout=false] if set, don't put a timeout on the operation. Used internally so `mongoose.model()` doesn't leave open handles.\n * @return Promise\n * @api private\n */\n\nConnection.prototype._waitForConnect = async function _waitForConnect(noTimeout) {\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    const bufferTimeoutMS = this._getBufferTimeoutMS();\n    let timeout = null;\n    let timedOut = false;\n    // The element that this function pushes onto `_queue`, stored to make it easy to remove later\n    const queueElement = {};\n\n    // Mongoose executes all elements in `_queue` when initial connection succeeds in `onOpen()`.\n    const waitForConnectPromise = new Promise(resolve => {\n      queueElement.fn = resolve;\n      this._queue.push(queueElement);\n    });\n    if (noTimeout) {\n      await waitForConnectPromise;\n    } else {\n      await Promise.race([waitForConnectPromise, new Promise(resolve => {\n        timeout = setTimeout(() => {\n          timedOut = true;\n          resolve();\n        }, bufferTimeoutMS);\n      })]);\n    }\n    if (timedOut) {\n      const index = this._queue.indexOf(queueElement);\n      if (index !== -1) {\n        this._queue.splice(index, 1);\n      }\n      const message = 'Connection operation buffering timed out after ' + bufferTimeoutMS + 'ms';\n      throw new MongooseError(message);\n    } else if (timeout != null) {\n      // Not strictly necessary, but avoid the extra overhead of creating a new MongooseError\n      // in case of success\n      clearTimeout(timeout);\n    }\n  }\n};\n\n/*!\n * Get the default buffer timeout for this connection\n */\n\nConnection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {\n  if (this.config.bufferTimeoutMS != null) {\n    return this.config.bufferTimeoutMS;\n  }\n  if (this.base?.get('bufferTimeoutMS') != null) {\n    return this.base.get('bufferTimeoutMS');\n  }\n  return 10000;\n};\n\n/**\n * Helper for MongoDB Node driver's `listCollections()`.\n * Returns an array of collection objects.\n *\n * @method listCollections\n * @return {Promise<Collection[]>}\n * @api public\n */\n\nConnection.prototype.listCollections = async function listCollections() {\n  await this._waitForConnect();\n  const cursor = this.db.listCollections();\n  return await cursor.toArray();\n};\n\n/**\n * Helper for MongoDB Node driver's `listDatabases()`.\n * Returns an object with a `databases` property that contains an\n * array of database objects.\n *\n * #### Example:\n *     const { databases } = await mongoose.connection.listDatabases();\n *     databases; // [{ name: 'mongoose_test', sizeOnDisk: 0, empty: false }]\n *\n * @method listCollections\n * @return {Promise<{ databases: Array<{ name: string }> }>}\n * @api public\n */\n\nConnection.prototype.listDatabases = async function listDatabases() {\n  // Implemented in `lib/drivers/node-mongodb-native/connection.js`\n  throw new MongooseError('listDatabases() not implemented by driver');\n};\n\n/**\n * Helper for `dropDatabase()`. Deletes the given database, including all\n * collections, documents, and indexes.\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     // Deletes the entire 'mydb' database\n *     await conn.dropDatabase();\n *\n * @method dropDatabase\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropDatabase = async function dropDatabase() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Connection.prototype.dropDatabase() no longer accepts a callback');\n  }\n  await this._waitForConnect();\n\n  // If `dropDatabase()` is called, this model's collection will not be\n  // init-ed. It is sufficiently common to call `dropDatabase()` after\n  // `mongoose.connect()` but before creating models that we want to\n  // support this. See gh-6796\n  for (const model of Object.values(this.models)) {\n    delete model.$init;\n  }\n  return this.db.dropDatabase();\n};\n\n/*!\n * ignore\n */\n\nConnection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  if (this.config.bufferCommands != null) {\n    return this.config.bufferCommands;\n  }\n  if (this.base.get('bufferCommands') != null) {\n    return this.base.get('bufferCommands');\n  }\n  return true;\n};\n\n/**\n * error\n *\n * Graceful error handling, passes error to callback\n * if available, else emits error on the connection.\n *\n * @param {Error} err\n * @param {Function} callback optional\n * @emits \"error\" Emits the `error` event with the given `err`, unless a callback is specified\n * @returns {Promise|null} Returns a rejected Promise if no `callback` is given.\n * @api private\n */\n\nConnection.prototype.error = function error(err, callback) {\n  if (callback) {\n    callback(err);\n    return null;\n  }\n  if (this.listeners('error').length > 0) {\n    this.emit('error', err);\n  }\n  return Promise.reject(err);\n};\n\n/**\n * Called when the connection is opened\n *\n * @emits \"open\"\n * @api private\n */\n\nConnection.prototype.onOpen = function () {\n  this.readyState = STATES.connected;\n  for (const d of this._queue) {\n    d.fn.apply(d.ctx, d.args);\n  }\n  this._queue = [];\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (Object.hasOwn(this.collections, i)) {\n      this.collections[i].onOpen();\n    }\n  }\n  this.emit('open');\n};\n\n/**\n * Opens the connection with a URI using `MongoClient.connect()`.\n *\n * @param {String} uri The URI to connect with.\n * @param {Object} [options] Passed on to [`MongoClient.connect`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#connect-1)\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.username`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @returns {Promise<Connection>}\n * @api public\n */\n\nConnection.prototype.openUri = async function openUri(uri, options) {\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString === uri) {\n      return this;\n    }\n  }\n  this._closeCalled = false;\n\n  // Internal option to skip `await this.$initialConnection` in\n  // this function for `createConnection()`. Because otherwise\n  // `createConnection()` would have an uncatchable error.\n  let _fireAndForget = false;\n  if (options && '_fireAndForget' in options) {\n    _fireAndForget = options._fireAndForget;\n    delete options._fireAndForget;\n  }\n  try {\n    _validateArgs.apply(arguments);\n  } catch (err) {\n    if (_fireAndForget) {\n      throw err;\n    }\n    this.$initialConnection = Promise.reject(err);\n    throw err;\n  }\n  this.$initialConnection = this.createClient(uri, options).then(() => this).catch(err => {\n    this.readyState = STATES.disconnected;\n    if (this.listeners('error').length > 0) {\n      immediate(() => this.emit('error', err));\n    }\n    throw err;\n  });\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  // `createConnection()` calls this `openUri()` function without\n  // awaiting on the result, so we set this option to rely on\n  // `asPromise()` to handle any errors.\n  if (_fireAndForget) {\n    return this;\n  }\n  try {\n    await this.$initialConnection;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n  return this;\n};\n\n/**\n * Listen to events in the Connection\n *\n * @param {String} event The event to listen on\n * @param {Function} callback\n * @see Connection#readyState https://mongoosejs.com/docs/api/connection.html#Connection.prototype.readyState\n *\n * @method on\n * @instance\n * @memberOf Connection\n * @api public\n */\n\n// Treat `on('error')` handlers as handling the initialConnection promise\n// to avoid uncaught exceptions when using `on('error')`. See gh-14377.\nConnection.prototype.on = function on(event, callback) {\n  if (event === 'error' && this.$initialConnection) {\n    this.$initialConnection.catch(() => {});\n  }\n  return EventEmitter.prototype.on.call(this, event, callback);\n};\n\n/**\n * Listen to a event once in the Connection\n *\n * @param {String} event The event to listen on\n * @param {Function} callback\n * @see Connection#readyState https://mongoosejs.com/docs/api/connection.html#Connection.prototype.readyState\n *\n * @method once\n * @instance\n * @memberOf Connection\n * @api public\n */\n\n// Treat `on('error')` handlers as handling the initialConnection promise\n// to avoid uncaught exceptions when using `on('error')`. See gh-14377.\nConnection.prototype.once = function on(event, callback) {\n  if (event === 'error' && this.$initialConnection) {\n    this.$initialConnection.catch(() => {});\n  }\n  return EventEmitter.prototype.once.call(this, event, callback);\n};\n\n/*!\n * ignore\n */\n\nfunction _validateArgs(uri, options, callback) {\n  if (typeof options === 'function' && callback == null) {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  } else if (typeof callback === 'function') {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _handleConnectionErrors(err) {\n  if (err?.name === 'MongoServerSelectionError') {\n    const originalError = err;\n    err = new ServerSelectionError();\n    err.assimilateError(originalError);\n  }\n  return err;\n}\n\n/**\n * Destroy the connection. Similar to [`.close`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.close()),\n * but also removes the connection from Mongoose's `connections` list and prevents the\n * connection from ever being re-opened.\n *\n * @param {Boolean} [force]\n * @returns {Promise}\n */\n\nConnection.prototype.destroy = async function destroy(force) {\n  if (typeof force === 'function' || arguments.length === 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.destroy() no longer accepts a callback');\n  }\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n  return this._close(force, true);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force] optional\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.close = async function close(force) {\n  if (typeof force === 'function' || arguments.length === 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.close() no longer accepts a callback');\n  }\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n  if (this._lastHeartbeatAt != null) {\n    this._lastHeartbeatAt = null;\n  }\n  for (const model of Object.values(this.models)) {\n    // If manually disconnecting, make sure to clear each model's `$init`\n    // promise, so Mongoose knows to re-run `init()` in case the\n    // connection is re-opened. See gh-12047.\n    delete model.$init;\n  }\n  return this._close(force, false);\n};\n\n/**\n * Handles closing the connection\n *\n * @param {Boolean} force\n * @param {Boolean} destroy\n * @returns {Connection} this\n * @api private\n */\nConnection.prototype._close = async function _close(force, destroy) {\n  const _this = this;\n  const closeCalled = this._closeCalled;\n  this._closeCalled = true;\n  this._destroyCalled = destroy;\n  if (this.client != null) {\n    this.client._closeCalled = true;\n    this.client._destroyCalled = destroy;\n  }\n  const conn = this;\n  switch (this.readyState) {\n    case STATES.disconnected:\n      if (destroy) {\n        const index = this.base.connections.indexOf(conn);\n        if (index !== -1) {\n          this.base.connections.splice(index, 1);\n        }\n      }\n      if (!closeCalled) {\n        await this.doClose(force);\n        this.onClose(force);\n      }\n      break;\n    case STATES.connected:\n      this.readyState = STATES.disconnecting;\n      await this.doClose(force);\n      if (destroy) {\n        const index = _this.base.connections.indexOf(conn);\n        if (index !== -1) {\n          this.base.connections.splice(index, 1);\n        }\n      }\n      this.onClose(force);\n      break;\n    case STATES.connecting:\n      return new Promise((resolve, reject) => {\n        const _rerunClose = () => {\n          this.removeListener('open', _rerunClose);\n          this.removeListener('error', _rerunClose);\n          if (destroy) {\n            this.destroy(force).then(resolve, reject);\n          } else {\n            this.close(force).then(resolve, reject);\n          }\n        };\n        this.once('open', _rerunClose);\n        this.once('error', _rerunClose);\n      });\n    case STATES.disconnecting:\n      return new Promise(resolve => {\n        this.once('close', () => {\n          if (destroy && this.base.connections.indexOf(conn) !== -1) {\n            this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n          }\n          resolve();\n        });\n      });\n  }\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n *\n * @api private\n */\n\nConnection.prototype.doClose = function doClose() {\n  throw new Error('Connection#doClose unimplemented by driver');\n};\n\n/**\n * Called when the connection closes\n *\n * @emits \"close\"\n * @api private\n */\n\nConnection.prototype.onClose = function onClose(force) {\n  this.readyState = STATES.disconnected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (Object.hasOwn(this.collections, i)) {\n      this.collections[i].onClose(force);\n    }\n  }\n  this.emit('close', force);\n  const wasForceClosed = typeof force === 'object' && force !== null ? force.force : force;\n  for (const db of this.otherDbs) {\n    this._destroyCalled ? db.destroy({\n      force: wasForceClosed,\n      skipCloseClient: true\n    }) : db.close({\n      force: wasForceClosed,\n      skipCloseClient: true\n    });\n  }\n};\n\n/**\n * Retrieves a raw collection instance, creating it if not cached.\n * This method returns a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using a Collection bypasses Mongoose middleware, validation, and casting,\n * letting you use [MongoDB Node.js driver](https://mongodb.github.io/node-mongodb-native/) functionality directly.\n *\n * @param {String} name of the collection\n * @param {Object} [options] optional collection options\n * @return {Collection} collection instance\n * @api public\n */\n\nConnection.prototype.collection = function (name, options) {\n  const defaultOptions = {\n    autoIndex: this.config.autoIndex ?? this.base.options.autoIndex,\n    autoCreate: this.config.autoCreate ?? this.base.options.autoCreate,\n    autoSearchIndex: this.config.autoSearchIndex ?? this.base.options.autoSearchIndex\n  };\n  options = Object.assign({}, defaultOptions, options ? clone(options) : {});\n  options.$wasForceClosed = this.$wasForceClosed;\n  const Collection = this.base?.__driver?.Collection || driver.get().Collection;\n  if (!(name in this.collections)) {\n    this.collections[name] = new Collection(name, this, options);\n  }\n  return this.collections[name];\n};\n\n/**\n * Declares a plugin executed on all schemas you pass to `conn.model()`\n *\n * Equivalent to calling `.plugin(fn)` on each schema you create.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Connection} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nConnection.prototype.plugin = function (fn, opts) {\n  this.plugins.push([fn, opts]);\n  return this;\n};\n\n/**\n * Defines or retrieves a model.\n *\n *     const mongoose = require('mongoose');\n *     const db = mongoose.createConnection(..);\n *     db.model('Venue', new Schema(..));\n *     const Ticket = db.model('Ticket', new Schema(..));\n *     const Venue = db.model('Venue');\n *\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the `utils.toCollectionName` method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor'\n *     const M = conn.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name the model name or class extending Model\n * @param {Schema} [schema] a schema. necessary when defining a model\n * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name\n * @param {Object} [options]\n * @param {Boolean} [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid `OverwriteModelError`\n * @see Mongoose#model https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()\n * @return {Model} The compiled model\n * @api public\n */\n\nConnection.prototype.model = function model(name, schema, collection, options) {\n  if (!(this instanceof Connection)) {\n    throw new MongooseError('`connection.model()` should not be run with ' + '`new`. If you are doing `new db.model(foo)(bar)`, use ' + '`db.model(foo)(bar)` instead');\n  }\n  let fn;\n  if (typeof name === 'function') {\n    fn = name;\n    name = fn.name;\n  }\n\n  // collection name discovery\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n  if (utils.isObject(schema)) {\n    if (!schema.instanceOfSchema) {\n      schema = new Schema(schema);\n    } else if (!(schema instanceof this.base.Schema)) {\n      schema = schema._clone(this.base.Schema);\n    }\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' + 'schema or a POJO');\n  }\n  const defaultOptions = {\n    cache: false,\n    overwriteModels: this.base.options.overwriteModels\n  };\n  const opts = Object.assign(defaultOptions, options, {\n    connection: this\n  });\n  if (this.models[name] && !collection && opts.overwriteModels !== true) {\n    // model exists but we are not subclassing with custom collection\n    if (schema?.instanceOfSchema && schema !== this.models[name].schema) {\n      throw new MongooseError.OverwriteModelError(name);\n    }\n    return this.models[name];\n  }\n  let model;\n  if (schema?.instanceOfSchema) {\n    applyPlugins(schema, this.plugins, null, '$connectionPluginsApplied');\n\n    // compile a model\n    model = this.base._model(fn || name, schema, collection, opts);\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n    return model;\n  }\n  if (this.models[name] && collection) {\n    // subclassing current model with alternate collection\n    model = this.models[name];\n    schema = model.prototype.schema;\n    const sub = model.__subclass(this, schema, collection);\n    // do not cache the sub model\n    return sub;\n  }\n  if (arguments.length === 1) {\n    model = this.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n  if (!model) {\n    throw new MongooseError.MissingSchemaError(name);\n  }\n  if (this === model.prototype.db && (!collection || collection === model.collection.name)) {\n    // model already uses this connection.\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n    return model;\n  }\n  this.models[name] = model.__subclass(this, schema, collection);\n  return this.models[name];\n};\n\n/**\n * Removes the model named `name` from this connection, if it exists. You can\n * use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * #### Example:\n *\n *     conn.model('User', new Schema({ name: String }));\n *     console.log(conn.model('User')); // Model object\n *     conn.deleteModel('User');\n *     console.log(conn.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       conn.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Connection} this\n */\n\nConnection.prototype.deleteModel = function deleteModel(name) {\n  if (typeof name === 'string') {\n    const model = this.model(name);\n    if (model == null) {\n      return this;\n    }\n    const collectionName = model.collection.name;\n    delete this.models[name];\n    delete this.collections[collectionName];\n    this.emit('deleteModel', model);\n  } else if (name instanceof RegExp) {\n    const pattern = name;\n    const names = this.modelNames();\n    for (const name of names) {\n      if (pattern.test(name)) {\n        this.deleteModel(name);\n      }\n    }\n  } else {\n    throw new Error('First parameter to `deleteModel()` must be a string ' + 'or regexp, got \"' + name + '\"');\n  }\n  return this;\n};\n\n/**\n * Watches the entire underlying database for changes. Similar to\n * [`Model.watch()`](https://mongoosejs.com/docs/api/model.html#Model.watch()).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const User = conn.model('User', new Schema({ name: String }));\n *\n *     const changeStream = conn.watch().on('change', data => console.log(data));\n *\n *     // Triggers a 'change' event on the change stream.\n *     await User.create({ name: 'test' });\n *\n * @api public\n * @param {Array} [pipeline]\n * @param {Object} [options] passed without changes to [the MongoDB driver's `Db#watch()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#watch)\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n */\n\nConnection.prototype.watch = function watch(pipeline, options) {\n  const changeStreamThunk = cb => {\n    immediate(() => {\n      if (this.readyState === STATES.connecting) {\n        this.once('open', function () {\n          const driverChangeStream = this.db.watch(pipeline, options);\n          cb(null, driverChangeStream);\n        });\n      } else {\n        const driverChangeStream = this.db.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      }\n    });\n  };\n  const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);\n  return changeStream;\n};\n\n/**\n * Returns a promise that resolves when this connection\n * successfully connects to MongoDB, or rejects if this connection failed\n * to connect.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *     conn.readyState; // 1, means Mongoose is connected\n *\n * @api public\n * @return {Promise}\n */\n\nConnection.prototype.asPromise = async function asPromise() {\n  try {\n    await this.$initialConnection;\n    return this;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n};\n\n/**\n * Returns an array of model names created on this connection.\n * @api public\n * @return {String[]}\n */\n\nConnection.prototype.modelNames = function modelNames() {\n  return Object.keys(this.models);\n};\n\n/**\n * Returns if the connection requires authentication after it is opened. Generally if a\n * username and password are both provided than authentication is needed, but in some cases a\n * password is not required.\n *\n * @api private\n * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.\n */\nConnection.prototype.shouldAuthenticate = function shouldAuthenticate() {\n  return this.user != null && (this.pass != null || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns a boolean value that specifies if the current authentication mechanism needs a\n * password to authenticate according to the auth objects passed into the openUri methods.\n *\n * @api private\n * @return {Boolean} true if the authentication mechanism specified in the options object requires\n *  a password, otherwise false.\n */\nConnection.prototype.authMechanismDoesNotRequirePassword = function authMechanismDoesNotRequirePassword() {\n  if (this.options?.auth) {\n    return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;\n  }\n  return true;\n};\n\n/**\n * Returns a boolean value that specifies if the provided objects object provides enough\n * data to authenticate with. Generally this is true if the username and password are both specified\n * but in some authentication methods, a password is not required for authentication so only a username\n * is required.\n *\n * @param {Object} [options] the options object passed into the openUri methods.\n * @api private\n * @return {Boolean} true if the provided options object provides enough data to authenticate with,\n *   otherwise false.\n */\nConnection.prototype.optionsProvideAuthenticationData = function optionsProvideAuthenticationData(options) {\n  return options && options.user && (options.pass || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *\n *     conn.getClient(); // MongoClient { ... }\n *\n * @api public\n * @return {MongoClient}\n */\n\nConnection.prototype.getClient = function getClient() {\n  return this.client;\n};\n\n/**\n * Set the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to\n * reuse it.\n *\n * #### Example:\n *\n *     const client = await mongodb.MongoClient.connect('mongodb://127.0.0.1:27017/test');\n *\n *     const conn = mongoose.createConnection().setClient(client);\n *\n *     conn.getClient(); // MongoClient { ... }\n *     conn.readyState; // 1, means 'CONNECTED'\n *\n * @api public\n * @param {MongClient} client The Client to set to be used.\n * @return {Connection} this\n */\n\nConnection.prototype.setClient = function setClient() {\n  throw new MongooseError('Connection#setClient not implemented by driver');\n};\n\n/*!\n * Called internally by `openUri()` to create a MongoClient instance.\n */\n\nConnection.prototype.createClient = function createClient() {\n  throw new MongooseError('Connection#createClient not implemented by driver');\n};\n\n/**\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.continueOnError] `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise<Object>} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nConnection.prototype.syncIndexes = async function syncIndexes(options = {}) {\n  const result = {};\n  const errorsMap = {};\n  const {\n    continueOnError\n  } = options;\n  delete options.continueOnError;\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.syncIndexes(options);\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n  if (!continueOnError && utils.hasOwnKeys(errorsMap)) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const syncIndexesError = new SyncIndexesError(message, errorsMap);\n    throw syncIndexesError;\n  }\n  return result;\n};\n\n/**\n * Switches to a different database using the same [connection pool](https://mongoosejs.com/docs/connections.html#connection_pools).\n *\n * Returns a new connection object, with the new db.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *     // Creates a cached connection to `mydb2`. All calls to `conn.useDb('mydb2', { useCache: true })` will return the same\n *     // connection instance as opposed to creating a new connection instance\n *     const db2 = conn.useDb('mydb2', { useCache: true });\n *\n * @method useDb\n * @memberOf Connection\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @return {Connection} New Connection Object\n * @api public\n */\n\n/**\n * Runs a [db-level aggregate()](https://www.mongodb.com/docs/manual/reference/method/db.aggregate/) on this connection's underlying `db`\n *\n * @method aggregate\n * @memberOf Connection\n * @param {Array} pipeline\n * @param {Object} [options]\n * @param {Boolean} [options.cursor=false] If true, make the Aggregate resolve to a Mongoose AggregationCursor rather than an array\n * @return {Aggregate} Aggregation wrapper\n * @api public\n */\n\n/**\n * Removes the database connection with the given name created with with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n * @api public\n */\n\n/*!\n * Module exports.\n */\n\nConnection.STATES = STATES;\nmodule.exports = Connection;","map":{"version":3,"names":["ChangeStream","require","EventEmitter","Schema","STATES","MongooseBulkWriteError","MongooseError","ServerSelectionError","SyncIndexesError","applyPlugins","clone","driver","get","getDefaultBulkwriteResult","immediate","utils","CreateCollectionsError","castBulkWrite","modelSymbol","isPromise","decorateBulkWriteResult","arrayAtomicsSymbol","sessionNewDocuments","Date","globalThis","noPasswordAuthMechanisms","Connection","base","collections","models","config","replica","options","otherDbs","relatedDbs","states","_readyState","disconnected","_closeCalled","_hasOpened","plugins","connections","length","id","nextConnectionId","_queue","Object","setPrototypeOf","prototype","defineProperty","connected","_lastHeartbeatAt","client","topology","s","description","type","heartbeatFrequencyMS","now","set","val","Error","db","readyState","emit","getOption","key","hasOwn","setOption","name","configurable","enumerable","writable","createCollection","collection","arguments","_waitForConnect","bulkWrite","ops","ordered","asyncLocalStorage","transactionAsyncLocalStorage","getStore","session","res","opsToSend","op","model","Model","cast","push","namespace","validOps","validOpIndexes","validationErrors","asyncValidations","results","i","error","index","maybePromise","then","Promise","all","sort","v1","v2","map","v","throwOnValidationError","BulkWriteResult","catch","err","mongoose","createCollections","result","errorsMap","continueOnError","values","modelName","hasOwnKeys","message","entries","join","createCollectionsError","withSession","executor","startSession","transaction","fn","Map","withTransaction","_wrapUserTransaction","finally","endSession","resolve","run","_resetSessionDocuments","doc","keys","state","$isNew","isNew","schema","versionKey","modifiedPaths","$__","activePaths","modify","path","currentState","paths","atomics","$__getValue","dropCollection","noTimeout","connecting","_shouldBufferCommands","bufferTimeoutMS","_getBufferTimeoutMS","timeout","timedOut","queueElement","waitForConnectPromise","race","setTimeout","indexOf","splice","clearTimeout","listCollections","cursor","toArray","listDatabases","dropDatabase","$init","bufferCommands","callback","listeners","reject","onOpen","d","apply","ctx","args","openUri","uri","_connectionString","_fireAndForget","_validateArgs","$initialConnection","createClient","init","$modelInitNoop","_handleConnectionErrors","on","event","call","once","originalError","assimilateError","destroy","force","$wasForceClosed","_close","close","_this","closeCalled","_destroyCalled","conn","doClose","onClose","disconnecting","_rerunClose","removeListener","wasForceClosed","skipCloseClient","defaultOptions","autoIndex","autoCreate","autoSearchIndex","assign","Collection","__driver","plugin","opts","isObject","instanceOfSchema","_clone","cache","overwriteModels","connection","OverwriteModelError","_model","sub","__subclass","MissingSchemaError","deleteModel","collectionName","RegExp","pattern","names","modelNames","test","watch","pipeline","changeStreamThunk","cb","driverChangeStream","changeStream","asPromise","shouldAuthenticate","user","pass","authMechanismDoesNotRequirePassword","auth","authMechanism","optionsProvideAuthenticationData","getClient","setClient","syncIndexes","syncIndexesError","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/connection.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ChangeStream = require('./cursor/changeStream');\nconst EventEmitter = require('events').EventEmitter;\nconst Schema = require('./schema');\nconst STATES = require('./connectionState');\nconst MongooseBulkWriteError = require('./error/bulkWriteError');\nconst MongooseError = require('./error/index');\nconst ServerSelectionError = require('./error/serverSelection');\nconst SyncIndexesError = require('./error/syncIndexes');\nconst applyPlugins = require('./helpers/schema/applyPlugins');\nconst clone = require('./helpers/clone');\nconst driver = require('./driver');\nconst get = require('./helpers/get');\nconst getDefaultBulkwriteResult = require('./helpers/getDefaultBulkwriteResult');\nconst immediate = require('./helpers/immediate');\nconst utils = require('./utils');\nconst CreateCollectionsError = require('./error/createCollectionsError');\nconst castBulkWrite = require('./helpers/model/castBulkWrite');\nconst { modelSymbol } = require('./helpers/symbols');\nconst isPromise = require('./helpers/isPromise');\nconst decorateBulkWriteResult = require('./helpers/model/decorateBulkWriteResult');\n\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst sessionNewDocuments = require('./helpers/symbols').sessionNewDocuments;\n\n// Snapshot the native Date constructor to ensure both Date.now() and new Date() (and other Date methods)\n// bypass timer mocks such as those set up by useFakeTimers().\nconst Date = globalThis.Date;\n\n/**\n * A list of authentication mechanisms that don't require a password for authentication.\n * This is used by the authMechanismDoesNotRequirePassword method.\n *\n * @api private\n */\nconst noPasswordAuthMechanisms = [\n  'MONGODB-X509'\n];\n\n/**\n * Connection constructor\n *\n * For practical reasons, a Connection equals a Db.\n *\n * @param {Mongoose} base a mongoose instance\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `connecting`: Emitted when `connection.openUri()` is executed on this connection.\n * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.\n * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connection's models.\n * @event `disconnecting`: Emitted when `connection.close()` was executed.\n * @event `disconnected`: Emitted after getting disconnected from the db.\n * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connection's models.\n * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successful connection.\n * @event `error`: Emitted when an error occurs on this connection.\n * @event `operation-start`: Emitted when a call to the MongoDB Node.js driver, like a `find()` or `insertOne()`, happens on any collection tied to this connection.\n * @event `operation-end`: Emitted when a call to the MongoDB Node.js driver, like a `find()` or `insertOne()`, either succeeds or errors.\n * @api public\n */\n\nfunction Connection(base) {\n  this.base = base;\n  this.collections = {};\n  this.models = {};\n  this.config = {};\n  this.replica = false;\n  this.options = null;\n  this.otherDbs = []; // FIXME: To be replaced with relatedDbs\n  this.relatedDbs = {}; // Hashmap of other dbs that share underlying connection\n  this.states = STATES;\n  this._readyState = STATES.disconnected;\n  this._closeCalled = false;\n  this._hasOpened = false;\n  this.plugins = [];\n  if (typeof base === 'undefined' || !base.connections.length) {\n    this.id = 0;\n  } else {\n    this.id = base.nextConnectionId;\n  }\n\n  // Internal queue of objects `{ fn, ctx, args }` that Mongoose calls when this connection is successfully\n  // opened. In `onOpen()`, Mongoose calls every entry in `_queue` and empties the queue.\n  this._queue = [];\n}\n\n/*!\n * Inherit from EventEmitter\n */\n\nObject.setPrototypeOf(Connection.prototype, EventEmitter.prototype);\n\n/**\n * Connection ready state\n *\n * - 0 = disconnected\n * - 1 = connected\n * - 2 = connecting\n * - 3 = disconnecting\n *\n * Each state change emits its associated event name.\n *\n * #### Example:\n *\n *     conn.on('connected', callback);\n *     conn.on('disconnected', callback);\n *\n * @property readyState\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'readyState', {\n  get: function() {\n    // If connection thinks it is connected, but we haven't received a heartbeat in 2 heartbeat intervals,\n    // that likely means the connection is stale (potentially due to frozen AWS Lambda container)\n    if (\n      this._readyState === STATES.connected &&\n      this._lastHeartbeatAt != null &&\n      // LoadBalanced topology (behind haproxy, including Atlas serverless instances) don't use heartbeats,\n      // so we can't use this check in that case.\n      this.client?.topology?.s?.description?.type !== 'LoadBalanced' &&\n      typeof this.client?.topology?.s?.description?.heartbeatFrequencyMS === 'number' &&\n      Date.now() - this._lastHeartbeatAt >= this.client.topology.s.description.heartbeatFrequencyMS * 2) {\n      return STATES.disconnected;\n    }\n    return this._readyState;\n  },\n  set: function(val) {\n    if (!(val in STATES)) {\n      throw new Error('Invalid connection state: ' + val);\n    }\n\n    if (this._readyState !== val) {\n      this._readyState = val;\n      // [legacy] loop over the otherDbs on this connection and change their state\n      for (const db of this.otherDbs) {\n        db.readyState = val;\n      }\n\n      if (STATES.connected === val) {\n        this._hasOpened = true;\n      }\n\n      this.emit(STATES[val]);\n    }\n  }\n});\n\n/**\n * Gets the value of the option `key`. Equivalent to `conn.options[key]`\n *\n * #### Example:\n *\n *     conn.get('test'); // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nConnection.prototype.get = function getOption(key) {\n  if (Object.hasOwn(this.config, key)) {\n    return this.config[key];\n  }\n\n  return get(this.options, key);\n};\n\n/**\n * Sets the value of the option `key`. Equivalent to `conn.options[key] = val`\n *\n * Supported options include:\n *\n * - `maxTimeMS`: Set [`maxTimeMS`](https://mongoosejs.com/docs/api/query.html#Query.prototype.maxTimeMS()) for all queries on this connection.\n * - 'debug': If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arugments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n *\n * #### Example:\n *\n *     conn.set('test', 'foo');\n *     conn.get('test'); // 'foo'\n *     conn.options.test; // 'foo'\n *\n * @param {String} key\n * @param {Any} val\n * @method set\n * @api public\n */\n\nConnection.prototype.set = function setOption(key, val) {\n  if (Object.hasOwn(this.config, key)) {\n    this.config[key] = val;\n    return val;\n  }\n\n  this.options = this.options || {};\n  this.options[key] = val;\n  return val;\n};\n\n/**\n * A hash of the collections associated with this connection\n *\n * @property collections\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.collections;\n\n/**\n * The name of the database this connection points to.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').name; // \"mydb\"\n *\n * @property name\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.name;\n\n/**\n * A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing\n * a map from model names to models. Contains all models that have been\n * added to this connection using [`Connection#model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()).\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection();\n *     const Test = conn.model('Test', mongoose.Schema({ name: String }));\n *\n *     Object.keys(conn.models).length; // 1\n *     conn.models.Test === Test; // true\n *\n * @property models\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.models;\n\n/**\n * A number identifier for this connection. Used for debugging when\n * you have [multiple connections](https://mongoosejs.com/docs/connections.html#multiple_connections).\n *\n * #### Example:\n *\n *     // The default connection has `id = 0`\n *     mongoose.connection.id; // 0\n *\n *     // If you create a new connection, Mongoose increments id\n *     const conn = mongoose.createConnection();\n *     conn.id; // 1\n *\n * @property id\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.id;\n\n/**\n * The plugins that will be applied to all models created on this connection.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @property plugins\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'plugins', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The host name portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the first host name in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').host; // \"127.0.0.1\"\n *\n * @property host\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'host', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The port portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the port from the first host name in the URI.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').port; // 27017\n *\n * @property port\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'port', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The username specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').user; // \"val\"\n *\n * @property user\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'user', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The password specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').pass; // \"psw\"\n *\n * @property pass\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'pass', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The mongodb.Db instance, set when the connection is opened\n *\n * @property db\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.db;\n\n/**\n * The MongoClient instance this connection uses to talk to MongoDB. Mongoose automatically sets this property\n * when the connection is opened.\n *\n * @property client\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.client;\n\n/**\n * A hash of the global options that are associated with this connection\n *\n * @property config\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.config;\n\n/**\n * Helper for `createCollection()`. Will explicitly create the given collection\n * with specified options. Used to create [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections/)\n * and [views](https://www.mongodb.com/docs/manual/core/views/) from mongoose.\n *\n * Options are passed down without modification to the [MongoDB driver's `createCollection()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n *\n * @method createCollection\n * @param {string} collection The collection to create\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.createCollection = async function createCollection(collection, options) {\n  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {\n    throw new MongooseError('Connection.prototype.createCollection() no longer accepts a callback');\n  }\n\n  await this._waitForConnect();\n\n  return this.db.createCollection(collection, options);\n};\n\n/**\n * _Requires MongoDB Server 8.0 or greater_. Executes bulk write operations across multiple models in a single operation.\n * You must specify the `model` for each operation: Mongoose will use `model` for casting and validation, as well as\n * determining which collection to apply the operation to.\n *\n * #### Example:\n *     const Test = mongoose.model('Test', new Schema({ name: String }));\n *\n *     await db.bulkWrite([\n *       { model: Test, name: 'insertOne', document: { name: 'test1' } }, // Can specify model as a Model class...\n *       { model: 'Test', name: 'insertOne', document: { name: 'test2' } } // or as a model name\n *     ], { ordered: false });\n *\n * @method bulkWrite\n * @param {Array} ops\n * @param {Object} [options]\n * @param {Boolean} [options.ordered] If false, perform unordered operations. If true, perform ordered operations.\n * @param {Session} [options.session] The session to use for the operation.\n * @return {Promise}\n * @see MongoDB https://www.mongodb.com/docs/manual/reference/command/bulkWrite/#mongodb-dbcommand-dbcmd.bulkWrite\n * @api public\n */\n\n\nConnection.prototype.bulkWrite = async function bulkWrite(ops, options) {\n  await this._waitForConnect();\n  options = options || {};\n\n  const ordered = options.ordered == null ? true : options.ordered;\n  const asyncLocalStorage = this.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !Object.hasOwn(options, 'session')) && asyncLocalStorage?.session != null) {\n    options = { ...options, session: asyncLocalStorage.session };\n  }\n\n  const now = this.base.now();\n\n  let res = null;\n  if (ordered) {\n    const opsToSend = [];\n    for (const op of ops) {\n      if (typeof op.model !== 'string' && !op.model?.[modelSymbol]) {\n        throw new MongooseError('Must specify model in Connection.prototype.bulkWrite() operations');\n      }\n      const Model = op.model[modelSymbol] ? op.model : this.model(op.model);\n\n      if (op.name == null) {\n        throw new MongooseError('Must specify operation name in Connection.prototype.bulkWrite()');\n      }\n      if (!Object.hasOwn(castBulkWrite.cast, op.name)) {\n        throw new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);\n      }\n\n      await castBulkWrite.cast[op.name](Model, op, options, now);\n      opsToSend.push({ ...op, namespace: Model.namespace() });\n    }\n\n    res = await this.client.bulkWrite(opsToSend, options);\n  } else {\n    const validOps = [];\n    const validOpIndexes = [];\n    let validationErrors = [];\n    const asyncValidations = [];\n    const results = [];\n    for (let i = 0; i < ops.length; ++i) {\n      const op = ops[i];\n      if (typeof op.model !== 'string' && !op.model?.[modelSymbol]) {\n        const error = new MongooseError('Must specify model in Connection.prototype.bulkWrite() operations');\n        validationErrors.push({ index: i, error: error });\n        results[i] = error;\n        continue;\n      }\n      let Model;\n      try {\n        Model = op.model[modelSymbol] ? op.model : this.model(op.model);\n      } catch (error) {\n        validationErrors.push({ index: i, error: error });\n        continue;\n      }\n      if (op.name == null) {\n        const error = new MongooseError('Must specify operation name in Connection.prototype.bulkWrite()');\n        validationErrors.push({ index: i, error: error });\n        results[i] = error;\n        continue;\n      }\n      if (!Object.hasOwn(castBulkWrite.cast, op.name)) {\n        const error = new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);\n        validationErrors.push({ index: i, error: error });\n        results[i] = error;\n        continue;\n      }\n\n      let maybePromise = null;\n      try {\n        maybePromise = castBulkWrite.cast[op.name](Model, op, options, now);\n      } catch (error) {\n        validationErrors.push({ index: i, error: error });\n        results[i] = error;\n        continue;\n      }\n      if (isPromise(maybePromise)) {\n        asyncValidations.push(\n          maybePromise.then(\n            () => {\n              validOps.push({ ...op, namespace: Model.namespace() });\n              validOpIndexes.push(i);\n            },\n            error => {\n              validationErrors.push({ index: i, error: error });\n              results[i] = error;\n            }\n          )\n        );\n      } else {\n        validOps.push({ ...op, namespace: Model.namespace() });\n        validOpIndexes.push(i);\n      }\n    }\n\n    if (asyncValidations.length > 0) {\n      await Promise.all(asyncValidations);\n    }\n\n    validationErrors = validationErrors.\n      sort((v1, v2) => v1.index - v2.index).\n      map(v => v.error);\n\n    if (validOps.length === 0) {\n      if (options.throwOnValidationError && validationErrors.length) {\n        throw new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          res,\n          'bulkWrite'\n        );\n      }\n      const BulkWriteResult = this.base.driver.get().BulkWriteResult;\n      const res = new BulkWriteResult(getDefaultBulkwriteResult(), false);\n      return decorateBulkWriteResult(res, validationErrors, results);\n    }\n\n    let error;\n    [res, error] = await this.client.bulkWrite(validOps, options).\n      then(res => ([res, null])).\n      catch(err => ([null, err]));\n\n    for (let i = 0; i < validOpIndexes.length; ++i) {\n      results[validOpIndexes[i]] = null;\n    }\n    if (error) {\n      if (validationErrors.length > 0) {\n        decorateBulkWriteResult(error, validationErrors, results);\n        error.mongoose = error.mongoose || {};\n        error.mongoose.validationErrors = validationErrors;\n      }\n    }\n\n    if (validationErrors.length > 0) {\n      if (options.throwOnValidationError) {\n        throw new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          res,\n          'bulkWrite'\n        );\n      } else {\n        decorateBulkWriteResult(res, validationErrors, results);\n      }\n    }\n  }\n\n  return res;\n};\n\n/**\n * Calls `createCollection()` on a models in a series.\n *\n * @method createCollections\n * @param {Boolean} continueOnError When true, will continue to create collections and create a new error class for the collections that errored.\n * @returns {Promise}\n * @api public\n */\n\nConnection.prototype.createCollections = async function createCollections(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.createCollection({});\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && utils.hasOwnKeys(errorsMap)) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const createCollectionsError = new CreateCollectionsError(message, errorsMap);\n    throw createCollectionsError;\n  }\n  return result;\n};\n\n/**\n * A convenience wrapper for `connection.client.withSession()`.\n *\n * #### Example:\n *\n *     await conn.withSession(async session => {\n *       const doc = await TestModel.findOne().session(session);\n *     });\n *\n * @method withSession\n * @param {Function} executor called with 1 argument: a `ClientSession` instance\n * @return {Promise} resolves to the return value of the executor function\n * @api public\n */\n\nConnection.prototype.withSession = async function withSession(executor) {\n  if (arguments.length === 0) {\n    throw new Error('Please provide an executor function');\n  }\n  return await this.client.withSession(executor);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * #### Example:\n *\n *     const session = await conn.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.deleteOne();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n *\n * @method startSession\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nConnection.prototype.startSession = async function startSession(options) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.startSession() no longer accepts a callback');\n  }\n\n  await this._waitForConnect();\n\n  const session = this.client.startSession(options);\n  return session;\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Executes the wrapped async function\n * in a transaction. Mongoose will commit the transaction if the\n * async function executes successfully and attempt to retry if\n * there was a retriable error.\n *\n * Calls the MongoDB driver's [`session.withTransaction()`](https://mongodb.github.io/node-mongodb-native/4.9/classes/ClientSession.html#withTransaction),\n * but also handles resetting Mongoose document state as shown below.\n *\n * #### Example:\n *\n *     const doc = new Person({ name: 'Will Riker' });\n *     await db.transaction(async function setRank(session) {\n *       doc.rank = 'Captain';\n *       await doc.save({ session });\n *       doc.isNew; // false\n *\n *       // Throw an error to abort the transaction\n *       throw new Error('Oops!');\n *     },{ readPreference: 'primary' }).catch(() => {});\n *\n *     // true, `transaction()` reset the document's state because the\n *     // transaction was aborted.\n *     doc.isNew;\n *\n * @method transaction\n * @param {Function} fn Function to execute in a transaction\n * @param {mongodb.TransactionOptions} [options] Optional settings for the transaction\n * @return {Promise<Any>} promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.\n * @api public\n */\n\nConnection.prototype.transaction = function transaction(fn, options) {\n  return this.startSession().then(session => {\n    session[sessionNewDocuments] = new Map();\n    return session.withTransaction(() => _wrapUserTransaction(fn, session, this.base), options).\n      then(res => {\n        delete session[sessionNewDocuments];\n        return res;\n      }).\n      catch(err => {\n        delete session[sessionNewDocuments];\n        throw err;\n      }).\n      finally(() => {\n        session.endSession().catch(() => {});\n      });\n  });\n};\n\n/*!\n * Reset document state in between transaction retries re: gh-13698\n */\n\nasync function _wrapUserTransaction(fn, session, mongoose) {\n  try {\n    const res = mongoose.transactionAsyncLocalStorage == null\n      ? await fn(session)\n      : await new Promise(resolve => {\n        mongoose.transactionAsyncLocalStorage.run(\n          { session },\n          () => resolve(fn(session))\n        );\n      });\n    return res;\n  } catch (err) {\n    _resetSessionDocuments(session);\n    throw err;\n  }\n}\n\n/*!\n * If transaction was aborted, we need to reset newly inserted documents' `isNew`.\n */\nfunction _resetSessionDocuments(session) {\n  for (const doc of session[sessionNewDocuments].keys()) {\n    const state = session[sessionNewDocuments].get(doc);\n    if (Object.hasOwn(state, 'isNew')) {\n      doc.$isNew = state.isNew;\n    }\n    if (Object.hasOwn(state, 'versionKey')) {\n      doc.set(doc.schema.options.versionKey, state.versionKey);\n    }\n\n    if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {\n      doc.$__.activePaths.states.modify = {};\n    }\n    for (const path of state.modifiedPaths) {\n      const currentState = doc.$__.activePaths.paths[path];\n      if (currentState != null) {\n        delete doc.$__.activePaths[currentState][path];\n      }\n      doc.$__.activePaths.paths[path] = 'modify';\n      doc.$__.activePaths.states.modify[path] = true;\n    }\n\n    for (const path of state.atomics.keys()) {\n      const val = doc.$__getValue(path);\n      if (val == null) {\n        continue;\n      }\n      val[arrayAtomicsSymbol] = state.atomics.get(path);\n    }\n  }\n}\n\n/**\n * Helper for `dropCollection()`. Will delete the given collection, including\n * all documents and indexes.\n *\n * @method dropCollection\n * @param {string} collection The collection to delete\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropCollection = async function dropCollection(collection) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.dropCollection() no longer accepts a callback');\n  }\n\n  await this._waitForConnect();\n\n  return this.db.dropCollection(collection);\n};\n\n/**\n * Waits for connection to be established, so the connection has a `client`\n *\n * @param {Boolean} [noTimeout=false] if set, don't put a timeout on the operation. Used internally so `mongoose.model()` doesn't leave open handles.\n * @return Promise\n * @api private\n */\n\nConnection.prototype._waitForConnect = async function _waitForConnect(noTimeout) {\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    const bufferTimeoutMS = this._getBufferTimeoutMS();\n    let timeout = null;\n    let timedOut = false;\n    // The element that this function pushes onto `_queue`, stored to make it easy to remove later\n    const queueElement = {};\n\n    // Mongoose executes all elements in `_queue` when initial connection succeeds in `onOpen()`.\n    const waitForConnectPromise = new Promise(resolve => {\n      queueElement.fn = resolve;\n      this._queue.push(queueElement);\n    });\n\n    if (noTimeout) {\n      await waitForConnectPromise;\n    } else {\n      await Promise.race([\n        waitForConnectPromise,\n        new Promise(resolve => {\n          timeout = setTimeout(\n            () => {\n              timedOut = true;\n              resolve();\n            },\n            bufferTimeoutMS\n          );\n        })\n      ]);\n    }\n\n    if (timedOut) {\n      const index = this._queue.indexOf(queueElement);\n      if (index !== -1) {\n        this._queue.splice(index, 1);\n      }\n      const message = 'Connection operation buffering timed out after ' + bufferTimeoutMS + 'ms';\n      throw new MongooseError(message);\n    } else if (timeout != null) {\n      // Not strictly necessary, but avoid the extra overhead of creating a new MongooseError\n      // in case of success\n      clearTimeout(timeout);\n    }\n  }\n};\n\n/*!\n * Get the default buffer timeout for this connection\n */\n\nConnection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {\n  if (this.config.bufferTimeoutMS != null) {\n    return this.config.bufferTimeoutMS;\n  }\n  if (this.base?.get('bufferTimeoutMS') != null) {\n    return this.base.get('bufferTimeoutMS');\n  }\n  return 10000;\n};\n\n/**\n * Helper for MongoDB Node driver's `listCollections()`.\n * Returns an array of collection objects.\n *\n * @method listCollections\n * @return {Promise<Collection[]>}\n * @api public\n */\n\nConnection.prototype.listCollections = async function listCollections() {\n  await this._waitForConnect();\n\n  const cursor = this.db.listCollections();\n  return await cursor.toArray();\n};\n\n/**\n * Helper for MongoDB Node driver's `listDatabases()`.\n * Returns an object with a `databases` property that contains an\n * array of database objects.\n *\n * #### Example:\n *     const { databases } = await mongoose.connection.listDatabases();\n *     databases; // [{ name: 'mongoose_test', sizeOnDisk: 0, empty: false }]\n *\n * @method listCollections\n * @return {Promise<{ databases: Array<{ name: string }> }>}\n * @api public\n */\n\nConnection.prototype.listDatabases = async function listDatabases() {\n  // Implemented in `lib/drivers/node-mongodb-native/connection.js`\n  throw new MongooseError('listDatabases() not implemented by driver');\n};\n\n/**\n * Helper for `dropDatabase()`. Deletes the given database, including all\n * collections, documents, and indexes.\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     // Deletes the entire 'mydb' database\n *     await conn.dropDatabase();\n *\n * @method dropDatabase\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropDatabase = async function dropDatabase() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Connection.prototype.dropDatabase() no longer accepts a callback');\n  }\n\n  await this._waitForConnect();\n\n  // If `dropDatabase()` is called, this model's collection will not be\n  // init-ed. It is sufficiently common to call `dropDatabase()` after\n  // `mongoose.connect()` but before creating models that we want to\n  // support this. See gh-6796\n  for (const model of Object.values(this.models)) {\n    delete model.$init;\n  }\n\n  return this.db.dropDatabase();\n};\n\n/*!\n * ignore\n */\n\nConnection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  if (this.config.bufferCommands != null) {\n    return this.config.bufferCommands;\n  }\n  if (this.base.get('bufferCommands') != null) {\n    return this.base.get('bufferCommands');\n  }\n  return true;\n};\n\n/**\n * error\n *\n * Graceful error handling, passes error to callback\n * if available, else emits error on the connection.\n *\n * @param {Error} err\n * @param {Function} callback optional\n * @emits \"error\" Emits the `error` event with the given `err`, unless a callback is specified\n * @returns {Promise|null} Returns a rejected Promise if no `callback` is given.\n * @api private\n */\n\nConnection.prototype.error = function error(err, callback) {\n  if (callback) {\n    callback(err);\n    return null;\n  }\n  if (this.listeners('error').length > 0) {\n    this.emit('error', err);\n  }\n  return Promise.reject(err);\n};\n\n/**\n * Called when the connection is opened\n *\n * @emits \"open\"\n * @api private\n */\n\nConnection.prototype.onOpen = function() {\n  this.readyState = STATES.connected;\n\n  for (const d of this._queue) {\n    d.fn.apply(d.ctx, d.args);\n  }\n  this._queue = [];\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (Object.hasOwn(this.collections, i)) {\n      this.collections[i].onOpen();\n    }\n  }\n\n  this.emit('open');\n};\n\n/**\n * Opens the connection with a URI using `MongoClient.connect()`.\n *\n * @param {String} uri The URI to connect with.\n * @param {Object} [options] Passed on to [`MongoClient.connect`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#connect-1)\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.username`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @returns {Promise<Connection>}\n * @api public\n */\n\nConnection.prototype.openUri = async function openUri(uri, options) {\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString === uri) {\n      return this;\n    }\n  }\n\n  this._closeCalled = false;\n\n  // Internal option to skip `await this.$initialConnection` in\n  // this function for `createConnection()`. Because otherwise\n  // `createConnection()` would have an uncatchable error.\n  let _fireAndForget = false;\n  if (options && '_fireAndForget' in options) {\n    _fireAndForget = options._fireAndForget;\n    delete options._fireAndForget;\n  }\n\n  try {\n    _validateArgs.apply(arguments);\n  } catch (err) {\n    if (_fireAndForget) {\n      throw err;\n    }\n    this.$initialConnection = Promise.reject(err);\n    throw err;\n  }\n\n  this.$initialConnection = this.createClient(uri, options).\n    then(() => this).\n    catch(err => {\n      this.readyState = STATES.disconnected;\n      if (this.listeners('error').length > 0) {\n        immediate(() => this.emit('error', err));\n      }\n      throw err;\n    });\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  // `createConnection()` calls this `openUri()` function without\n  // awaiting on the result, so we set this option to rely on\n  // `asPromise()` to handle any errors.\n  if (_fireAndForget) {\n    return this;\n  }\n\n  try {\n    await this.$initialConnection;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n\n  return this;\n};\n\n/**\n * Listen to events in the Connection\n *\n * @param {String} event The event to listen on\n * @param {Function} callback\n * @see Connection#readyState https://mongoosejs.com/docs/api/connection.html#Connection.prototype.readyState\n *\n * @method on\n * @instance\n * @memberOf Connection\n * @api public\n */\n\n// Treat `on('error')` handlers as handling the initialConnection promise\n// to avoid uncaught exceptions when using `on('error')`. See gh-14377.\nConnection.prototype.on = function on(event, callback) {\n  if (event === 'error' && this.$initialConnection) {\n    this.$initialConnection.catch(() => {});\n  }\n  return EventEmitter.prototype.on.call(this, event, callback);\n};\n\n/**\n * Listen to a event once in the Connection\n *\n * @param {String} event The event to listen on\n * @param {Function} callback\n * @see Connection#readyState https://mongoosejs.com/docs/api/connection.html#Connection.prototype.readyState\n *\n * @method once\n * @instance\n * @memberOf Connection\n * @api public\n */\n\n// Treat `on('error')` handlers as handling the initialConnection promise\n// to avoid uncaught exceptions when using `on('error')`. See gh-14377.\nConnection.prototype.once = function on(event, callback) {\n  if (event === 'error' && this.$initialConnection) {\n    this.$initialConnection.catch(() => {});\n  }\n  return EventEmitter.prototype.once.call(this, event, callback);\n};\n\n/*!\n * ignore\n */\n\nfunction _validateArgs(uri, options, callback) {\n  if (typeof options === 'function' && callback == null) {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  } else if (typeof callback === 'function') {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _handleConnectionErrors(err) {\n  if (err?.name === 'MongoServerSelectionError') {\n    const originalError = err;\n    err = new ServerSelectionError();\n    err.assimilateError(originalError);\n  }\n\n  return err;\n}\n\n/**\n * Destroy the connection. Similar to [`.close`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.close()),\n * but also removes the connection from Mongoose's `connections` list and prevents the\n * connection from ever being re-opened.\n *\n * @param {Boolean} [force]\n * @returns {Promise}\n */\n\nConnection.prototype.destroy = async function destroy(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.destroy() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  return this._close(force, true);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force] optional\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.close = async function close(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.close() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  if (this._lastHeartbeatAt != null) {\n    this._lastHeartbeatAt = null;\n  }\n\n  for (const model of Object.values(this.models)) {\n    // If manually disconnecting, make sure to clear each model's `$init`\n    // promise, so Mongoose knows to re-run `init()` in case the\n    // connection is re-opened. See gh-12047.\n    delete model.$init;\n  }\n\n  return this._close(force, false);\n};\n\n/**\n * Handles closing the connection\n *\n * @param {Boolean} force\n * @param {Boolean} destroy\n * @returns {Connection} this\n * @api private\n */\nConnection.prototype._close = async function _close(force, destroy) {\n  const _this = this;\n  const closeCalled = this._closeCalled;\n  this._closeCalled = true;\n  this._destroyCalled = destroy;\n  if (this.client != null) {\n    this.client._closeCalled = true;\n    this.client._destroyCalled = destroy;\n  }\n\n  const conn = this;\n  switch (this.readyState) {\n    case STATES.disconnected:\n      if (destroy) {\n        const index = this.base.connections.indexOf(conn);\n        if (index !== -1) {\n          this.base.connections.splice(index, 1);\n        }\n      }\n      if (!closeCalled) {\n        await this.doClose(force);\n        this.onClose(force);\n      }\n      break;\n\n    case STATES.connected:\n      this.readyState = STATES.disconnecting;\n      await this.doClose(force);\n      if (destroy) {\n        const index = _this.base.connections.indexOf(conn);\n        if (index !== -1) {\n          this.base.connections.splice(index, 1);\n        }\n      }\n      this.onClose(force);\n\n      break;\n    case STATES.connecting:\n      return new Promise((resolve, reject) => {\n        const _rerunClose = () => {\n          this.removeListener('open', _rerunClose);\n          this.removeListener('error', _rerunClose);\n          if (destroy) {\n            this.destroy(force).then(resolve, reject);\n          } else {\n            this.close(force).then(resolve, reject);\n          }\n        };\n\n        this.once('open', _rerunClose);\n        this.once('error', _rerunClose);\n      });\n\n    case STATES.disconnecting:\n      return new Promise(resolve => {\n        this.once('close', () => {\n          if (destroy && this.base.connections.indexOf(conn) !== -1) {\n            this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n          }\n          resolve();\n        });\n      });\n  }\n\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n *\n * @api private\n */\n\nConnection.prototype.doClose = function doClose() {\n  throw new Error('Connection#doClose unimplemented by driver');\n};\n\n/**\n * Called when the connection closes\n *\n * @emits \"close\"\n * @api private\n */\n\nConnection.prototype.onClose = function onClose(force) {\n  this.readyState = STATES.disconnected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (Object.hasOwn(this.collections, i)) {\n      this.collections[i].onClose(force);\n    }\n  }\n\n  this.emit('close', force);\n\n  const wasForceClosed = typeof force === 'object' && force !== null ? force.force : force;\n\n  for (const db of this.otherDbs) {\n    this._destroyCalled ? db.destroy({ force: wasForceClosed, skipCloseClient: true }) : db.close({ force: wasForceClosed, skipCloseClient: true });\n  }\n};\n\n/**\n * Retrieves a raw collection instance, creating it if not cached.\n * This method returns a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using a Collection bypasses Mongoose middleware, validation, and casting,\n * letting you use [MongoDB Node.js driver](https://mongodb.github.io/node-mongodb-native/) functionality directly.\n *\n * @param {String} name of the collection\n * @param {Object} [options] optional collection options\n * @return {Collection} collection instance\n * @api public\n */\n\nConnection.prototype.collection = function(name, options) {\n  const defaultOptions = {\n    autoIndex: this.config.autoIndex ?? this.base.options.autoIndex,\n    autoCreate: this.config.autoCreate ?? this.base.options.autoCreate,\n    autoSearchIndex: this.config.autoSearchIndex ?? this.base.options.autoSearchIndex\n  };\n  options = Object.assign({}, defaultOptions, options ? clone(options) : {});\n  options.$wasForceClosed = this.$wasForceClosed;\n  const Collection = this.base?.__driver?.Collection || driver.get().Collection;\n  if (!(name in this.collections)) {\n    this.collections[name] = new Collection(name, this, options);\n  }\n  return this.collections[name];\n};\n\n/**\n * Declares a plugin executed on all schemas you pass to `conn.model()`\n *\n * Equivalent to calling `.plugin(fn)` on each schema you create.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Connection} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nConnection.prototype.plugin = function(fn, opts) {\n  this.plugins.push([fn, opts]);\n  return this;\n};\n\n/**\n * Defines or retrieves a model.\n *\n *     const mongoose = require('mongoose');\n *     const db = mongoose.createConnection(..);\n *     db.model('Venue', new Schema(..));\n *     const Ticket = db.model('Ticket', new Schema(..));\n *     const Venue = db.model('Venue');\n *\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the `utils.toCollectionName` method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor'\n *     const M = conn.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name the model name or class extending Model\n * @param {Schema} [schema] a schema. necessary when defining a model\n * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name\n * @param {Object} [options]\n * @param {Boolean} [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid `OverwriteModelError`\n * @see Mongoose#model https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()\n * @return {Model} The compiled model\n * @api public\n */\n\nConnection.prototype.model = function model(name, schema, collection, options) {\n  if (!(this instanceof Connection)) {\n    throw new MongooseError('`connection.model()` should not be run with ' +\n      '`new`. If you are doing `new db.model(foo)(bar)`, use ' +\n      '`db.model(foo)(bar)` instead');\n  }\n\n  let fn;\n  if (typeof name === 'function') {\n    fn = name;\n    name = fn.name;\n  }\n\n  // collection name discovery\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (utils.isObject(schema)) {\n    if (!schema.instanceOfSchema) {\n      schema = new Schema(schema);\n    } else if (!(schema instanceof this.base.Schema)) {\n      schema = schema._clone(this.base.Schema);\n    }\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };\n  const opts = Object.assign(defaultOptions, options, { connection: this });\n  if (this.models[name] && !collection && opts.overwriteModels !== true) {\n    // model exists but we are not subclassing with custom collection\n    if (schema?.instanceOfSchema && schema !== this.models[name].schema) {\n      throw new MongooseError.OverwriteModelError(name);\n    }\n    return this.models[name];\n  }\n\n  let model;\n\n  if (schema?.instanceOfSchema) {\n    applyPlugins(schema, this.plugins, null, '$connectionPluginsApplied');\n\n    // compile a model\n    model = this.base._model(fn || name, schema, collection, opts);\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n\n    return model;\n  }\n\n  if (this.models[name] && collection) {\n    // subclassing current model with alternate collection\n    model = this.models[name];\n    schema = model.prototype.schema;\n    const sub = model.__subclass(this, schema, collection);\n    // do not cache the sub model\n    return sub;\n  }\n\n  if (arguments.length === 1) {\n    model = this.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n\n  if (!model) {\n    throw new MongooseError.MissingSchemaError(name);\n  }\n\n  if (this === model.prototype.db\n      && (!collection || collection === model.collection.name)) {\n    // model already uses this connection.\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    return model;\n  }\n  this.models[name] = model.__subclass(this, schema, collection);\n  return this.models[name];\n};\n\n/**\n * Removes the model named `name` from this connection, if it exists. You can\n * use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * #### Example:\n *\n *     conn.model('User', new Schema({ name: String }));\n *     console.log(conn.model('User')); // Model object\n *     conn.deleteModel('User');\n *     console.log(conn.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       conn.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Connection} this\n */\n\nConnection.prototype.deleteModel = function deleteModel(name) {\n  if (typeof name === 'string') {\n    const model = this.model(name);\n    if (model == null) {\n      return this;\n    }\n    const collectionName = model.collection.name;\n    delete this.models[name];\n    delete this.collections[collectionName];\n\n    this.emit('deleteModel', model);\n  } else if (name instanceof RegExp) {\n    const pattern = name;\n    const names = this.modelNames();\n    for (const name of names) {\n      if (pattern.test(name)) {\n        this.deleteModel(name);\n      }\n    }\n  } else {\n    throw new Error('First parameter to `deleteModel()` must be a string ' +\n      'or regexp, got \"' + name + '\"');\n  }\n\n  return this;\n};\n\n/**\n * Watches the entire underlying database for changes. Similar to\n * [`Model.watch()`](https://mongoosejs.com/docs/api/model.html#Model.watch()).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const User = conn.model('User', new Schema({ name: String }));\n *\n *     const changeStream = conn.watch().on('change', data => console.log(data));\n *\n *     // Triggers a 'change' event on the change stream.\n *     await User.create({ name: 'test' });\n *\n * @api public\n * @param {Array} [pipeline]\n * @param {Object} [options] passed without changes to [the MongoDB driver's `Db#watch()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#watch)\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n */\n\nConnection.prototype.watch = function watch(pipeline, options) {\n  const changeStreamThunk = cb => {\n    immediate(() => {\n      if (this.readyState === STATES.connecting) {\n        this.once('open', function() {\n          const driverChangeStream = this.db.watch(pipeline, options);\n          cb(null, driverChangeStream);\n        });\n      } else {\n        const driverChangeStream = this.db.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      }\n    });\n  };\n\n  const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);\n  return changeStream;\n};\n\n/**\n * Returns a promise that resolves when this connection\n * successfully connects to MongoDB, or rejects if this connection failed\n * to connect.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *     conn.readyState; // 1, means Mongoose is connected\n *\n * @api public\n * @return {Promise}\n */\n\nConnection.prototype.asPromise = async function asPromise() {\n  try {\n    await this.$initialConnection;\n    return this;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n};\n\n/**\n * Returns an array of model names created on this connection.\n * @api public\n * @return {String[]}\n */\n\nConnection.prototype.modelNames = function modelNames() {\n  return Object.keys(this.models);\n};\n\n/**\n * Returns if the connection requires authentication after it is opened. Generally if a\n * username and password are both provided than authentication is needed, but in some cases a\n * password is not required.\n *\n * @api private\n * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.\n */\nConnection.prototype.shouldAuthenticate = function shouldAuthenticate() {\n  return this.user != null &&\n    (this.pass != null || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns a boolean value that specifies if the current authentication mechanism needs a\n * password to authenticate according to the auth objects passed into the openUri methods.\n *\n * @api private\n * @return {Boolean} true if the authentication mechanism specified in the options object requires\n *  a password, otherwise false.\n */\nConnection.prototype.authMechanismDoesNotRequirePassword = function authMechanismDoesNotRequirePassword() {\n  if (this.options?.auth) {\n    return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;\n  }\n  return true;\n};\n\n/**\n * Returns a boolean value that specifies if the provided objects object provides enough\n * data to authenticate with. Generally this is true if the username and password are both specified\n * but in some authentication methods, a password is not required for authentication so only a username\n * is required.\n *\n * @param {Object} [options] the options object passed into the openUri methods.\n * @api private\n * @return {Boolean} true if the provided options object provides enough data to authenticate with,\n *   otherwise false.\n */\nConnection.prototype.optionsProvideAuthenticationData = function optionsProvideAuthenticationData(options) {\n  return (options) &&\n      (options.user) &&\n      ((options.pass) || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *\n *     conn.getClient(); // MongoClient { ... }\n *\n * @api public\n * @return {MongoClient}\n */\n\nConnection.prototype.getClient = function getClient() {\n  return this.client;\n};\n\n/**\n * Set the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to\n * reuse it.\n *\n * #### Example:\n *\n *     const client = await mongodb.MongoClient.connect('mongodb://127.0.0.1:27017/test');\n *\n *     const conn = mongoose.createConnection().setClient(client);\n *\n *     conn.getClient(); // MongoClient { ... }\n *     conn.readyState; // 1, means 'CONNECTED'\n *\n * @api public\n * @param {MongClient} client The Client to set to be used.\n * @return {Connection} this\n */\n\nConnection.prototype.setClient = function setClient() {\n  throw new MongooseError('Connection#setClient not implemented by driver');\n};\n\n/*!\n * Called internally by `openUri()` to create a MongoClient instance.\n */\n\nConnection.prototype.createClient = function createClient() {\n  throw new MongooseError('Connection#createClient not implemented by driver');\n};\n\n/**\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.continueOnError] `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise<Object>} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nConnection.prototype.syncIndexes = async function syncIndexes(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.syncIndexes(options);\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && utils.hasOwnKeys(errorsMap)) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const syncIndexesError = new SyncIndexesError(message, errorsMap);\n    throw syncIndexesError;\n  }\n\n  return result;\n};\n\n/**\n * Switches to a different database using the same [connection pool](https://mongoosejs.com/docs/connections.html#connection_pools).\n *\n * Returns a new connection object, with the new db.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *     // Creates a cached connection to `mydb2`. All calls to `conn.useDb('mydb2', { useCache: true })` will return the same\n *     // connection instance as opposed to creating a new connection instance\n *     const db2 = conn.useDb('mydb2', { useCache: true });\n *\n * @method useDb\n * @memberOf Connection\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @return {Connection} New Connection Object\n * @api public\n */\n\n/**\n * Runs a [db-level aggregate()](https://www.mongodb.com/docs/manual/reference/method/db.aggregate/) on this connection's underlying `db`\n *\n * @method aggregate\n * @memberOf Connection\n * @param {Array} pipeline\n * @param {Object} [options]\n * @param {Boolean} [options.cursor=false] If true, make the Aggregate resolve to a Mongoose AggregationCursor rather than an array\n * @return {Aggregate} Aggregation wrapper\n * @api public\n */\n\n/**\n * Removes the database connection with the given name created with with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n * @api public\n */\n\n/*!\n * Module exports.\n */\n\nConnection.STATES = STATES;\nmodule.exports = Connection;\n"],"mappings":"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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAxC,UAAU,CAACsB,SAAS,CAACW,GAAG,GAAG,SAASS,SAASA,CAACF,GAAG,EAAEN,GAAG,EAAE;EACtD,IAAId,MAAM,CAACqB,MAAM,CAAC,IAAI,CAACrC,MAAM,EAAEoC,GAAG,CAAC,EAAE;IACnC,IAAI,CAACpC,MAAM,CAACoC,GAAG,CAAC,GAAGN,GAAG;IACtB,OAAOA,GAAG;EACZ;EAEA,IAAI,CAAC5B,OAAO,GAAG,IAAI,CAACA,OAAO,IAAI,CAAC,CAAC;EACjC,IAAI,CAACA,OAAO,CAACkC,GAAG,CAAC,GAAGN,GAAG;EACvB,OAAOA,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAlC,UAAU,CAACsB,SAAS,CAACpB,WAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAF,UAAU,CAACsB,SAAS,CAACqB,IAAI;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA3C,UAAU,CAACsB,SAAS,CAACnB,MAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAH,UAAU,CAACsB,SAAS,CAACL,EAAE;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAG,MAAM,CAACG,cAAc,CAACvB,UAAU,CAACsB,SAAS,EAAE,SAAS,EAAE;EACrDsB,YAAY,EAAE,KAAK;EACnBC,UAAU,EAAE,IAAI;EAChBC,QAAQ,EAAE;AACZ,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA1B,MAAM,CAACG,cAAc,CAACvB,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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}