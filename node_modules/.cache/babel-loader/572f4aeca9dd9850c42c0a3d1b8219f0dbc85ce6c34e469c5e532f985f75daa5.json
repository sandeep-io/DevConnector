{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = executeOperation;\nexports.autoConnect = autoConnect;\nconst constants_1 = require(\"../cmap/wire_protocol/constants\");\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\nconst aggregate_1 = require(\"./aggregate\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nasync function executeOperation(client, operation, timeoutContext) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  const topology = client.topology == null ? await (0, utils_1.abortable)(autoConnect(client), operation.options) : client.topology;\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner;\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({\n      owner,\n      explicit: false\n    });\n  } else if (session.hasEnded) {\n    throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && (0, utils_1.maxWireVersion)(topology) < constants_1.MIN_SUPPORTED_SNAPSHOT_READS_WIRE_VERSION) {\n    throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n  operation.session ??= session;\n  const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary) && (hasReadAspect || operation.commandName === 'runCommand')) {\n    throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);\n  }\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  timeoutContext ??= timeout_1.TimeoutContext.create({\n    session,\n    serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,\n    waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,\n    timeoutMS: operation.options.timeoutMS\n  });\n  try {\n    return await tryOperation(operation, {\n      topology,\n      timeoutContext,\n      session,\n      readPreference\n    });\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession();\n    }\n  }\n}\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nasync function autoConnect(client) {\n  if (client.topology == null) {\n    if (client.s.hasBeenClosed) {\n      throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options.__skipPingOnConnect = true;\n    try {\n      await client.connect();\n      if (client.topology == null) {\n        throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n      }\n      return client.topology;\n    } finally {\n      delete client.s.options.__skipPingOnConnect;\n    }\n  }\n  return client.topology;\n}\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation(operation, {\n  topology,\n  timeoutContext,\n  session,\n  readPreference\n}) {\n  let selector;\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);\n  } else if (operation instanceof aggregate_1.AggregateOperation && operation.hasWriteStage) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n  let server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName,\n    timeoutContext,\n    signal: operation.options.signal\n  });\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const inTransaction = session?.inTransaction() ?? false;\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n  const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n  const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) && session != null && (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite);\n  if (hasWriteAspect && willRetryWrite && session != null) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n  const maxTries = willRetry ? timeoutContext.csotEnabled() ? Infinity : 2 : 1;\n  let previousOperationError;\n  let previousServer;\n  for (let tries = 0; tries < maxTries; tries++) {\n    if (previousOperationError) {\n      if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new error_1.MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: previousOperationError\n        });\n      }\n      if (operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {\n        throw previousOperationError;\n      }\n      if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError)) throw previousOperationError;\n      if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError)) {\n        throw previousOperationError;\n      }\n      if (previousOperationError instanceof error_1.MongoNetworkError && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) && session != null && session.isPinned && !session.inTransaction()) {\n        session.unpin({\n          force: true,\n          forceClear: true\n        });\n      }\n      server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        previousServer,\n        signal: operation.options.signal\n      });\n      if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server)) {\n        throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n      }\n    }\n    operation.server = server;\n    try {\n      // If tries > 0 and we are command batching we need to reset the batch.\n      if (tries > 0 && operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING)) {\n        operation.resetBatch();\n      }\n      try {\n        const result = await server.command(operation, timeoutContext);\n        return operation.handleOk(result);\n      } catch (error) {\n        return operation.handleError(error);\n      }\n    } catch (operationError) {\n      if (!(operationError instanceof error_1.MongoError)) throw operationError;\n      if (previousOperationError != null && operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n        throw previousOperationError;\n      }\n      previousServer = server.description;\n      previousOperationError = operationError;\n      // Reset timeouts\n      timeoutContext.clear();\n    }\n  }\n  throw previousOperationError ?? new error_1.MongoRuntimeError('Tried to propagate retryability error, but no error was found.');\n}","map":{"version":3,"names":["exports","executeOperation","autoConnect","constants_1","require","error_1","read_preference_1","server_selection_1","timeout_1","utils_1","aggregate_1","operation_1","MMAPv1_RETRY_WRITES_ERROR_CODE","MONGODB_ERROR_CODES","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","client","operation","timeoutContext","AbstractOperation","MongoRuntimeError","topology","abortable","options","session","owner","Symbol","startSession","explicit","hasEnded","MongoExpiredSessionError","snapshotEnabled","maxWireVersion","MIN_SUPPORTED_SNAPSHOT_READS_WIRE_VERSION","MongoCompatibilityError","MongoInvalidArgumentError","readPreference","ReadPreference","primary","inTransaction","hasReadAspect","hasAspect","Aspect","READ_OPERATION","equals","commandName","MongoTransactionError","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","TimeoutContext","create","serverSelectionTimeoutMS","s","waitQueueTimeoutMS","timeoutMS","tryOperation","endSession","hasBeenClosed","MongoNotConnectedError","__skipPingOnConnect","connect","selector","MUST_SELECT_SAME_SERVER","sameServerSelector","server","description","AggregateOperation","hasWriteStage","secondaryWritableServerSelector","commonWireVersion","selectServer","operationName","signal","hasWriteAspect","WRITE_OPERATION","willRetryRead","retryReads","canRetryRead","willRetryWrite","retryWrites","supportsRetryableWrites","canRetryWrite","willRetry","RETRYABLE","incrementTransactionNumber","maxTries","csotEnabled","Infinity","previousOperationError","previousServer","tries","code","MongoServerError","message","errmsg","originalError","COMMAND_BATCHING","isRetryableWriteError","isRetryableReadError","MongoNetworkError","CURSOR_CREATING","force","forceClear","MongoUnexpectedServerResponseError","resetBatch","result","command","handleOk","error","handleError","operationError","MongoError","hasErrorLabel","MongoErrorLabel","NoWritesPerformed","clear"],"sources":["C:\\DEVC\\node_modules\\mongodb\\src\\operations\\execute_operation.ts"],"sourcesContent":["import { MIN_SUPPORTED_SNAPSHOT_READS_WIRE_VERSION } from '../cmap/wire_protocol/constants';\nimport {\n  isRetryableReadError,\n  isRetryableWriteError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNotConnectedError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { ReadPreference } from '../read_preference';\nimport type { ServerDescription } from '../sdam/server_description';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  type ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { TimeoutContext } from '../timeout';\nimport { abortable, maxWireVersion, supportsRetryableWrites } from '../utils';\nimport { AggregateOperation } from './aggregate';\nimport { AbstractOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation extends AbstractOperation> = ReturnType<\n  TOperation['handleOk']\n>;\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nexport async function executeOperation<\n  T extends AbstractOperation,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, timeoutContext?: TimeoutContext | null): Promise<TResult> {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  const topology =\n    client.topology == null\n      ? await abortable(autoConnect(client), operation.options)\n      : client.topology;\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner: symbol | undefined;\n\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({ owner, explicit: false });\n  } else if (session.hasEnded) {\n    throw new MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (\n    session.snapshotEnabled &&\n    maxWireVersion(topology) < MIN_SUPPORTED_SNAPSHOT_READS_WIRE_VERSION\n  ) {\n    throw new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n\n  operation.session ??= session;\n\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n\n  if (\n    inTransaction &&\n    !readPreference.equals(ReadPreference.primary) &&\n    (hasReadAspect || operation.commandName === 'runCommand')\n  ) {\n    throw new MongoTransactionError(\n      `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n    );\n  }\n\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  timeoutContext ??= TimeoutContext.create({\n    session,\n    serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,\n    waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,\n    timeoutMS: operation.options.timeoutMS\n  });\n\n  try {\n    return await tryOperation(operation, {\n      topology,\n      timeoutContext,\n      session,\n      readPreference\n    });\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession();\n    }\n  }\n}\n\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nexport async function autoConnect(client: MongoClient): Promise<Topology> {\n  if (client.topology == null) {\n    if (client.s.hasBeenClosed) {\n      throw new MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options.__skipPingOnConnect = true;\n    try {\n      await client.connect();\n      if (client.topology == null) {\n        throw new MongoRuntimeError(\n          'client.connect did not create a topology but also did not throw'\n        );\n      }\n      return client.topology;\n    } finally {\n      delete client.s.options.__skipPingOnConnect;\n    }\n  }\n  return client.topology;\n}\n\n/** @internal */\ntype RetryOptions = {\n  session: ClientSession | undefined;\n  readPreference: ReadPreference;\n  topology: Topology;\n  timeoutContext: TimeoutContext;\n};\n\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation<T extends AbstractOperation, TResult = ResultTypeFromOperation<T>>(\n  operation: T,\n  { topology, timeoutContext, session, readPreference }: RetryOptions\n): Promise<TResult> {\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation instanceof AggregateOperation && operation.hasWriteStage) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  let server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName,\n    timeoutContext,\n    signal: operation.options.signal\n  });\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const inTransaction = session?.inTransaction() ?? false;\n\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n\n  const willRetryWrite =\n    topology.s.options.retryWrites &&\n    !inTransaction &&\n    supportsRetryableWrites(server) &&\n    operation.canRetryWrite;\n\n  const willRetry =\n    operation.hasAspect(Aspect.RETRYABLE) &&\n    session != null &&\n    ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite));\n\n  if (hasWriteAspect && willRetryWrite && session != null) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n\n  const maxTries = willRetry ? (timeoutContext.csotEnabled() ? Infinity : 2) : 1;\n  let previousOperationError: MongoError | undefined;\n  let previousServer: ServerDescription | undefined;\n\n  for (let tries = 0; tries < maxTries; tries++) {\n    if (previousOperationError) {\n      if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: previousOperationError\n        });\n      }\n\n      if (operation.hasAspect(Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {\n        throw previousOperationError;\n      }\n\n      if (hasWriteAspect && !isRetryableWriteError(previousOperationError))\n        throw previousOperationError;\n\n      if (hasReadAspect && !isRetryableReadError(previousOperationError)) {\n        throw previousOperationError;\n      }\n\n      if (\n        previousOperationError instanceof MongoNetworkError &&\n        operation.hasAspect(Aspect.CURSOR_CREATING) &&\n        session != null &&\n        session.isPinned &&\n        !session.inTransaction()\n      ) {\n        session.unpin({ force: true, forceClear: true });\n      }\n\n      server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        previousServer,\n        signal: operation.options.signal\n      });\n\n      if (hasWriteAspect && !supportsRetryableWrites(server)) {\n        throw new MongoUnexpectedServerResponseError(\n          'Selected server does not support retryable writes'\n        );\n      }\n    }\n\n    operation.server = server;\n\n    try {\n      // If tries > 0 and we are command batching we need to reset the batch.\n      if (tries > 0 && operation.hasAspect(Aspect.COMMAND_BATCHING)) {\n        operation.resetBatch();\n      }\n\n      try {\n        const result = await server.command(operation, timeoutContext);\n        return operation.handleOk(result);\n      } catch (error) {\n        return operation.handleError(error);\n      }\n    } catch (operationError) {\n      if (!(operationError instanceof MongoError)) throw operationError;\n      if (\n        previousOperationError != null &&\n        operationError.hasErrorLabel(MongoErrorLabel.NoWritesPerformed)\n      ) {\n        throw previousOperationError;\n      }\n      previousServer = server.description;\n      previousOperationError = operationError;\n\n      // Reset timeouts\n      timeoutContext.clear();\n    }\n  }\n\n  throw (\n    previousOperationError ??\n    new MongoRuntimeError('Tried to propagate retryability error, but no error was found.')\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}