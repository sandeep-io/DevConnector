{"ast":null,"code":"/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst MongooseError = require('../../error/index');\nconst STATES = require('../../connectionState');\nconst mongodb = require('mongodb');\nconst pkg = require('../../../package.json');\nconst processConnectionOptions = require('../../helpers/processConnectionOptions');\nconst setTimeout = require('../../helpers/timers').setTimeout;\nconst utils = require('../../utils');\nconst Schema = require('../../schema');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n  // Tracks the last time (as unix timestamp) the connection received a\n  // serverHeartbeatSucceeded or serverHeartbeatFailed event from the underlying MongoClient.\n  // If we haven't received one in a while (like due to a frozen AWS Lambda container) then\n  // `readyState` is likely stale.\n  this._lastHeartbeatAt = null;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function (name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n  newConn.client = _this.client;\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this._queue.push({\n      fn: wireup\n    });\n  }\n  function wireup() {\n    newConn.client = _this.client;\n    newConn.db = _this.client.db(name);\n    newConn._lastHeartbeatAt = _this._lastHeartbeatAt;\n    newConn.onOpen();\n  }\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  this.otherDbs.push(newConn);\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options?.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n  return newConn;\n};\n\n/**\n * Runs a [db-level aggregate()](https://www.mongodb.com/docs/manual/reference/method/db.aggregate/) on this connection's underlying `db`\n *\n * @param {Array} pipeline\n * @param {Object} [options]\n */\n\nNativeConnection.prototype.aggregate = function aggregate(pipeline, options) {\n  return new this.base.Aggregate(null, this).append(pipeline).option(options ?? {});\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n  if (skipCloseClient) {\n    return this;\n  }\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n  return this;\n};\n\n/**\n * Implementation of `listDatabases()` for MongoDB driver\n *\n * @return Promise\n * @api public\n */\n\nNativeConnection.prototype.listDatabases = async function listDatabases() {\n  await this._waitForConnect();\n  return await this.db.admin().listDatabases();\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' + `string, got \"${typeof uri}\". Make sure the first parameter to ` + '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n  if (this._destroyCalled) {\n    throw new MongooseError('Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' + 'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.');\n  }\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' + 'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' + 'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n  options = processConnectionOptions(uri, options);\n  if (options) {\n    const autoIndex = options.config?.autoIndex ?? options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n    if ('autoSearchIndex' in options) {\n      this.config.autoSearchIndex = options.autoSearchIndex;\n      delete options.autoSearchIndex;\n    }\n    if ('bufferTimeoutMS' in options) {\n      this.config.bufferTimeoutMS = options.bufferTimeoutMS;\n      delete options.bufferTimeoutMS;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n  const {\n    schemaMap,\n    encryptedFieldsMap\n  } = this._buildEncryptionSchemas();\n  if ((utils.hasOwnKeys(schemaMap) || utils.hasOwnKeys(encryptedFieldsMap)) && !options.autoEncryption) {\n    throw new Error('Must provide `autoEncryption` when connecting with encrypted schemas.');\n  }\n  if (utils.hasOwnKeys(schemaMap)) {\n    options.autoEncryption.schemaMap = schemaMap;\n  }\n  if (utils.hasOwnKeys(encryptedFieldsMap)) {\n    options.autoEncryption.encryptedFieldsMap = encryptedFieldsMap;\n  }\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n  client.setMaxListeners(0);\n  await client.connect();\n  _setClient(this, client, options, dbName);\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/**\n * Given a connection, which may or may not have encrypted models, build\n * a schemaMap and/or an encryptedFieldsMap for the connection, combining all models\n * into a single schemaMap and encryptedFields map.\n *\n * @returns the generated schemaMap and encryptedFieldsMap\n  */\nNativeConnection.prototype._buildEncryptionSchemas = function () {\n  const qeMappings = {};\n  const csfleMappings = {};\n  const encryptedModels = Object.values(this.models).filter(model => model.schema._hasEncryptedFields());\n\n  // If discriminators are configured for the collection, there might be multiple models\n  // pointing to the same namespace.  For this scenario, we merge all the schemas for each namespace\n  // into a single schema and then generate a schemaMap/encryptedFieldsMap for the combined schema.\n  for (const model of encryptedModels) {\n    const {\n      schema,\n      collection: {\n        collectionName\n      }\n    } = model;\n    const namespace = `${this.$dbName}.${collectionName}`;\n    const mappings = schema.encryptionType() === 'csfle' ? csfleMappings : qeMappings;\n    mappings[namespace] ??= new Schema({}, {\n      encryptionType: schema.encryptionType()\n    });\n    const isNonRootDiscriminator = schema.discriminatorMapping && !schema.discriminatorMapping.isRoot;\n    if (isNonRootDiscriminator) {\n      const rootSchema = schema._baseSchema;\n      schema.eachPath(pathname => {\n        if (rootSchema.path(pathname)) return;\n        if (!mappings[namespace]._hasEncryptedField(pathname)) return;\n        throw new Error(`Cannot have duplicate keys in discriminators with encryption. key=${pathname}`);\n      });\n    }\n    mappings[namespace].add(schema);\n  }\n  const schemaMap = Object.fromEntries(Object.entries(csfleMappings).map(([namespace, schema]) => [namespace, schema._buildSchemaMap()]));\n  const encryptedFieldsMap = Object.fromEntries(Object.entries(qeMappings).map(([namespace, schema]) => [namespace, schema._buildEncryptedFields()]));\n  return {\n    schemaMap,\n    encryptedFieldsMap\n  };\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client?.s?.options?.hosts?.[0]?.host;\n  conn.port = client?.s?.options?.hosts?.[0]?.port;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n  const type = client?.topology?.description?.type || '';\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n  conn._lastHeartbeatAt = null;\n  client.on('serverHeartbeatSucceeded', () => {\n    conn._lastHeartbeatAt = Date.now();\n    for (const otherDb of conn.otherDbs) {\n      otherDb._lastHeartbeatAt = conn._lastHeartbeatAt;\n    }\n  });\n  if (options.monitorCommands) {\n    client.on('commandStarted', data => conn.emit('commandStarted', data));\n    client.on('commandFailed', data => conn.emit('commandFailed', data));\n    client.on('commandSucceeded', data => conn.emit('commandSucceeded', data));\n  }\n  conn.onOpen();\n  for (const i in conn.collections) {\n    if (Object.hasOwn(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;","map":{"version":3,"names":["MongooseConnection","require","MongooseError","STATES","mongodb","pkg","processConnectionOptions","setTimeout","utils","Schema","NativeConnection","apply","arguments","_listening","_lastHeartbeatAt","Object","setPrototypeOf","prototype","useDb","name","options","useCache","relatedDbs","newConn","constructor","base","collections","models","replica","config","assign","_readyState","_closeCalled","_hasOpened","_parent","host","port","user","pass","_this","client","db","connected","wireup","_queue","push","fn","onOpen","otherDbs","aggregate","pipeline","Aggregate","append","option","removeDb","dbs","filter","length","_destroyCalled","disconnected","$wasForceClosed","doClose","force","skipCloseClient","close","Promise","resolve","listDatabases","_waitForConnect","admin","createClient","uri","readyState","connecting","_connectionString","autoIndex","autoCreate","sanitizeFilter","autoSearchIndex","bufferTimeoutMS","auth","username","password","bufferCommands","_connectionOptions","dbName","$dbName","hasUserDefinedProperty","driverInfo","version","schemaMap","encryptedFieldsMap","_buildEncryptionSchemas","hasOwnKeys","autoEncryption","Error","MongoClient","error","setMaxListeners","connect","_setClient","qeMappings","csfleMappings","encryptedModels","values","model","schema","_hasEncryptedFields","collection","collectionName","namespace","mappings","encryptionType","isNonRootDiscriminator","discriminatorMapping","isRoot","rootSchema","_baseSchema","eachPath","pathname","path","_hasEncryptedField","add","fromEntries","entries","map","_buildSchemaMap","_buildEncryptedFields","setClient","topology","s","url","init","catch","$modelInitNoop","conn","hosts","databaseName","_handleReconnect","emit","type","description","on","ev","newDescription","startsWith","Date","now","otherDb","monitorCommands","data","i","hasOwn","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst MongooseError = require('../../error/index');\nconst STATES = require('../../connectionState');\nconst mongodb = require('mongodb');\nconst pkg = require('../../../package.json');\nconst processConnectionOptions = require('../../helpers/processConnectionOptions');\nconst setTimeout = require('../../helpers/timers').setTimeout;\nconst utils = require('../../utils');\nconst Schema = require('../../schema');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n  // Tracks the last time (as unix timestamp) the connection received a\n  // serverHeartbeatSucceeded or serverHeartbeatFailed event from the underlying MongoClient.\n  // If we haven't received one in a while (like due to a frozen AWS Lambda container) then\n  // `readyState` is likely stale.\n  this._lastHeartbeatAt = null;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this._queue.push({ fn: wireup });\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    newConn.db = _this.client.db(name);\n    newConn._lastHeartbeatAt = _this._lastHeartbeatAt;\n    newConn.onOpen();\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  this.otherDbs.push(newConn);\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options?.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/**\n * Runs a [db-level aggregate()](https://www.mongodb.com/docs/manual/reference/method/db.aggregate/) on this connection's underlying `db`\n *\n * @param {Array} pipeline\n * @param {Object} [options]\n */\n\nNativeConnection.prototype.aggregate = function aggregate(pipeline, options) {\n  return new this.base.Aggregate(null, this).append(pipeline).option(options ?? {});\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    return this;\n  }\n\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n\n  return this;\n};\n\n/**\n * Implementation of `listDatabases()` for MongoDB driver\n *\n * @return Promise\n * @api public\n */\n\nNativeConnection.prototype.listDatabases = async function listDatabases() {\n  await this._waitForConnect();\n\n  return await this.db.admin().listDatabases();\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +\n      `string, got \"${typeof uri}\". Make sure the first parameter to ` +\n      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n\n  if (this._destroyCalled) {\n    throw new MongooseError(\n      'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +\n      'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.'\n    );\n  }\n\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' +\n        'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' +\n        'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n\n  options = processConnectionOptions(uri, options);\n\n  if (options) {\n\n    const autoIndex = options.config?.autoIndex ?? options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n\n    if ('autoSearchIndex' in options) {\n      this.config.autoSearchIndex = options.autoSearchIndex;\n      delete options.autoSearchIndex;\n    }\n\n    if ('bufferTimeoutMS' in options) {\n      this.config.bufferTimeoutMS = options.bufferTimeoutMS;\n      delete options.bufferTimeoutMS;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n\n  const { schemaMap, encryptedFieldsMap } = this._buildEncryptionSchemas();\n\n  if ((utils.hasOwnKeys(schemaMap) || utils.hasOwnKeys(encryptedFieldsMap)) && !options.autoEncryption) {\n    throw new Error('Must provide `autoEncryption` when connecting with encrypted schemas.');\n  }\n\n  if (utils.hasOwnKeys(schemaMap)) {\n    options.autoEncryption.schemaMap = schemaMap;\n  }\n\n  if (utils.hasOwnKeys(encryptedFieldsMap)) {\n    options.autoEncryption.encryptedFieldsMap = encryptedFieldsMap;\n  }\n\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n\n  client.setMaxListeners(0);\n  await client.connect();\n\n  _setClient(this, client, options, dbName);\n\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/**\n * Given a connection, which may or may not have encrypted models, build\n * a schemaMap and/or an encryptedFieldsMap for the connection, combining all models\n * into a single schemaMap and encryptedFields map.\n *\n * @returns the generated schemaMap and encryptedFieldsMap\n  */\nNativeConnection.prototype._buildEncryptionSchemas = function() {\n  const qeMappings = {};\n  const csfleMappings = {};\n\n  const encryptedModels = Object.values(this.models).filter(model => model.schema._hasEncryptedFields());\n\n  // If discriminators are configured for the collection, there might be multiple models\n  // pointing to the same namespace.  For this scenario, we merge all the schemas for each namespace\n  // into a single schema and then generate a schemaMap/encryptedFieldsMap for the combined schema.\n  for (const model of encryptedModels) {\n    const { schema, collection: { collectionName } } = model;\n    const namespace = `${this.$dbName}.${collectionName}`;\n    const mappings = schema.encryptionType() === 'csfle' ? csfleMappings : qeMappings;\n\n    mappings[namespace] ??= new Schema({}, { encryptionType: schema.encryptionType() });\n\n    const isNonRootDiscriminator = schema.discriminatorMapping && !schema.discriminatorMapping.isRoot;\n    if (isNonRootDiscriminator) {\n      const rootSchema = schema._baseSchema;\n      schema.eachPath((pathname) => {\n        if (rootSchema.path(pathname)) return;\n        if (!mappings[namespace]._hasEncryptedField(pathname)) return;\n\n        throw new Error(`Cannot have duplicate keys in discriminators with encryption. key=${pathname}`);\n      });\n    }\n\n    mappings[namespace].add(schema);\n  }\n\n  const schemaMap = Object.fromEntries(Object.entries(csfleMappings).map(\n    ([namespace, schema]) => ([namespace, schema._buildSchemaMap()])\n  ));\n\n  const encryptedFieldsMap = Object.fromEntries(Object.entries(qeMappings).map(\n    ([namespace, schema]) => ([namespace, schema._buildEncryptedFields()])\n  ));\n\n  return {\n    schemaMap, encryptedFieldsMap\n  };\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client?.s?.options?.hosts?.[0]?.host;\n  conn.port = client?.s?.options?.hosts?.[0]?.port;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n\n  const type = client?.topology?.description?.type || '';\n\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n\n  conn._lastHeartbeatAt = null;\n\n  client.on('serverHeartbeatSucceeded', () => {\n    conn._lastHeartbeatAt = Date.now();\n    for (const otherDb of conn.otherDbs) {\n      otherDb._lastHeartbeatAt = conn._lastHeartbeatAt;\n    }\n  });\n\n  if (options.monitorCommands) {\n    client.on('commandStarted', (data) => conn.emit('commandStarted', data));\n    client.on('commandFailed', (data) => conn.emit('commandFailed', data));\n    client.on('commandSucceeded', (data) => conn.emit('commandSucceeded', data));\n  }\n\n  conn.onOpen();\n\n  for (const i in conn.collections) {\n    if (Object.hasOwn(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n"],"mappings":"AAAA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,kBAAkB,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AACtD,MAAMC,aAAa,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AAClD,MAAME,MAAM,GAAGF,OAAO,CAAC,uBAAuB,CAAC;AAC/C,MAAMG,OAAO,GAAGH,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMI,GAAG,GAAGJ,OAAO,CAAC,uBAAuB,CAAC;AAC5C,MAAMK,wBAAwB,GAAGL,OAAO,CAAC,wCAAwC,CAAC;AAClF,MAAMM,UAAU,GAAGN,OAAO,CAAC,sBAAsB,CAAC,CAACM,UAAU;AAC7D,MAAMC,KAAK,GAAGP,OAAO,CAAC,aAAa,CAAC;AACpC,MAAMQ,MAAM,GAAGR,OAAO,CAAC,cAAc,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASS,gBAAgBA,CAAA,EAAG;EAC1BV,kBAAkB,CAACW,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EACzC,IAAI,CAACC,UAAU,GAAG,KAAK;EACvB;EACA;EACA;EACA;EACA,IAAI,CAACC,gBAAgB,GAAG,IAAI;AAC9B;;AAEA;AACA;AACA;AACA;;AAEAJ,gBAAgB,CAACP,MAAM,GAAGA,MAAM;;AAEhC;AACA;AACA;;AAEAY,MAAM,CAACC,cAAc,CAACN,gBAAgB,CAACO,SAAS,EAAEjB,kBAAkB,CAACiB,SAAS,CAAC;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAP,gBAAgB,CAACO,SAAS,CAACC,KAAK,GAAG,UAASC,IAAI,EAAEC,OAAO,EAAE;EACzD;EACAA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAIA,OAAO,CAACC,QAAQ,IAAI,IAAI,CAACC,UAAU,CAACH,IAAI,CAAC,EAAE;IAC7C,OAAO,IAAI,CAACG,UAAU,CAACH,IAAI,CAAC;EAC9B;;EAEA;EACA,MAAMI,OAAO,GAAG,IAAI,IAAI,CAACC,WAAW,CAAC,CAAC;EACtCD,OAAO,CAACJ,IAAI,GAAGA,IAAI;EACnBI,OAAO,CAACE,IAAI,GAAG,IAAI,CAACA,IAAI;EACxBF,OAAO,CAACG,WAAW,GAAG,CAAC,CAAC;EACxBH,OAAO,CAACI,MAAM,GAAG,CAAC,CAAC;EACnBJ,OAAO,CAACK,OAAO,GAAG,IAAI,CAACA,OAAO;EAC9BL,OAAO,CAACM,MAAM,GAAGd,MAAM,CAACe,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACD,MAAM,EAAEN,OAAO,CAACM,MAAM,CAAC;EAC/DN,OAAO,CAACJ,IAAI,GAAG,IAAI,CAACA,IAAI;EACxBI,OAAO,CAACH,OAAO,GAAG,IAAI,CAACA,OAAO;EAC9BG,OAAO,CAACQ,WAAW,GAAG,IAAI,CAACA,WAAW;EACtCR,OAAO,CAACS,YAAY,GAAG,IAAI,CAACA,YAAY;EACxCT,OAAO,CAACU,UAAU,GAAG,IAAI,CAACA,UAAU;EACpCV,OAAO,CAACV,UAAU,GAAG,KAAK;EAC1BU,OAAO,CAACW,OAAO,GAAG,IAAI;EAEtBX,OAAO,CAACY,IAAI,GAAG,IAAI,CAACA,IAAI;EACxBZ,OAAO,CAACa,IAAI,GAAG,IAAI,CAACA,IAAI;EACxBb,OAAO,CAACc,IAAI,GAAG,IAAI,CAACA,IAAI;EACxBd,OAAO,CAACe,IAAI,GAAG,IAAI,CAACA,IAAI;;EAExB;EACA;EACA;EACA;EACA;EACA;;EAEA,MAAMC,KAAK,GAAG,IAAI;EAElBhB,OAAO,CAACiB,MAAM,GAAGD,KAAK,CAACC,MAAM;EAE7B,IAAI,IAAI,CAACC,EAAE,IAAI,IAAI,CAACV,WAAW,KAAK5B,MAAM,CAACuC,SAAS,EAAE;IACpDC,MAAM,CAAC,CAAC;EACV,CAAC,MAAM;IACL,IAAI,CAACC,MAAM,CAACC,IAAI,CAAC;MAAEC,EAAE,EAAEH;IAAO,CAAC,CAAC;EAClC;EAEA,SAASA,MAAMA,CAAA,EAAG;IAChBpB,OAAO,CAACiB,MAAM,GAAGD,KAAK,CAACC,MAAM;IAC7BjB,OAAO,CAACkB,EAAE,GAAGF,KAAK,CAACC,MAAM,CAACC,EAAE,CAACtB,IAAI,CAAC;IAClCI,OAAO,CAACT,gBAAgB,GAAGyB,KAAK,CAACzB,gBAAgB;IACjDS,OAAO,CAACwB,MAAM,CAAC,CAAC;EAClB;EAEAxB,OAAO,CAACJ,IAAI,GAAGA,IAAI;;EAEnB;EACA,IAAI,CAAC6B,QAAQ,CAACH,IAAI,CAACtB,OAAO,CAAC;EAC3BA,OAAO,CAACyB,QAAQ,CAACH,IAAI,CAAC,IAAI,CAAC;;EAE3B;EACA,IAAIzB,OAAO,EAAEC,QAAQ,EAAE;IACrB,IAAI,CAACC,UAAU,CAACC,OAAO,CAACJ,IAAI,CAAC,GAAGI,OAAO;IACvCA,OAAO,CAACD,UAAU,GAAG,IAAI,CAACA,UAAU;EACtC;EAEA,OAAOC,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEAb,gBAAgB,CAACO,SAAS,CAACgC,SAAS,GAAG,SAASA,SAASA,CAACC,QAAQ,EAAE9B,OAAO,EAAE;EAC3E,OAAO,IAAI,IAAI,CAACK,IAAI,CAAC0B,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAACC,MAAM,CAACF,QAAQ,CAAC,CAACG,MAAM,CAACjC,OAAO,IAAI,CAAC,CAAC,CAAC;AACnF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAV,gBAAgB,CAACO,SAAS,CAACqC,QAAQ,GAAG,SAASA,QAAQA,CAACnC,IAAI,EAAE;EAC5D,MAAMoC,GAAG,GAAG,IAAI,CAACP,QAAQ,CAACQ,MAAM,CAACf,EAAE,IAAIA,EAAE,CAACtB,IAAI,KAAKA,IAAI,CAAC;EACxD,IAAI,CAACoC,GAAG,CAACE,MAAM,EAAE;IACf,MAAM,IAAIvD,aAAa,CAAC,+BAA+BiB,IAAI,SAAS,CAAC;EACvE;EAEA,KAAK,MAAMsB,EAAE,IAAIc,GAAG,EAAE;IACpBd,EAAE,CAACT,YAAY,GAAG,IAAI;IACtBS,EAAE,CAACiB,cAAc,GAAG,IAAI;IACxBjB,EAAE,CAACV,WAAW,GAAG5B,MAAM,CAACwD,YAAY;IACpClB,EAAE,CAACmB,eAAe,GAAG,IAAI;EAC3B;EACA,OAAO,IAAI,CAACtC,UAAU,CAACH,IAAI,CAAC;EAC5B,IAAI,CAAC6B,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACQ,MAAM,CAACf,EAAE,IAAIA,EAAE,CAACtB,IAAI,KAAKA,IAAI,CAAC;AAC9D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAT,gBAAgB,CAACO,SAAS,CAAC4C,OAAO,GAAG,eAAeA,OAAOA,CAACC,KAAK,EAAE;EACjE,IAAI,IAAI,CAACtB,MAAM,IAAI,IAAI,EAAE;IACvB,OAAO,IAAI;EACb;EAEA,IAAIuB,eAAe,GAAG,KAAK;EAC3B,IAAID,KAAK,IAAI,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC9CC,eAAe,GAAGD,KAAK,CAACC,eAAe;IACvCD,KAAK,GAAGA,KAAK,CAACA,KAAK;EACrB;EAEA,IAAIC,eAAe,EAAE;IACnB,OAAO,IAAI;EACb;EAEA,MAAM,IAAI,CAACvB,MAAM,CAACwB,KAAK,CAACF,KAAK,CAAC;EAC9B;EACA;EACA;EACA;EACA,MAAM,IAAIG,OAAO,CAACC,OAAO,IAAI3D,UAAU,CAAC2D,OAAO,EAAE,CAAC,CAAC,CAAC;EAEpD,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEAxD,gBAAgB,CAACO,SAAS,CAACkD,aAAa,GAAG,eAAeA,aAAaA,CAAA,EAAG;EACxE,MAAM,IAAI,CAACC,eAAe,CAAC,CAAC;EAE5B,OAAO,MAAM,IAAI,CAAC3B,EAAE,CAAC4B,KAAK,CAAC,CAAC,CAACF,aAAa,CAAC,CAAC;AAC9C,CAAC;;AAED;AACA;AACA;;AAEAzD,gBAAgB,CAACO,SAAS,CAACqD,YAAY,GAAG,eAAeA,YAAYA,CAACC,GAAG,EAAEnD,OAAO,EAAE;EAClF,IAAI,OAAOmD,GAAG,KAAK,QAAQ,EAAE;IAC3B,MAAM,IAAIrE,aAAa,CAAC,+CAA+C,GACrE,gBAAgB,OAAOqE,GAAG,sCAAsC,GAChE,oEAAoE,CAAC;EACzE;EAEA,IAAI,IAAI,CAACb,cAAc,EAAE;IACvB,MAAM,IAAIxD,aAAa,CACrB,8FAA8F,GAC9F,4FACF,CAAC;EACH;EAEA,IAAI,IAAI,CAACsE,UAAU,KAAKrE,MAAM,CAACsE,UAAU,IAAI,IAAI,CAACD,UAAU,KAAKrE,MAAM,CAACuC,SAAS,EAAE;IACjF,IAAI,IAAI,CAACgC,iBAAiB,KAAKH,GAAG,EAAE;MAClC,MAAM,IAAIrE,aAAa,CAAC,uDAAuD,GAC7E,mFAAmF,GACnF,wFAAwF,CAAC;IAC7F;EACF;EAEAkB,OAAO,GAAGd,wBAAwB,CAACiE,GAAG,EAAEnD,OAAO,CAAC;EAEhD,IAAIA,OAAO,EAAE;IAEX,MAAMuD,SAAS,GAAGvD,OAAO,CAACS,MAAM,EAAE8C,SAAS,IAAIvD,OAAO,CAACuD,SAAS;IAChE,IAAIA,SAAS,IAAI,IAAI,EAAE;MACrB,IAAI,CAAC9C,MAAM,CAAC8C,SAAS,GAAGA,SAAS,KAAK,KAAK;MAC3C,OAAOvD,OAAO,CAACS,MAAM;MACrB,OAAOT,OAAO,CAACuD,SAAS;IAC1B;IAEA,IAAI,YAAY,IAAIvD,OAAO,EAAE;MAC3B,IAAI,CAACS,MAAM,CAAC+C,UAAU,GAAG,CAAC,CAACxD,OAAO,CAACwD,UAAU;MAC7C,OAAOxD,OAAO,CAACwD,UAAU;IAC3B;IAEA,IAAI,gBAAgB,IAAIxD,OAAO,EAAE;MAC/B,IAAI,CAACS,MAAM,CAACgD,cAAc,GAAGzD,OAAO,CAACyD,cAAc;MACnD,OAAOzD,OAAO,CAACyD,cAAc;IAC/B;IAEA,IAAI,iBAAiB,IAAIzD,OAAO,EAAE;MAChC,IAAI,CAACS,MAAM,CAACiD,eAAe,GAAG1D,OAAO,CAAC0D,eAAe;MACrD,OAAO1D,OAAO,CAAC0D,eAAe;IAChC;IAEA,IAAI,iBAAiB,IAAI1D,OAAO,EAAE;MAChC,IAAI,CAACS,MAAM,CAACkD,eAAe,GAAG3D,OAAO,CAAC2D,eAAe;MACrD,OAAO3D,OAAO,CAAC2D,eAAe;IAChC;;IAEA;IACA,IAAI3D,OAAO,CAACiB,IAAI,IAAIjB,OAAO,CAACkB,IAAI,EAAE;MAChClB,OAAO,CAAC4D,IAAI,GAAG5D,OAAO,CAAC4D,IAAI,IAAI,CAAC,CAAC;MACjC5D,OAAO,CAAC4D,IAAI,CAACC,QAAQ,GAAG7D,OAAO,CAACiB,IAAI;MACpCjB,OAAO,CAAC4D,IAAI,CAACE,QAAQ,GAAG9D,OAAO,CAACkB,IAAI;MAEpC,IAAI,CAACD,IAAI,GAAGjB,OAAO,CAACiB,IAAI;MACxB,IAAI,CAACC,IAAI,GAAGlB,OAAO,CAACkB,IAAI;IAC1B;IACA,OAAOlB,OAAO,CAACiB,IAAI;IACnB,OAAOjB,OAAO,CAACkB,IAAI;IAEnB,IAAIlB,OAAO,CAAC+D,cAAc,IAAI,IAAI,EAAE;MAClC,IAAI,CAACtD,MAAM,CAACsD,cAAc,GAAG/D,OAAO,CAAC+D,cAAc;MACnD,OAAO/D,OAAO,CAAC+D,cAAc;IAC/B;EACF,CAAC,MAAM;IACL/D,OAAO,GAAG,CAAC,CAAC;EACd;EAEA,IAAI,CAACgE,kBAAkB,GAAGhE,OAAO;EACjC,MAAMiE,MAAM,GAAGjE,OAAO,CAACiE,MAAM;EAC7B,IAAIA,MAAM,IAAI,IAAI,EAAE;IAClB,IAAI,CAACC,OAAO,GAAGD,MAAM;EACvB;EACA,OAAOjE,OAAO,CAACiE,MAAM;EAErB,IAAI,CAAC7E,KAAK,CAAC+E,sBAAsB,CAACnE,OAAO,EAAE,YAAY,CAAC,EAAE;IACxDA,OAAO,CAACoE,UAAU,GAAG;MACnBrE,IAAI,EAAE,UAAU;MAChBsE,OAAO,EAAEpF,GAAG,CAACoF;IACf,CAAC;EACH;EAEA,MAAM;IAAEC,SAAS;IAAEC;EAAmB,CAAC,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;EAExE,IAAI,CAACpF,KAAK,CAACqF,UAAU,CAACH,SAAS,CAAC,IAAIlF,KAAK,CAACqF,UAAU,CAACF,kBAAkB,CAAC,KAAK,CAACvE,OAAO,CAAC0E,cAAc,EAAE;IACpG,MAAM,IAAIC,KAAK,CAAC,uEAAuE,CAAC;EAC1F;EAEA,IAAIvF,KAAK,CAACqF,UAAU,CAACH,SAAS,CAAC,EAAE;IAC/BtE,OAAO,CAAC0E,cAAc,CAACJ,SAAS,GAAGA,SAAS;EAC9C;EAEA,IAAIlF,KAAK,CAACqF,UAAU,CAACF,kBAAkB,CAAC,EAAE;IACxCvE,OAAO,CAAC0E,cAAc,CAACH,kBAAkB,GAAGA,kBAAkB;EAChE;EAEA,IAAI,CAACnB,UAAU,GAAGrE,MAAM,CAACsE,UAAU;EACnC,IAAI,CAACC,iBAAiB,GAAGH,GAAG;EAE5B,IAAI/B,MAAM;EACV,IAAI;IACFA,MAAM,GAAG,IAAIpC,OAAO,CAAC4F,WAAW,CAACzB,GAAG,EAAEnD,OAAO,CAAC;EAChD,CAAC,CAAC,OAAO6E,KAAK,EAAE;IACd,IAAI,CAACzB,UAAU,GAAGrE,MAAM,CAACwD,YAAY;IACrC,MAAMsC,KAAK;EACb;EACA,IAAI,CAACzD,MAAM,GAAGA,MAAM;EAEpBA,MAAM,CAAC0D,eAAe,CAAC,CAAC,CAAC;EACzB,MAAM1D,MAAM,CAAC2D,OAAO,CAAC,CAAC;EAEtBC,UAAU,CAAC,IAAI,EAAE5D,MAAM,EAAEpB,OAAO,EAAEiE,MAAM,CAAC;EAEzC,KAAK,MAAM5C,EAAE,IAAI,IAAI,CAACO,QAAQ,EAAE;IAC9BoD,UAAU,CAAC3D,EAAE,EAAED,MAAM,EAAE,CAAC,CAAC,EAAEC,EAAE,CAACtB,IAAI,CAAC;EACrC;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAT,gBAAgB,CAACO,SAAS,CAAC2E,uBAAuB,GAAG,YAAW;EAC9D,MAAMS,UAAU,GAAG,CAAC,CAAC;EACrB,MAAMC,aAAa,GAAG,CAAC,CAAC;EAExB,MAAMC,eAAe,GAAGxF,MAAM,CAACyF,MAAM,CAAC,IAAI,CAAC7E,MAAM,CAAC,CAAC6B,MAAM,CAACiD,KAAK,IAAIA,KAAK,CAACC,MAAM,CAACC,mBAAmB,CAAC,CAAC,CAAC;;EAEtG;EACA;EACA;EACA,KAAK,MAAMF,KAAK,IAAIF,eAAe,EAAE;IACnC,MAAM;MAAEG,MAAM;MAAEE,UAAU,EAAE;QAAEC;MAAe;IAAE,CAAC,GAAGJ,KAAK;IACxD,MAAMK,SAAS,GAAG,GAAG,IAAI,CAACxB,OAAO,IAAIuB,cAAc,EAAE;IACrD,MAAME,QAAQ,GAAGL,MAAM,CAACM,cAAc,CAAC,CAAC,KAAK,OAAO,GAAGV,aAAa,GAAGD,UAAU;IAEjFU,QAAQ,CAACD,SAAS,CAAC,KAAK,IAAIrG,MAAM,CAAC,CAAC,CAAC,EAAE;MAAEuG,cAAc,EAAEN,MAAM,CAACM,cAAc,CAAC;IAAE,CAAC,CAAC;IAEnF,MAAMC,sBAAsB,GAAGP,MAAM,CAACQ,oBAAoB,IAAI,CAACR,MAAM,CAACQ,oBAAoB,CAACC,MAAM;IACjG,IAAIF,sBAAsB,EAAE;MAC1B,MAAMG,UAAU,GAAGV,MAAM,CAACW,WAAW;MACrCX,MAAM,CAACY,QAAQ,CAAEC,QAAQ,IAAK;QAC5B,IAAIH,UAAU,CAACI,IAAI,CAACD,QAAQ,CAAC,EAAE;QAC/B,IAAI,CAACR,QAAQ,CAACD,SAAS,CAAC,CAACW,kBAAkB,CAACF,QAAQ,CAAC,EAAE;QAEvD,MAAM,IAAIxB,KAAK,CAAC,qEAAqEwB,QAAQ,EAAE,CAAC;MAClG,CAAC,CAAC;IACJ;IAEAR,QAAQ,CAACD,SAAS,CAAC,CAACY,GAAG,CAAChB,MAAM,CAAC;EACjC;EAEA,MAAMhB,SAAS,GAAG3E,MAAM,CAAC4G,WAAW,CAAC5G,MAAM,CAAC6G,OAAO,CAACtB,aAAa,CAAC,CAACuB,GAAG,CACpE,CAAC,CAACf,SAAS,EAAEJ,MAAM,CAAC,KAAM,CAACI,SAAS,EAAEJ,MAAM,CAACoB,eAAe,CAAC,CAAC,CAChE,CAAC,CAAC;EAEF,MAAMnC,kBAAkB,GAAG5E,MAAM,CAAC4G,WAAW,CAAC5G,MAAM,CAAC6G,OAAO,CAACvB,UAAU,CAAC,CAACwB,GAAG,CAC1E,CAAC,CAACf,SAAS,EAAEJ,MAAM,CAAC,KAAM,CAACI,SAAS,EAAEJ,MAAM,CAACqB,qBAAqB,CAAC,CAAC,CACtE,CAAC,CAAC;EAEF,OAAO;IACLrC,SAAS;IAAEC;EACb,CAAC;AACH,CAAC;;AAED;AACA;AACA;;AAEAjF,gBAAgB,CAACO,SAAS,CAAC+G,SAAS,GAAG,SAASA,SAASA,CAACxF,MAAM,EAAE;EAChE,IAAI,EAAEA,MAAM,YAAYpC,OAAO,CAAC4F,WAAW,CAAC,EAAE;IAC5C,MAAM,IAAI9F,aAAa,CAAC,yDAAyD,CAAC;EACpF;EACA,IAAI,IAAI,CAACsE,UAAU,KAAKrE,MAAM,CAACwD,YAAY,EAAE;IAC3C,MAAM,IAAIzD,aAAa,CAAC,sEAAsE,CAAC;EACjG;EACA,IAAIsC,MAAM,CAACyF,QAAQ,IAAI,IAAI,EAAE;IAC3B,MAAM,IAAI/H,aAAa,CAAC,2FAA2F,CAAC;EACtH;EAEA,IAAI,CAACwE,iBAAiB,GAAGlC,MAAM,CAAC0F,CAAC,CAACC,GAAG;EACrC/B,UAAU,CAAC,IAAI,EAAE5D,MAAM,EAAE,CAAC,CAAC,EAAEA,MAAM,CAAC0F,CAAC,CAAC9G,OAAO,CAACiE,MAAM,CAAC;EAErD,KAAK,MAAMoB,KAAK,IAAI1F,MAAM,CAACyF,MAAM,CAAC,IAAI,CAAC7E,MAAM,CAAC,EAAE;IAC9C;IACA8E,KAAK,CAAC2B,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,SAASC,cAAcA,CAAA,EAAG,CAAC,CAAC,CAAC;EAClD;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;;AAEA,SAASlC,UAAUA,CAACmC,IAAI,EAAE/F,MAAM,EAAEpB,OAAO,EAAEiE,MAAM,EAAE;EACjD,MAAM5C,EAAE,GAAG4C,MAAM,IAAI,IAAI,GAAG7C,MAAM,CAACC,EAAE,CAAC4C,MAAM,CAAC,GAAG7C,MAAM,CAACC,EAAE,CAAC,CAAC;EAC3D8F,IAAI,CAAC9F,EAAE,GAAGA,EAAE;EACZ8F,IAAI,CAAC/F,MAAM,GAAGA,MAAM;EACpB+F,IAAI,CAACpG,IAAI,GAAGK,MAAM,EAAE0F,CAAC,EAAE9G,OAAO,EAAEoH,KAAK,GAAG,CAAC,CAAC,EAAErG,IAAI;EAChDoG,IAAI,CAACnG,IAAI,GAAGI,MAAM,EAAE0F,CAAC,EAAE9G,OAAO,EAAEoH,KAAK,GAAG,CAAC,CAAC,EAAEpG,IAAI;EAChDmG,IAAI,CAACpH,IAAI,GAAGkE,MAAM,IAAI,IAAI,GAAGA,MAAM,GAAG5C,EAAE,CAACgG,YAAY;EACrDF,IAAI,CAACvG,YAAY,GAAGQ,MAAM,CAACR,YAAY;EAEvC,MAAM0G,gBAAgB,GAAGA,CAAA,KAAM;IAC7B;IACA;IACA;IACA;IACA,IAAIH,IAAI,CAAC/D,UAAU,KAAKrE,MAAM,CAACuC,SAAS,EAAE;MACxC6F,IAAI,CAAC/D,UAAU,GAAGrE,MAAM,CAACuC,SAAS;MAClC6F,IAAI,CAACI,IAAI,CAAC,WAAW,CAAC;MACtBJ,IAAI,CAACI,IAAI,CAAC,aAAa,CAAC;MACxBJ,IAAI,CAACxF,MAAM,CAAC,CAAC;IACf;EACF,CAAC;EAED,MAAM6F,IAAI,GAAGpG,MAAM,EAAEyF,QAAQ,EAAEY,WAAW,EAAED,IAAI,IAAI,EAAE;EAEtD,IAAIA,IAAI,KAAK,QAAQ,EAAE;IACrBpG,MAAM,CAACsG,EAAE,CAAC,0BAA0B,EAAEC,EAAE,IAAI;MAC1C,MAAMC,cAAc,GAAGD,EAAE,CAACC,cAAc;MACxC,IAAIA,cAAc,CAACJ,IAAI,KAAK,SAAS,EAAE;QACrCL,IAAI,CAAC/D,UAAU,GAAGrE,MAAM,CAACwD,YAAY;MACvC,CAAC,MAAM;QACL+E,gBAAgB,CAAC,CAAC;MACpB;IACF,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIE,IAAI,CAACK,UAAU,CAAC,YAAY,CAAC,EAAE;IACxCzG,MAAM,CAACsG,EAAE,CAAC,4BAA4B,EAAEC,EAAE,IAAI;MAC5C;MACA,MAAMF,WAAW,GAAGE,EAAE,CAACC,cAAc;MACrC,IAAIT,IAAI,CAAC/D,UAAU,KAAKrE,MAAM,CAACuC,SAAS,IAAImG,WAAW,CAACD,IAAI,KAAK,uBAAuB,EAAE;QACxF;QACAL,IAAI,CAAC/D,UAAU,GAAGrE,MAAM,CAACwD,YAAY;MACvC,CAAC,MAAM,IAAI4E,IAAI,CAAC/D,UAAU,KAAKrE,MAAM,CAACwD,YAAY,IAAIkF,WAAW,CAACD,IAAI,KAAK,uBAAuB,EAAE;QAClGF,gBAAgB,CAAC,CAAC;MACpB;IACF,CAAC,CAAC;EACJ;EAEAH,IAAI,CAACzH,gBAAgB,GAAG,IAAI;EAE5B0B,MAAM,CAACsG,EAAE,CAAC,0BAA0B,EAAE,MAAM;IAC1CP,IAAI,CAACzH,gBAAgB,GAAGoI,IAAI,CAACC,GAAG,CAAC,CAAC;IAClC,KAAK,MAAMC,OAAO,IAAIb,IAAI,CAACvF,QAAQ,EAAE;MACnCoG,OAAO,CAACtI,gBAAgB,GAAGyH,IAAI,CAACzH,gBAAgB;IAClD;EACF,CAAC,CAAC;EAEF,IAAIM,OAAO,CAACiI,eAAe,EAAE;IAC3B7G,MAAM,CAACsG,EAAE,CAAC,gBAAgB,EAAGQ,IAAI,IAAKf,IAAI,CAACI,IAAI,CAAC,gBAAgB,EAAEW,IAAI,CAAC,CAAC;IACxE9G,MAAM,CAACsG,EAAE,CAAC,eAAe,EAAGQ,IAAI,IAAKf,IAAI,CAACI,IAAI,CAAC,eAAe,EAAEW,IAAI,CAAC,CAAC;IACtE9G,MAAM,CAACsG,EAAE,CAAC,kBAAkB,EAAGQ,IAAI,IAAKf,IAAI,CAACI,IAAI,CAAC,kBAAkB,EAAEW,IAAI,CAAC,CAAC;EAC9E;EAEAf,IAAI,CAACxF,MAAM,CAAC,CAAC;EAEb,KAAK,MAAMwG,CAAC,IAAIhB,IAAI,CAAC7G,WAAW,EAAE;IAChC,IAAIX,MAAM,CAACyI,MAAM,CAACjB,IAAI,CAAC7G,WAAW,EAAE6H,CAAC,CAAC,EAAE;MACtChB,IAAI,CAAC7G,WAAW,CAAC6H,CAAC,CAAC,CAACxG,MAAM,CAAC,CAAC;IAC9B;EACF;AACF;;AAEA;AACA;AACA;;AAEA0G,MAAM,CAACC,OAAO,GAAGhJ,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}