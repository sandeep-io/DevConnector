{"ast":null,"code":"'use strict';\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst sessionNewDocuments = require('../helpers/symbols').sessionNewDocuments;\nconst utils = require('../utils');\nmodule.exports = function trackTransaction(schema) {\n  schema.pre('save', function trackTransactionPreSave() {\n    const session = this.$session();\n    if (session == null) {\n      return;\n    }\n    if (session.transaction == null || session[sessionNewDocuments] == null) {\n      return;\n    }\n    if (!session[sessionNewDocuments].has(this)) {\n      const initialState = {};\n      if (this.isNew) {\n        initialState.isNew = true;\n      }\n      if (this.$__schema.options.versionKey) {\n        initialState.versionKey = this.get(this.$__schema.options.versionKey);\n      }\n      initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths('modify')));\n      initialState.atomics = _getAtomics(this);\n      session[sessionNewDocuments].set(this, initialState);\n    }\n  });\n};\nfunction _getAtomics(doc, previous) {\n  const pathToAtomics = new Map();\n  previous = previous || new Map();\n  const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));\n  for (const path of pathsToCheck) {\n    const val = doc.$__getValue(path);\n    if (Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length && val[arrayAtomicsSymbol] != null && utils.hasOwnKeys(val[arrayAtomicsSymbol])) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n  const dirty = doc.$__dirty();\n  for (const dirt of dirty) {\n    const path = dirt.path;\n    const val = dirt.value;\n    if (val?.[arrayAtomicsSymbol] != null && utils.hasOwnKeys(val[arrayAtomicsSymbol])) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n  return pathToAtomics;\n}\nfunction mergeAtomics(destination, source) {\n  destination = destination || {};\n  if (source.$pullAll != null) {\n    destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);\n  }\n  if (source.$push != null) {\n    destination.$push = destination.$push || {};\n    destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);\n  }\n  if (source.$addToSet != null) {\n    destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);\n  }\n  if (source.$set != null) {\n    destination.$set = Array.isArray(source.$set) ? [...source.$set] : Object.assign({}, source.$set);\n  }\n  return destination;\n}","map":{"version":3,"names":["arrayAtomicsSymbol","require","sessionNewDocuments","utils","module","exports","trackTransaction","schema","pre","trackTransactionPreSave","session","$session","transaction","has","initialState","isNew","$__schema","options","versionKey","get","modifiedPaths","Set","Object","keys","$__","activePaths","getStatePaths","atomics","_getAtomics","set","doc","previous","pathToAtomics","Map","pathsToCheck","init","concat","modify","path","val","$__getValue","Array","isArray","isMongooseDocumentArray","length","hasOwnKeys","existing","mergeAtomics","dirty","$__dirty","dirt","value","destination","source","$pullAll","$push","$each","$addToSet","$set","assign"],"sources":["C:/DEVC/node_modules/mongoose/lib/plugins/trackTransaction.js"],"sourcesContent":["'use strict';\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst sessionNewDocuments = require('../helpers/symbols').sessionNewDocuments;\nconst utils = require('../utils');\n\nmodule.exports = function trackTransaction(schema) {\n  schema.pre('save', function trackTransactionPreSave() {\n    const session = this.$session();\n    if (session == null) {\n      return;\n    }\n    if (session.transaction == null || session[sessionNewDocuments] == null) {\n      return;\n    }\n\n    if (!session[sessionNewDocuments].has(this)) {\n      const initialState = {};\n      if (this.isNew) {\n        initialState.isNew = true;\n      }\n      if (this.$__schema.options.versionKey) {\n        initialState.versionKey = this.get(this.$__schema.options.versionKey);\n      }\n\n      initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths('modify')));\n      initialState.atomics = _getAtomics(this);\n\n      session[sessionNewDocuments].set(this, initialState);\n    }\n  });\n};\n\nfunction _getAtomics(doc, previous) {\n  const pathToAtomics = new Map();\n  previous = previous || new Map();\n\n  const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));\n\n  for (const path of pathsToCheck) {\n    const val = doc.$__getValue(path);\n    if (Array.isArray(val) &&\n        utils.isMongooseDocumentArray(val) &&\n        val.length &&\n        val[arrayAtomicsSymbol] != null &&\n        utils.hasOwnKeys(val[arrayAtomicsSymbol])) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  const dirty = doc.$__dirty();\n  for (const dirt of dirty) {\n    const path = dirt.path;\n\n    const val = dirt.value;\n    if (val?.[arrayAtomicsSymbol] != null && utils.hasOwnKeys(val[arrayAtomicsSymbol])) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  return pathToAtomics;\n}\n\nfunction mergeAtomics(destination, source) {\n  destination = destination || {};\n\n  if (source.$pullAll != null) {\n    destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);\n  }\n  if (source.$push != null) {\n    destination.$push = destination.$push || {};\n    destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);\n  }\n  if (source.$addToSet != null) {\n    destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);\n  }\n  if (source.$set != null) {\n    destination.$set = Array.isArray(source.$set) ? [...source.$set] : Object.assign({}, source.$set);\n  }\n\n  return destination;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}