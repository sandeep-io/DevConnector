{"ast":null,"code":"'use strict';\n\nconst StrictModeError = require('../../error/strict');\n\n/**\n * Handle immutable option for a given path when casting updates based on options\n *\n * @param {SchemaType} schematype the resolved schematype for this path\n * @param {Boolean | 'throw' | null} strict whether strict mode is set for this query\n * @param {Object} obj the object containing the value being checked so we can delete\n * @param {String} key the key in `obj` which we are checking for immutability\n * @param {String} fullPath the full path being checked\n * @param {Object} options the query options\n * @param {Query} ctx the query. Passed as `this` and first param to the `immutable` option, if `immutable` is a function\n * @returns true if field was removed, false otherwise\n */\n\nmodule.exports = function handleImmutable(schematype, strict, obj, key, fullPath, options, ctx) {\n  if (!schematype?.options?.immutable) {\n    return false;\n  }\n  let immutable = schematype.options.immutable;\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n  if (!immutable) {\n    return false;\n  }\n  if (options?.overwriteImmutable) {\n    return false;\n  }\n  if (strict === false) {\n    return false;\n  }\n  if (strict === 'throw') {\n    throw new StrictModeError(null, `Field ${fullPath} is immutable and strict = 'throw'`);\n  }\n  delete obj[key];\n  return true;\n};","map":{"version":3,"names":["StrictModeError","require","module","exports","handleImmutable","schematype","strict","obj","key","fullPath","options","ctx","immutable","call","overwriteImmutable"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/query/handleImmutable.js"],"sourcesContent":["'use strict';\n\nconst StrictModeError = require('../../error/strict');\n\n/**\n * Handle immutable option for a given path when casting updates based on options\n *\n * @param {SchemaType} schematype the resolved schematype for this path\n * @param {Boolean | 'throw' | null} strict whether strict mode is set for this query\n * @param {Object} obj the object containing the value being checked so we can delete\n * @param {String} key the key in `obj` which we are checking for immutability\n * @param {String} fullPath the full path being checked\n * @param {Object} options the query options\n * @param {Query} ctx the query. Passed as `this` and first param to the `immutable` option, if `immutable` is a function\n * @returns true if field was removed, false otherwise\n */\n\nmodule.exports = function handleImmutable(schematype, strict, obj, key, fullPath, options, ctx) {\n  if (!schematype?.options?.immutable) {\n    return false;\n  }\n  let immutable = schematype.options.immutable;\n\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n  if (!immutable) {\n    return false;\n  }\n\n  if (options?.overwriteImmutable) {\n    return false;\n  }\n  if (strict === false) {\n    return false;\n  }\n  if (strict === 'throw') {\n    throw new StrictModeError(null,\n      `Field ${fullPath} is immutable and strict = 'throw'`);\n  }\n\n  delete obj[key];\n  return true;\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,eAAe,GAAGC,OAAO,CAAC,oBAAoB,CAAC;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAG,SAASC,eAAeA,CAACC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,GAAG,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,GAAG,EAAE;EAC9F,IAAI,CAACN,UAAU,EAAEK,OAAO,EAAEE,SAAS,EAAE;IACnC,OAAO,KAAK;EACd;EACA,IAAIA,SAAS,GAAGP,UAAU,CAACK,OAAO,CAACE,SAAS;EAE5C,IAAI,OAAOA,SAAS,KAAK,UAAU,EAAE;IACnCA,SAAS,GAAGA,SAAS,CAACC,IAAI,CAACF,GAAG,EAAEA,GAAG,CAAC;EACtC;EACA,IAAI,CAACC,SAAS,EAAE;IACd,OAAO,KAAK;EACd;EAEA,IAAIF,OAAO,EAAEI,kBAAkB,EAAE;IAC/B,OAAO,KAAK;EACd;EACA,IAAIR,MAAM,KAAK,KAAK,EAAE;IACpB,OAAO,KAAK;EACd;EACA,IAAIA,MAAM,KAAK,OAAO,EAAE;IACtB,MAAM,IAAIN,eAAe,CAAC,IAAI,EAC5B,SAASS,QAAQ,oCAAoC,CAAC;EAC1D;EAEA,OAAOF,GAAG,CAACC,GAAG,CAAC;EACf,OAAO,IAAI;AACb,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}