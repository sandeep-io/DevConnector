{"ast":null,"code":"'use strict';\n\n/*!\n * ignore\n */\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = ['deleteOne', 'remove', 'save', 'updateOne', 'validate', 'init'];\n\n/*!\n * ignore\n */\n\nconst alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(fn => [fn, `$__${fn}`]));\n\n/**\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} options\n * @api private\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    let type = schema.paths[key];\n    let childModel = null;\n    const result = findChildModel(type);\n    if (result) {\n      childModel = result.childModel;\n      type = result.type;\n    } else {\n      continue;\n    }\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n    applyHooks(childModel, type.schema, {\n      ...options,\n      decorateDoc: false,\n      isChildSchema: true\n    });\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key], childModel.discriminators[key].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema._getDocumentMiddleware();\n  model._middleware = middleware;\n  objToDecorate.$__init = middleware.createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (alreadyHookedFunctions.has(method)) {\n      continue;\n    }\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[`$__${method}`] = objToDecorate[method];\n    objToDecorate[method] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}\n\n/**\n * Check if there is an embedded schematype in the given schematype. Handles drilling down into primitive\n * arrays and maps in case of array of array of subdocs or map of subdocs.\n *\n * @param {SchemaType} curType\n * @returns {{ childModel: Model | typeof Subdocument, curType: SchemaType } | null}\n */\n\nfunction findChildModel(curType) {\n  if (curType.$isSingleNested || curType.$isMongooseDocumentArray) {\n    return {\n      childModel: curType.Constructor,\n      type: curType\n    };\n  }\n  if (curType.instance === 'Array') {\n    const embedded = curType.getEmbeddedSchemaType();\n    if (embedded) {\n      return findChildModel(embedded);\n    }\n  }\n  if (curType.instance === 'Map') {\n    const mapType = curType.getEmbeddedSchemaType();\n    if (mapType) {\n      return findChildModel(mapType);\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["module","exports","applyHooks","middlewareFunctions","alreadyHookedFunctions","Set","flatMap","fn","model","schema","options","kareemOptions","useErrorHandlers","numCallbackParams","nullResultByDefault","contextParameter","objToDecorate","decorateDoc","prototype","$appliedHooks","key","Object","keys","paths","type","childModel","result","findChildModel","isChildSchema","discriminators","middleware","_getDocumentMiddleware","_middleware","$__init","createWrapperSync","customMethods","methods","customMethodOptions","assign","checkForPromise","method","has","hasHooks","originalMethod","createWrapper","curType","$isSingleNested","$isMongooseDocumentArray","Constructor","instance","embedded","getEmbeddedSchemaType","mapType"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/model/applyHooks.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = [\n  'deleteOne',\n  'remove',\n  'save',\n  'updateOne',\n  'validate',\n  'init'\n];\n\n/*!\n * ignore\n */\n\nconst alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(fn => ([fn, `$__${fn}`])));\n\n/**\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} options\n * @api private\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    let type = schema.paths[key];\n    let childModel = null;\n\n    const result = findChildModel(type);\n    if (result) {\n      childModel = result.childModel;\n      type = result.type;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, {\n      ...options,\n      decorateDoc: false,\n      isChildSchema: true\n    });\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key],\n          childModel.discriminators[key].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema._getDocumentMiddleware();\n\n  model._middleware = middleware;\n\n  objToDecorate.$__init = middleware.\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (alreadyHookedFunctions.has(method)) {\n      continue;\n    }\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[`$__${method}`] = objToDecorate[method];\n    objToDecorate[method] = middleware.\n      createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}\n\n/**\n * Check if there is an embedded schematype in the given schematype. Handles drilling down into primitive\n * arrays and maps in case of array of array of subdocs or map of subdocs.\n *\n * @param {SchemaType} curType\n * @returns {{ childModel: Model | typeof Subdocument, curType: SchemaType } | null}\n */\n\nfunction findChildModel(curType) {\n  if (curType.$isSingleNested || curType.$isMongooseDocumentArray) {\n    return { childModel: curType.Constructor, type: curType };\n  }\n  if (curType.instance === 'Array') {\n    const embedded = curType.getEmbeddedSchemaType();\n    if (embedded) {\n      return findChildModel(embedded);\n    }\n  }\n  if (curType.instance === 'Map') {\n    const mapType = curType.getEmbeddedSchemaType();\n    if (mapType) {\n      return findChildModel(mapType);\n    }\n  }\n  return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}