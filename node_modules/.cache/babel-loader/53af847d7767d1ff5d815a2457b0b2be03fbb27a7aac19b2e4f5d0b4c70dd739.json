{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst CastError = require('../error/cast');\nconst DocumentArrayElement = require('./documentArrayElement');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaArray = require('./array');\nconst SchemaDocumentArrayOptions = require('../options/schemaDocumentArrayOptions');\nconst SchemaType = require('../schemaType');\nconst cast = require('../cast');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst discriminator = require('../helpers/model/discriminator');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst isOperator = require('../helpers/query/isOperator');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @param {Schema} parentSchema\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions, parentSchema) {\n  if (schema.options?.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions?._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n  if (schemaOptions?._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options?._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n  const Constructor = _createConstructor(schema, options);\n  Constructor.prototype.$basePath = key;\n  Constructor.path = key;\n  const $parentSchemaType = this;\n  const embeddedSchemaType = new DocumentArrayElement(key + '.$', schema, {\n    ...(schemaOptions || {}),\n    $parentSchemaType,\n    Constructor\n  });\n  SchemaArray.call(this, key, embeddedSchemaType, options, null, parentSchema);\n  this.schema = schema;\n  // EmbeddedDocument schematype options\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = Constructor;\n  Constructor.base = schema.base;\n  const fn = this.defaultValue;\n  if (!('defaultValue' in this) || fn != null) {\n    this.default(function () {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = {\n  castNonArrays: true\n};\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$size` is the function Mongoose calls to cast `$size` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaDocumentArray\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaDocumentArray.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: {\n    ...SchemaArray.prototype.$conditionalHandlers\n  }\n});\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/arraySubdocument'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n  schema._preCompile();\n  const proto = baseClass?.prototype ?? Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n  EmbeddedDocument.options = options;\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function (name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n  schema = discriminator(this.Constructor, name, schema, tiedValue, null, null, options?.overwriteExisting);\n  const EmbeddedDocument = _createConstructor(schema, null, this.Constructor);\n  EmbeddedDocument.baseCasterConstructor = this.Constructor;\n  Object.defineProperty(EmbeddedDocument, 'name', {\n    value: name\n  });\n  this.Constructor.discriminators[name] = EmbeddedDocument;\n  return this.Constructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api public\n */\n\nSchemaDocumentArray.prototype.doValidate = async function doValidate(array, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n  await SchemaType.prototype.doValidate.call(this, array, scope);\n  if (options?.updateValidator) {\n    return;\n  }\n  if (!utils.isMongooseDocumentArray(array)) {\n    array = new MongooseDocumentArray(array, this.path, scope);\n  }\n  const promises = [];\n  for (let i = 0; i < array.length; ++i) {\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n    let doc = array[i];\n    if (doc == null) {\n      continue;\n    }\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.Constructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n    if (options?.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n    promises.push(doc.$__validate(null, options));\n  }\n  await Promise.all(promises);\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function (array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n  const count = array?.length;\n  let resultError = null;\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.Constructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n    if (options?.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n    const subdocValidateError = doc.validateSync(options);\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function (scope, init, options) {\n  let ret = typeof this.defaultValue === 'function' ? this.defaultValue.call(scope) : this.defaultValue;\n  if (ret == null) {\n    return ret;\n  }\n  if (options?.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.Constructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined, undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n    ret[i] = _subdoc;\n  }\n  return ret;\n};\nconst _toObjectOptions = Object.freeze({\n  transform: false,\n  virtuals: false\n});\nconst initDocumentOptions = Object.freeze({\n  skipId: false,\n  willInit: true\n});\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value?.[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n  let selected;\n  let subdoc;\n  options = options || {};\n  const path = options.path || this.path;\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc, this);\n  }\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n    const Constructor = getConstructor(this.Constructor, rawArray[i]);\n    const spreadDoc = handleSpreadDoc(rawArray[i], true);\n    if (rawArray[i] !== spreadDoc) {\n      rawArray[i] = spreadDoc;\n    }\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i], options);\n      } else {\n        if (typeof prev?.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i], value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions, this.parentSchema);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  schematype._appliedDiscriminators = this._appliedDiscriminators;\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function (value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Handle casting $elemMatch operators\n */\n\nSchemaDocumentArray.prototype.$conditionalHandlers.$elemMatch = cast$elemMatch;\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this?.Constructor?.schema?.options?.discriminatorKey;\n  const discriminators = this?.Constructor?.schema?.discriminators || {};\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this?.$$context);\n  }\n  const schema = this.Constructor.schema ?? context.schema;\n  return cast(schema, val, null, this?.$$context);\n}\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaDocumentArray.prototype.toJSONSchema = function toJSONSchema(options) {\n  const itemsTypeDefinition = createJSONSchemaTypeDefinition('object', 'object', options?.useBsonType, false);\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return {\n    ...createJSONSchemaTypeDefinition('array', 'array', options?.useBsonType, isRequired),\n    items: {\n      ...itemsTypeDefinition,\n      ...this.schema.toJSONSchema(options)\n    }\n  };\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;","map":{"version":3,"names":["CastError","require","DocumentArrayElement","EventEmitter","SchemaArray","SchemaDocumentArrayOptions","SchemaType","cast","createJSONSchemaTypeDefinition","discriminator","handleIdOption","handleSpreadDoc","isOperator","utils","getConstructor","InvalidSchemaOptionError","arrayAtomicsSymbol","arrayPathSymbol","documentArrayParent","MongooseDocumentArray","Subdocument","SchemaDocumentArray","key","schema","options","schemaOptions","parentSchema","timeseries","schemaTypeIdOption","defaultOptions","_id","Constructor","_createConstructor","prototype","$basePath","path","$parentSchemaType","embeddedSchemaType","call","$isMongooseDocumentArray","base","fn","defaultValue","default","arr","Array","isArray","schemaName","castNonArrays","Object","create","constructor","OptionsConstructor","defineProperty","enumerable","value","$conditionalHandlers","baseClass","EmbeddedDocument","apply","arguments","__parentArray","getArrayParent","$session","_preCompile","proto","$__setSchema","$isArraySubdocument","events","i","methods","statics","name","getFunctionName","tiedValue","isPOJO","clone","instanceOfSchema","overwriteExisting","baseCasterConstructor","discriminators","doValidate","array","scope","updateValidator","isMongooseDocumentArray","promises","length","doc","undefined","validateModifiedOnly","$isModified","push","$__validate","Promise","all","doValidateSync","schemaTypeError","count","resultError","len","subdocValidateError","validateSync","getDefault","init","ret","skipCast","_subdoc","$init","isNew","assign","$__","activePaths","_toObjectOptions","freeze","transform","virtuals","initDocumentOptions","skipId","willInit","prev","selected","subdoc","markModified","skipDocumentArrayCast","arrayPathIndex","rawArray","__array","spreadDoc","__index","$setIndex","scopePaths","id","deepEqual","toObject","set","error","schematype","validators","slice","requiredValidator","_appliedDiscriminators","applyGetters","fields","keys","hasKeys","sub","startsWith","substring","setters","get","$elemMatch","cast$elemMatch","val","context","numKeys","castForQuery","discriminatorKey","$$context","toJSONSchema","itemsTypeDefinition","useBsonType","isRequired","required","items","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/schema/documentArray.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst DocumentArrayElement = require('./documentArrayElement');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaArray = require('./array');\nconst SchemaDocumentArrayOptions =\n  require('../options/schemaDocumentArrayOptions');\nconst SchemaType = require('../schemaType');\nconst cast = require('../cast');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst discriminator = require('../helpers/model/discriminator');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst isOperator = require('../helpers/query/isOperator');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @param {Schema} parentSchema\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions, parentSchema) {\n  if (schema.options?.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions?._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n\n  if (schemaOptions?._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options?._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const Constructor = _createConstructor(schema, options);\n  Constructor.prototype.$basePath = key;\n  Constructor.path = key;\n\n  const $parentSchemaType = this;\n  const embeddedSchemaType = new DocumentArrayElement(key + '.$', schema, {\n    ...(schemaOptions || {}),\n    $parentSchemaType,\n    Constructor\n  });\n\n  SchemaArray.call(this, key, embeddedSchemaType, options, null, parentSchema);\n\n  this.schema = schema;\n  // EmbeddedDocument schematype options\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = Constructor;\n\n  Constructor.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn != null) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = { castNonArrays: true };\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$size` is the function Mongoose calls to cast `$size` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaDocumentArray\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaDocumentArray.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: { ...SchemaArray.prototype.$conditionalHandlers }\n});\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/arraySubdocument'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass?.prototype ?? Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.Constructor, name, schema, tiedValue, null, null, options?.overwriteExisting);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.Constructor);\n  EmbeddedDocument.baseCasterConstructor = this.Constructor;\n\n  Object.defineProperty(EmbeddedDocument, 'name', {\n    value: name\n  });\n\n  this.Constructor.discriminators[name] = EmbeddedDocument;\n\n  return this.Constructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api public\n */\n\nSchemaDocumentArray.prototype.doValidate = async function doValidate(array, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  await SchemaType.prototype.doValidate.call(this, array, scope);\n  if (options?.updateValidator) {\n    return;\n  }\n  if (!utils.isMongooseDocumentArray(array)) {\n    array = new MongooseDocumentArray(array, this.path, scope);\n  }\n\n  const promises = [];\n  for (let i = 0; i < array.length; ++i) {\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n    let doc = array[i];\n    if (doc == null) {\n      continue;\n    }\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.Constructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options?.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    promises.push(doc.$__validate(null, options));\n  }\n\n  await Promise.all(promises);\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array?.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.Constructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options?.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync(options);\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function(scope, init, options) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  if (options?.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.Constructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({ transform: false, virtuals: false });\nconst initDocumentOptions = Object.freeze({ skipId: false, willInit: true });\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value?.[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n\n  options = options || {};\n\n  const path = options.path || this.path;\n\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc, this);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.Constructor, rawArray[i]);\n\n    const spreadDoc = handleSpreadDoc(rawArray[i], true);\n    if (rawArray[i] !== spreadDoc) {\n      rawArray[i] = spreadDoc;\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i], options);\n      } else {\n        if (typeof prev?.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i],\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(\n    this.path,\n    this.schema,\n    options,\n    this.schemaOptions,\n    this.parentSchema\n  );\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  schematype._appliedDiscriminators = this._appliedDiscriminators;\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\n\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Handle casting $elemMatch operators\n */\n\nSchemaDocumentArray.prototype.$conditionalHandlers.$elemMatch = cast$elemMatch;\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this?.Constructor?.schema?.options?.discriminatorKey;\n  const discriminators = this?.Constructor?.schema?.discriminators || {};\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this?.$$context);\n  }\n\n  const schema = this.Constructor.schema ?? context.schema;\n  return cast(schema, val, null, this?.$$context);\n}\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaDocumentArray.prototype.toJSONSchema = function toJSONSchema(options) {\n  const itemsTypeDefinition = createJSONSchemaTypeDefinition('object', 'object', options?.useBsonType, false);\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return {\n    ...createJSONSchemaTypeDefinition('array', 'array', options?.useBsonType, isRequired),\n    items: { ...itemsTypeDefinition, ...this.schema.toJSONSchema(options) }\n  };\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}