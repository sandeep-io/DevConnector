{"ast":null,"code":"'use strict';\n\n/*!\n * ignore\n */\nconst MongooseMap = require('../types/map');\nconst SchemaMapOptions = require('../options/schemaMapOptions');\nconst SchemaType = require('../schemaType');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst MongooseError = require('../error/mongooseError');\nconst Schema = require('../schema');\nconst utils = require('../utils');\nclass SchemaMap extends SchemaType {\n  /**\n   * Map SchemaType constructor.\n   *\n   * @param {String} path\n   * @param {Object} options\n   * @param {Object} schemaOptions\n   * @param {Schema} parentSchema\n   * @inherits SchemaType\n   * @api public\n   */\n\n  constructor(key, options, schemaOptions, parentSchema) {\n    super(key, options, 'Map', parentSchema);\n    this.$isSchemaMap = true;\n    // Create the nested schema type for the map values\n    this._createNestedSchemaType(parentSchema, key, options, schemaOptions);\n  }\n\n  /**\n   * Sets a default option for all Map instances.\n   *\n   * @param {String} option The option you'd like to set the value for\n   * @param {Any} value value for option\n   * @return {undefined}\n   * @function set\n   * @api public\n   */\n\n  set(option, value) {\n    return SchemaType.set(option, value);\n  }\n\n  /**\n   * Casts to Map\n   *\n   * @param {Object} value\n   * @param {Object} model this value is optional\n   * @api private\n   */\n\n  cast(val, doc, init, prev, options) {\n    if (val instanceof MongooseMap) {\n      return val;\n    }\n    const path = this.path;\n    if (init) {\n      const map = new MongooseMap({}, path, doc, this.$__schemaType, options);\n\n      // Use the map's path for passing to nested casts.\n      // If map's parent is a subdocument, use the relative path so nested casts get relative paths.\n      const mapPath = map.$__pathRelativeToParent != null ? map.$__pathRelativeToParent : map.$__path;\n      if (val instanceof global.Map) {\n        for (const key of val.keys()) {\n          let _val = val.get(key);\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, {\n              ...options,\n              path: mapPath + '.' + key\n            });\n          }\n          map.$init(key, _val);\n        }\n      } else {\n        for (const key of Object.keys(val)) {\n          let _val = val[key];\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, {\n              ...options,\n              path: mapPath + '.' + key\n            });\n          }\n          map.$init(key, _val);\n        }\n      }\n      return map;\n    }\n    return new MongooseMap(val, path, doc, this.$__schemaType, options);\n  }\n\n  /**\n   * Creates a copy of this map schema type.\n   *\n   * @api private\n   */\n\n  clone() {\n    const schematype = super.clone();\n    if (this.$__schemaType != null) {\n      schematype.$__schemaType = this.$__schemaType.clone();\n    }\n    return schematype;\n  }\n\n  /**\n   * Returns the embedded schema type (i.e. the `.$*` path)\n   *\n   * @api public\n   */\n\n  getEmbeddedSchemaType() {\n    return this.$__schemaType;\n  }\n\n  /**\n   * Returns this schema type's representation in a JSON schema.\n   *\n   * @param [options]\n   * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n   * @returns {Object} JSON schema properties\n   */\n\n  toJSONSchema(options) {\n    const useBsonType = options?.useBsonType;\n    const embeddedSchemaType = this.getEmbeddedSchemaType();\n    const isRequired = this.options.required && typeof this.options.required !== 'function';\n    const result = createJSONSchemaTypeDefinition('object', 'object', useBsonType, isRequired);\n    result.additionalProperties = embeddedSchemaType.toJSONSchema(options);\n    return result;\n  }\n\n  /**\n   * Returns the auto encryption type for this schema type.\n   *\n   * @api public\n   */\n\n  autoEncryptionType() {\n    return 'object';\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\nSchemaMap.schemaName = 'Map';\nSchemaMap.prototype.OptionsConstructor = SchemaMapOptions;\nSchemaMap.defaultOptions = {};\n\n/*!\n * ignore\n */\n\nSchemaMap.prototype._createNestedSchemaType = function _createNestedSchemaType(schema, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = {\n    type: {}\n  };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) && utils.hasOwnKeys(obj.of) && !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = {\n        [schema.options.typeKey]: new Schema(obj.of)\n      };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = {\n        [schema.options.typeKey]: obj.of\n      };\n    }\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  this.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n};\nmodule.exports = SchemaMap;","map":{"version":3,"names":["MongooseMap","require","SchemaMapOptions","SchemaType","createJSONSchemaTypeDefinition","MongooseError","Schema","utils","SchemaMap","constructor","key","options","schemaOptions","parentSchema","$isSchemaMap","_createNestedSchemaType","set","option","value","cast","val","doc","init","prev","path","map","$__schemaType","mapPath","$__pathRelativeToParent","$__path","global","Map","keys","_val","get","_castNullish","$init","Object","clone","schematype","getEmbeddedSchemaType","toJSONSchema","useBsonType","embeddedSchemaType","isRequired","required","result","additionalProperties","autoEncryptionType","schemaName","prototype","OptionsConstructor","defaultOptions","schema","obj","_mapType","type","hasUserDefinedProperty","isInlineSchema","isPOJO","of","hasOwnKeys","typeKey","assign","instanceOfSchema","subdocumentSchema","eachPath","subpath","select","ref","interpretAsType","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/schema/map.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst MongooseMap = require('../types/map');\nconst SchemaMapOptions = require('../options/schemaMapOptions');\nconst SchemaType = require('../schemaType');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst MongooseError = require('../error/mongooseError');\nconst Schema = require('../schema');\nconst utils = require('../utils');\n\nclass SchemaMap extends SchemaType {\n  /**\n   * Map SchemaType constructor.\n   *\n   * @param {String} path\n   * @param {Object} options\n   * @param {Object} schemaOptions\n   * @param {Schema} parentSchema\n   * @inherits SchemaType\n   * @api public\n   */\n\n  constructor(key, options, schemaOptions, parentSchema) {\n    super(key, options, 'Map', parentSchema);\n    this.$isSchemaMap = true;\n    // Create the nested schema type for the map values\n    this._createNestedSchemaType(parentSchema, key, options, schemaOptions);\n  }\n\n  /**\n   * Sets a default option for all Map instances.\n   *\n   * @param {String} option The option you'd like to set the value for\n   * @param {Any} value value for option\n   * @return {undefined}\n   * @function set\n   * @api public\n   */\n\n  set(option, value) {\n    return SchemaType.set(option, value);\n  }\n\n  /**\n   * Casts to Map\n   *\n   * @param {Object} value\n   * @param {Object} model this value is optional\n   * @api private\n   */\n\n  cast(val, doc, init, prev, options) {\n    if (val instanceof MongooseMap) {\n      return val;\n    }\n\n    const path = this.path;\n\n    if (init) {\n      const map = new MongooseMap({}, path, doc, this.$__schemaType, options);\n\n      // Use the map's path for passing to nested casts.\n      // If map's parent is a subdocument, use the relative path so nested casts get relative paths.\n      const mapPath = map.$__pathRelativeToParent != null ? map.$__pathRelativeToParent : map.$__path;\n\n      if (val instanceof global.Map) {\n        for (const key of val.keys()) {\n          let _val = val.get(key);\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { ...options, path: mapPath + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      } else {\n        for (const key of Object.keys(val)) {\n          let _val = val[key];\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { ...options, path: mapPath + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      }\n\n      return map;\n    }\n\n    return new MongooseMap(val, path, doc, this.$__schemaType, options);\n  }\n\n  /**\n   * Creates a copy of this map schema type.\n   *\n   * @api private\n   */\n\n  clone() {\n    const schematype = super.clone();\n\n    if (this.$__schemaType != null) {\n      schematype.$__schemaType = this.$__schemaType.clone();\n    }\n    return schematype;\n  }\n\n  /**\n   * Returns the embedded schema type (i.e. the `.$*` path)\n   *\n   * @api public\n   */\n\n  getEmbeddedSchemaType() {\n    return this.$__schemaType;\n  }\n\n  /**\n   * Returns this schema type's representation in a JSON schema.\n   *\n   * @param [options]\n   * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n   * @returns {Object} JSON schema properties\n   */\n\n  toJSONSchema(options) {\n    const useBsonType = options?.useBsonType;\n    const embeddedSchemaType = this.getEmbeddedSchemaType();\n\n    const isRequired = this.options.required && typeof this.options.required !== 'function';\n    const result = createJSONSchemaTypeDefinition('object', 'object', useBsonType, isRequired);\n    result.additionalProperties = embeddedSchemaType.toJSONSchema(options);\n\n    return result;\n  }\n\n  /**\n   * Returns the auto encryption type for this schema type.\n   *\n   * @api public\n   */\n\n  autoEncryptionType() {\n    return 'object';\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\nSchemaMap.schemaName = 'Map';\n\nSchemaMap.prototype.OptionsConstructor = SchemaMapOptions;\n\nSchemaMap.defaultOptions = {};\n\n/*!\n * ignore\n */\n\nSchemaMap.prototype._createNestedSchemaType = function _createNestedSchemaType(schema, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = { type: {} };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) &&\n      utils.hasOwnKeys(obj.of) &&\n      !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = { [schema.options.typeKey]: new Schema(obj.of) };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = { [schema.options.typeKey]: obj.of };\n    }\n\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  this.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n};\n\nmodule.exports = SchemaMap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}