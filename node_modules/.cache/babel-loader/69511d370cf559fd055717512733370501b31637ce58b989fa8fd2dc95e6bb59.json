{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../../error/mongooseError');\nconst isPathExcluded = require('../projection/isPathExcluded');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst util = require('util');\nconst utils = require('../../utils');\nconst hasNumericPropRE = /(\\.\\d+$|\\.\\d+\\.)/g;\nmodule.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {\n  if (refPath == null) {\n    return [];\n  }\n  if (typeof refPath === 'string' && queryProjection != null && isPathExcluded(queryProjection, refPath)) {\n    throw new MongooseError('refPath `' + refPath + '` must not be excluded in projection, got ' + util.inspect(queryProjection));\n  }\n\n  // If populated path has numerics, the end `refPath` should too. For example,\n  // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we\n  // should return `a.0.c` for the refPath.\n\n  if (hasNumericPropRE.test(populatedPath)) {\n    const chunks = populatedPath.split(hasNumericPropRE);\n    if (chunks[chunks.length - 1] === '') {\n      throw new Error('Can\\'t populate individual element in an array');\n    }\n    let _refPath = '';\n    let _remaining = refPath;\n    // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`\n    for (let i = 0; i < chunks.length; i += 2) {\n      const chunk = chunks[i];\n      if (_remaining.startsWith(chunk + '.')) {\n        _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];\n        _remaining = _remaining.substring(chunk.length + 1);\n      } else if (i === chunks.length - 1) {\n        _refPath += _remaining;\n        _remaining = '';\n        break;\n      } else {\n        throw new Error('Could not normalize ref path, chunk ' + chunk + ' not in populated path');\n      }\n    }\n    const refValue = mpath.get(_refPath, doc, lookupLocalFields);\n    let modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    modelNames = utils.array.flatten(modelNames);\n    return modelNames;\n  }\n  const refValue = mpath.get(refPath, doc, lookupLocalFields);\n  let modelNames;\n  if (modelSchema != null && Object.hasOwn(modelSchema.virtuals, refPath)) {\n    modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];\n  } else {\n    modelNames = Array.isArray(refValue) ? refValue : [refValue];\n  }\n  return modelNames;\n};","map":{"version":3,"names":["MongooseError","require","isPathExcluded","lookupLocalFields","mpath","util","utils","hasNumericPropRE","module","exports","modelNamesFromRefPath","refPath","doc","populatedPath","modelSchema","queryProjection","inspect","test","chunks","split","length","Error","_refPath","_remaining","i","chunk","startsWith","substring","refValue","get","modelNames","Array","isArray","array","flatten","Object","hasOwn","virtuals","applyGetters"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/mongooseError');\nconst isPathExcluded = require('../projection/isPathExcluded');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst util = require('util');\nconst utils = require('../../utils');\n\nconst hasNumericPropRE = /(\\.\\d+$|\\.\\d+\\.)/g;\n\nmodule.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {\n  if (refPath == null) {\n    return [];\n  }\n\n  if (typeof refPath === 'string' && queryProjection != null && isPathExcluded(queryProjection, refPath)) {\n    throw new MongooseError('refPath `' + refPath + '` must not be excluded in projection, got ' +\n      util.inspect(queryProjection));\n  }\n\n  // If populated path has numerics, the end `refPath` should too. For example,\n  // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we\n  // should return `a.0.c` for the refPath.\n\n  if (hasNumericPropRE.test(populatedPath)) {\n    const chunks = populatedPath.split(hasNumericPropRE);\n\n    if (chunks[chunks.length - 1] === '') {\n      throw new Error('Can\\'t populate individual element in an array');\n    }\n\n    let _refPath = '';\n    let _remaining = refPath;\n    // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`\n    for (let i = 0; i < chunks.length; i += 2) {\n      const chunk = chunks[i];\n      if (_remaining.startsWith(chunk + '.')) {\n        _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];\n        _remaining = _remaining.substring(chunk.length + 1);\n      } else if (i === chunks.length - 1) {\n        _refPath += _remaining;\n        _remaining = '';\n        break;\n      } else {\n        throw new Error('Could not normalize ref path, chunk ' + chunk + ' not in populated path');\n      }\n    }\n\n    const refValue = mpath.get(_refPath, doc, lookupLocalFields);\n    let modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    modelNames = utils.array.flatten(modelNames);\n    return modelNames;\n  }\n\n  const refValue = mpath.get(refPath, doc, lookupLocalFields);\n\n  let modelNames;\n  if (modelSchema != null && Object.hasOwn(modelSchema.virtuals, refPath)) {\n    modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];\n  } else {\n    modelNames = Array.isArray(refValue) ? refValue : [refValue];\n  }\n\n  return modelNames;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}