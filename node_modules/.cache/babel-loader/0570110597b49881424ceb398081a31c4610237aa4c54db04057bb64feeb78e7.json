{"ast":null,"code":"'use strict';\n\nconst Mixed = require('../../schema/mixed');\nconst applyBuiltinPlugins = require('../schema/applyBuiltinPlugins');\nconst clone = require('../clone');\nconst defineKey = require('../document/compile').defineKey;\nconst get = require('../get');\nconst utils = require('../../utils');\nconst mergeDiscriminatorSchema = require('../../helpers/discriminator/mergeDiscriminatorSchema');\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true,\n  virtuals: true,\n  methods: true,\n  statics: true\n};\n\n/**\n * Validate fields declared on the child schema when either schema is configured for encryption.  Specifically, this function ensures that:\n *\n * - any encrypted fields are declared on exactly one of the schemas (not both)\n * - encrypted fields cannot be declared on either the parent or child schema, where the other schema declares the same field without encryption.\n *\n * @param {Schema} parentSchema\n * @param {Schema} childSchema\n */\nfunction validateDiscriminatorSchemasForEncryption(parentSchema, childSchema) {\n  if (parentSchema.encryptionType() == null && childSchema.encryptionType() == null) return;\n  const allSharedNestedPaths = setIntersection(allNestedPaths(parentSchema), allNestedPaths(childSchema));\n  for (const path of allSharedNestedPaths) {\n    if (parentSchema._hasEncryptedField(path) && childSchema._hasEncryptedField(path)) {\n      throw new Error(`encrypted fields cannot be declared on both the base schema and the child schema in a discriminator. path=${path}`);\n    }\n    if (parentSchema._hasEncryptedField(path) || childSchema._hasEncryptedField(path)) {\n      throw new Error(`encrypted fields cannot have the same path as a non-encrypted field for discriminators. path=${path}`);\n    }\n  }\n  function allNestedPaths(schema) {\n    return [...Object.keys(schema.paths), ...Object.keys(schema.singleNestedPaths)];\n  }\n\n  /**\n   * @param {Iterable<string>} i1\n   * @param {Iterable<string>} i2\n   */\n  function* setIntersection(i1, i2) {\n    const s1 = new Set(i1);\n    for (const item of i2) {\n      if (s1.has(item)) {\n        yield item;\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks, overwriteExisting) {\n  if (!schema?.instanceOfSchema) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n  mergeHooks = mergeHooks == null ? true : mergeHooks;\n  if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name + '\" can only be a discriminator of the root model');\n  }\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base, 'options.applyPluginsToDiscriminators', false) || !mergeHooks;\n    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  } else if (!mergeHooks) {\n    applyBuiltinPlugins(schema);\n  }\n  const key = model.schema.options.discriminatorKey;\n  const existingPath = model.schema.path(key);\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey({\n      prop: key,\n      prototype: model.prototype,\n      options: model.schema.options\n    });\n  }\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name + '\" cannot have field with name \"' + key + '\"');\n  }\n  let value = name;\n  if (typeof tiedValue === 'string' && tiedValue.length || tiedValue != null) {\n    value = tiedValue;\n  }\n  validateDiscriminatorSchemasForEncryption(model.schema, schema);\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n    if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {\n      schema.remove('_id');\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n    for (const path of baseSchemaPaths) {\n      if (schema.nested[path]) {\n        conflictingPaths.push(path);\n        continue;\n      }\n      if (path.indexOf('.') === -1) {\n        continue;\n      }\n      const sp = path.split('.').slice(0, -1);\n      let cur = '';\n      for (const piece of sp) {\n        cur += (cur.length ? '.' : '') + piece;\n        if (schema.paths[cur] instanceof Mixed || schema.singleNestedPaths[cur] instanceof Mixed) {\n          conflictingPaths.push(path);\n        }\n      }\n    }\n\n    // Shallow clone `obj` so we can add additional properties without modifying original\n    // schema. `Schema.prototype.clone()` copies `obj` by reference, no cloning.\n    schema.obj = {\n      ...schema.obj\n    };\n    mergeDiscriminatorSchema(schema, baseSchema);\n    schema._gatherChildSchemas();\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (const conflictingPath of conflictingPaths) {\n      delete schema.paths[conflictingPath];\n    }\n\n    // Rebuild schema models because schemas may have been merged re: #7884\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function (newName) {\n        if (newName === value || Array.isArray(value) && utils.deepEqual(newName, value)) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;\n    schema.add(obj);\n    schema.discriminatorMapping = {\n      key: key,\n      value: value,\n      isRoot: false\n    };\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n    const userProvidedOptions = schema._userProvidedOptions;\n    for (const _key of keys) {\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        // Use `schema.options` in `deepEqual()` because of `discriminatorKey`\n        // set above. We don't allow customizing discriminator key, always\n        // overwrite. See gh-9238\n        if (_key in userProvidedOptions && !utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key + ' (can only modify ' + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') + ')');\n        }\n      }\n    }\n    schema.options = clone(baseSchema.options);\n    for (const _key of Object.keys(userProvidedOptions)) {\n      schema.options[_key] = userProvidedOptions[_key];\n    }\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    if (mergeHooks) {\n      schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    }\n    if (applyPlugins) {\n      schema.plugins = Array.prototype.slice.call(baseSchema.plugins);\n    }\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = {\n      key: key,\n      value: null,\n      isRoot: true\n    };\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n  model.schema.discriminators[name] = schema;\n  if (model.discriminators[name] && !schema.options.overwriteModels && !overwriteExisting) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n  return schema;\n};","map":{"version":3,"names":["Mixed","require","applyBuiltinPlugins","clone","defineKey","get","utils","mergeDiscriminatorSchema","CUSTOMIZABLE_DISCRIMINATOR_OPTIONS","toJSON","toObject","_id","id","virtuals","methods","statics","validateDiscriminatorSchemasForEncryption","parentSchema","childSchema","encryptionType","allSharedNestedPaths","setIntersection","allNestedPaths","path","_hasEncryptedField","Error","schema","Object","keys","paths","singleNestedPaths","i1","i2","s1","Set","item","has","module","exports","discriminator","model","name","tiedValue","applyPlugins","mergeHooks","overwriteExisting","instanceOfSchema","discriminatorMapping","isRoot","applyPluginsToDiscriminators","base","_applyPlugins","skipTopLevel","key","options","discriminatorKey","existingPath","hasUserDefinedProperty","select","$skipDiscriminatorCheck","baseSchemaAddition","default","typeKey","String","add","prop","prototype","value","length","merge","baseSchema","_baseSchema","auto","remove","baseSchemaPaths","conflictingPaths","nested","push","indexOf","sp","split","slice","cur","piece","obj","_gatherChildSchemas","conflictingPath","childSchemas","forEach","$__setSchema","set","newName","Array","isArray","deepEqual","collection","userProvidedOptions","_userProvidedOptions","_key","join","s","hooks","plugins","call","callQueue","concat","_requiredpaths","discriminators","overwriteModels"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/model/discriminator.js"],"sourcesContent":["'use strict';\n\nconst Mixed = require('../../schema/mixed');\nconst applyBuiltinPlugins = require('../schema/applyBuiltinPlugins');\nconst clone = require('../clone');\nconst defineKey = require('../document/compile').defineKey;\nconst get = require('../get');\nconst utils = require('../../utils');\nconst mergeDiscriminatorSchema = require('../../helpers/discriminator/mergeDiscriminatorSchema');\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true,\n  virtuals: true,\n  methods: true,\n  statics: true\n};\n\n/**\n * Validate fields declared on the child schema when either schema is configured for encryption.  Specifically, this function ensures that:\n *\n * - any encrypted fields are declared on exactly one of the schemas (not both)\n * - encrypted fields cannot be declared on either the parent or child schema, where the other schema declares the same field without encryption.\n *\n * @param {Schema} parentSchema\n * @param {Schema} childSchema\n */\nfunction validateDiscriminatorSchemasForEncryption(parentSchema, childSchema) {\n  if (parentSchema.encryptionType() == null && childSchema.encryptionType() == null) return;\n\n  const allSharedNestedPaths = setIntersection(\n    allNestedPaths(parentSchema),\n    allNestedPaths(childSchema)\n  );\n\n  for (const path of allSharedNestedPaths) {\n    if (parentSchema._hasEncryptedField(path) && childSchema._hasEncryptedField(path)) {\n      throw new Error(`encrypted fields cannot be declared on both the base schema and the child schema in a discriminator. path=${path}`);\n    }\n\n    if (parentSchema._hasEncryptedField(path) || childSchema._hasEncryptedField(path)) {\n      throw new Error(`encrypted fields cannot have the same path as a non-encrypted field for discriminators. path=${path}`);\n    }\n  }\n\n  function allNestedPaths(schema) {\n    return [...Object.keys(schema.paths), ...Object.keys(schema.singleNestedPaths)];\n  }\n\n  /**\n   * @param {Iterable<string>} i1\n   * @param {Iterable<string>} i2\n   */\n  function* setIntersection(i1, i2) {\n    const s1 = new Set(i1);\n    for (const item of i2) {\n      if (s1.has(item)) {\n        yield item;\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks, overwriteExisting) {\n  if (!schema?.instanceOfSchema) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  mergeHooks = mergeHooks == null ? true : mergeHooks;\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base,\n      'options.applyPluginsToDiscriminators', false) || !mergeHooks;\n    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  } else if (!mergeHooks) {\n    applyBuiltinPlugins(schema);\n  }\n\n  const key = model.schema.options.discriminatorKey;\n\n  const existingPath = model.schema.path(key);\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey({\n      prop: key,\n      prototype: model.prototype,\n      options: model.schema.options\n    });\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n  if ((typeof tiedValue === 'string' && tiedValue.length) || tiedValue != null) {\n    value = tiedValue;\n  }\n\n  validateDiscriminatorSchemasForEncryption(model.schema, schema);\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      schema.remove('_id');\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (const path of baseSchemaPaths) {\n      if (schema.nested[path]) {\n        conflictingPaths.push(path);\n        continue;\n      }\n\n      if (path.indexOf('.') === -1) {\n        continue;\n      }\n      const sp = path.split('.').slice(0, -1);\n      let cur = '';\n      for (const piece of sp) {\n        cur += (cur.length ? '.' : '') + piece;\n        if (schema.paths[cur] instanceof Mixed ||\n            schema.singleNestedPaths[cur] instanceof Mixed) {\n          conflictingPaths.push(path);\n        }\n      }\n    }\n\n    // Shallow clone `obj` so we can add additional properties without modifying original\n    // schema. `Schema.prototype.clone()` copies `obj` by reference, no cloning.\n    schema.obj = { ...schema.obj };\n    mergeDiscriminatorSchema(schema, baseSchema);\n    schema._gatherChildSchemas();\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (const conflictingPath of conflictingPaths) {\n      delete schema.paths[conflictingPath];\n    }\n\n    // Rebuild schema models because schemas may have been merged re: #7884\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function(newName) {\n        if (newName === value || (Array.isArray(value) && utils.deepEqual(newName, value))) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;\n    schema.add(obj);\n\n    schema.discriminatorMapping = { key: key, value: value, isRoot: false };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n    const userProvidedOptions = schema._userProvidedOptions;\n    for (const _key of keys) {\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        // Use `schema.options` in `deepEqual()` because of `discriminatorKey`\n        // set above. We don't allow customizing discriminator key, always\n        // overwrite. See gh-9238\n        if (_key in userProvidedOptions && !utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n            ' (can only modify ' +\n            Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n            ')');\n        }\n      }\n    }\n    schema.options = clone(baseSchema.options);\n\n    for (const _key of Object.keys(userProvidedOptions)) {\n      schema.options[_key] = userProvidedOptions[_key];\n    }\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    if (mergeHooks) {\n      schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    }\n    if (applyPlugins) {\n      schema.plugins = Array.prototype.slice.call(baseSchema.plugins);\n    }\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = { key: key, value: null, isRoot: true };\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name] && !schema.options.overwriteModels && !overwriteExisting) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}