{"ast":null,"code":"/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/index');\nconst SchemaDateOptions = require('../options/schemaDateOptions');\nconst SchemaType = require('../schemaType');\nconst castDate = require('../cast/date');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst getConstructorName = require('../helpers/getConstructorName');\nconst utils = require('../utils');\nconst CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @param {Object} schemaOptions\n * @param {Schema} parentSchema\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options, _schemaOptions, parentSchema) {\n  SchemaType.call(this, key, options, 'Date', parentSchema);\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\nSchemaDate.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\nSchemaDate.prototype.OptionsConstructor = SchemaDateOptions;\n\n/*!\n * ignore\n */\n\nSchemaDate._cast = castDate;\n\n/**\n * Sets a default option for all Date instances.\n *\n * #### Example:\n *\n *     // Make all dates have `required` of true by default.\n *     mongoose.Schema.Date.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Date }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDate.set = SchemaType.set;\nSchemaDate.setters = [];\n\n/**\n * Attaches a getter for all Date instances\n *\n * #### Example:\n *\n *     // Always convert Dates to string\n *     mongoose.Date.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({ date: { type: Date, default: () => new Date() } }));\n *     typeof (new Model({}).date); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to dates.\n *\n * #### Example:\n *\n *     // Mongoose converts empty string '' into `null` for date types. You\n *     // can create a custom caster to disable it.\n *     const original = mongoose.Schema.Types.Date.cast();\n *     mongoose.Schema.Types.Date.cast(v => {\n *       assert.ok(v !== '');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.Date.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaDate.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._defaultCaster = v => {\n  if (v != null && !(v instanceof Date)) {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [vercel](https://github.com/vercel/ms) allowing us to use a friendlier syntax:\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     const schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function (when) {\n  if (getConstructorName(this._index) !== 'Object') {\n    this._index = {};\n  }\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._checkRequired = v => v instanceof Date;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDate.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function (value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ? this.constructor.checkRequired() : SchemaDate.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ d: { type: Date, min: min })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.min = function (value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function (v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MIN}/, value === Date.now ? 'Date.now()' : value.toString());\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.minValidator = function (val) {\n        let _value = value;\n        if (typeof value === 'function' && value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const min = _value === Date.now ? _value() : _this.cast(_value);\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ d: { type: Date, max: max })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.max = function (value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function (v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MAX}/, value === Date.now ? 'Date.now()' : value.toString());\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function (val) {\n        let _value = value;\n        if (typeof _value === 'function' && _value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const max = _value === Date.now ? _value() : _this.cast(_value);\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function (value) {\n  let castDate;\n  if (typeof this._castFunction === 'function') {\n    castDate = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDate = this.constructor.cast();\n  } else {\n    castDate = SchemaDate.cast();\n  }\n  try {\n    return castDate(value);\n  } catch (error) {\n    throw new CastError('date', value, this.path, error, this);\n  }\n};\n\n/**\n * Date Query casting.\n *\n * @param {Any} val\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$gte` is the function Mongoose calls to cast `$gte` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaDate\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaDate.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function ($conditional, val, context) {\n  if ($conditional == null) {\n    try {\n      return this.applySetters(val, context);\n    } catch (err) {\n      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n        err.path = this.$fullPath;\n      }\n      throw err;\n    }\n  }\n  const handler = this.$conditionalHandlers[$conditional];\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n  return handler.call(this, val);\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaDate.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('string', 'date', options?.useBsonType, isRequired);\n};\nSchemaDate.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'date';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;","map":{"version":3,"names":["MongooseError","require","SchemaDateOptions","SchemaType","castDate","createJSONSchemaTypeDefinition","getConstructorName","utils","CastError","SchemaDate","key","options","_schemaOptions","parentSchema","call","schemaName","defaultOptions","prototype","Object","create","constructor","OptionsConstructor","_cast","set","setters","get","cast","caster","arguments","length","_defaultCaster","v","Date","Error","expires","when","_index","_checkRequired","checkRequired","value","doc","_isRef","min","message","minValidator","validators","filter","validator","msg","messages","replace","now","toString","_this","push","val","_value","valueOf","type","max","maxValidator","_castFunction","error","path","handleSingle","$conditionalHandlers","$gt","$gte","$lt","$lte","defineProperty","enumerable","castForQuery","$conditional","context","applySetters","err","$fullPath","handler","toJSONSchema","isRequired","required","useBsonType","autoEncryptionType","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/schema/date.js"],"sourcesContent":["/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/index');\nconst SchemaDateOptions = require('../options/schemaDateOptions');\nconst SchemaType = require('../schemaType');\nconst castDate = require('../cast/date');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst getConstructorName = require('../helpers/getConstructorName');\nconst utils = require('../utils');\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @param {Object} schemaOptions\n * @param {Schema} parentSchema\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options, _schemaOptions, parentSchema) {\n  SchemaType.call(this, key, options, 'Date', parentSchema);\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\nSchemaDate.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\nSchemaDate.prototype.OptionsConstructor = SchemaDateOptions;\n\n/*!\n * ignore\n */\n\nSchemaDate._cast = castDate;\n\n/**\n * Sets a default option for all Date instances.\n *\n * #### Example:\n *\n *     // Make all dates have `required` of true by default.\n *     mongoose.Schema.Date.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Date }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDate.set = SchemaType.set;\n\nSchemaDate.setters = [];\n\n/**\n * Attaches a getter for all Date instances\n *\n * #### Example:\n *\n *     // Always convert Dates to string\n *     mongoose.Date.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({ date: { type: Date, default: () => new Date() } }));\n *     typeof (new Model({}).date); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to dates.\n *\n * #### Example:\n *\n *     // Mongoose converts empty string '' into `null` for date types. You\n *     // can create a custom caster to disable it.\n *     const original = mongoose.Schema.Types.Date.cast();\n *     mongoose.Schema.Types.Date.cast(v => {\n *       assert.ok(v !== '');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.Date.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaDate.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._defaultCaster = v => {\n  if (v != null && !(v instanceof Date)) {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [vercel](https://github.com/vercel/ms) allowing us to use a friendlier syntax:\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     const schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (getConstructorName(this._index) !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._checkRequired = v => v instanceof Date;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDate.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDate.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ d: { type: Date, min: min })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        let _value = value;\n        if (typeof value === 'function' && value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const min = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ d: { type: Date, max: max })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        let _value = value;\n        if (typeof _value === 'function' && _value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const max = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  let castDate;\n  if (typeof this._castFunction === 'function') {\n    castDate = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDate = this.constructor.cast();\n  } else {\n    castDate = SchemaDate.cast();\n  }\n\n  try {\n    return castDate(value);\n  } catch (error) {\n    throw new CastError('date', value, this.path, error, this);\n  }\n};\n\n/**\n * Date Query casting.\n *\n * @param {Any} val\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$gte` is the function Mongoose calls to cast `$gte` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaDate\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaDate.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val, context) {\n  if ($conditional == null) {\n    try {\n      return this.applySetters(val, context);\n    } catch (err) {\n      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n        err.path = this.$fullPath;\n      }\n      throw err;\n    }\n  }\n\n  const handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaDate.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('string', 'date', options?.useBsonType, isRequired);\n};\n\nSchemaDate.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'date';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}