{"ast":null,"code":"'use strict';\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Behaves like `Schema#path()`, except for it also digs into arrays without\n * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.\n * @api private\n */\n\nmodule.exports = function getPath(schema, path, discriminatorValueMap) {\n  let schematype = schema.path(path);\n  if (schematype != null) {\n    return schematype;\n  }\n  const pieces = path.split('.');\n  let cur = '';\n  let isArray = false;\n  for (const piece of pieces) {\n    if (isArray && numberRE.test(piece)) {\n      continue;\n    }\n    cur = cur.length === 0 ? piece : cur + '.' + piece;\n    schematype = schema.path(cur);\n    if (schematype?.schema) {\n      schema = schematype.schema;\n      if (!isArray && schematype.$isMongooseDocumentArray) {\n        isArray = true;\n      }\n      if (discriminatorValueMap && discriminatorValueMap[cur]) {\n        schema = schema.discriminators[discriminatorValueMap[cur]] ?? schema;\n      }\n      cur = '';\n    } else if (schematype?.instance === 'Mixed') {\n      // If we found a mixed path, no point in digging further, the end result is always Mixed\n      break;\n    }\n  }\n  return schematype;\n};","map":{"version":3,"names":["numberRE","module","exports","getPath","schema","path","discriminatorValueMap","schematype","pieces","split","cur","isArray","piece","test","length","$isMongooseDocumentArray","discriminators","instance"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/schema/getPath.js"],"sourcesContent":["'use strict';\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Behaves like `Schema#path()`, except for it also digs into arrays without\n * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.\n * @api private\n */\n\nmodule.exports = function getPath(schema, path, discriminatorValueMap) {\n  let schematype = schema.path(path);\n  if (schematype != null) {\n    return schematype;\n  }\n  const pieces = path.split('.');\n  let cur = '';\n  let isArray = false;\n\n  for (const piece of pieces) {\n    if (isArray && numberRE.test(piece)) {\n      continue;\n    }\n    cur = cur.length === 0 ? piece : cur + '.' + piece;\n\n    schematype = schema.path(cur);\n    if (schematype?.schema) {\n      schema = schematype.schema;\n      if (!isArray && schematype.$isMongooseDocumentArray) {\n        isArray = true;\n      }\n      if (discriminatorValueMap && discriminatorValueMap[cur]) {\n        schema = schema.discriminators[discriminatorValueMap[cur]] ?? schema;\n      }\n      cur = '';\n    } else if (schematype?.instance === 'Mixed') {\n      // If we found a mixed path, no point in digging further, the end result is always Mixed\n      break;\n    }\n  }\n\n  return schematype;\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,QAAQ,GAAG,OAAO;;AAExB;AACA;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAG,SAASC,OAAOA,CAACC,MAAM,EAAEC,IAAI,EAAEC,qBAAqB,EAAE;EACrE,IAAIC,UAAU,GAAGH,MAAM,CAACC,IAAI,CAACA,IAAI,CAAC;EAClC,IAAIE,UAAU,IAAI,IAAI,EAAE;IACtB,OAAOA,UAAU;EACnB;EACA,MAAMC,MAAM,GAAGH,IAAI,CAACI,KAAK,CAAC,GAAG,CAAC;EAC9B,IAAIC,GAAG,GAAG,EAAE;EACZ,IAAIC,OAAO,GAAG,KAAK;EAEnB,KAAK,MAAMC,KAAK,IAAIJ,MAAM,EAAE;IAC1B,IAAIG,OAAO,IAAIX,QAAQ,CAACa,IAAI,CAACD,KAAK,CAAC,EAAE;MACnC;IACF;IACAF,GAAG,GAAGA,GAAG,CAACI,MAAM,KAAK,CAAC,GAAGF,KAAK,GAAGF,GAAG,GAAG,GAAG,GAAGE,KAAK;IAElDL,UAAU,GAAGH,MAAM,CAACC,IAAI,CAACK,GAAG,CAAC;IAC7B,IAAIH,UAAU,EAAEH,MAAM,EAAE;MACtBA,MAAM,GAAGG,UAAU,CAACH,MAAM;MAC1B,IAAI,CAACO,OAAO,IAAIJ,UAAU,CAACQ,wBAAwB,EAAE;QACnDJ,OAAO,GAAG,IAAI;MAChB;MACA,IAAIL,qBAAqB,IAAIA,qBAAqB,CAACI,GAAG,CAAC,EAAE;QACvDN,MAAM,GAAGA,MAAM,CAACY,cAAc,CAACV,qBAAqB,CAACI,GAAG,CAAC,CAAC,IAAIN,MAAM;MACtE;MACAM,GAAG,GAAG,EAAE;IACV,CAAC,MAAM,IAAIH,UAAU,EAAEU,QAAQ,KAAK,OAAO,EAAE;MAC3C;MACA;IACF;EACF;EAEA,OAAOV,UAAU;AACnB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}