{"ast":null,"code":"'use strict';\n\nconst get = require('../get');\nconst utils = require('../../utils');\n/**\n * Given a Mongoose index definition (key + options objects) and a MongoDB server\n * index definition, determine if the two indexes are equal.\n *\n * @param {Object} schemaIndexKeysObject the Mongoose index spec\n * @param {Object} options the Mongoose index definition's options\n * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`\n * @api private\n */\n\nmodule.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {\n  // Special case: text indexes have a special format in the db. For example,\n  // `{ name: 'text' }` becomes:\n  // {\n  //   v: 2,\n  //   key: { _fts: 'text', _ftsx: 1 },\n  //   name: 'name_text',\n  //   ns: 'test.tests',\n  //   weights: { name: 1 },\n  //   default_language: 'english',\n  //   language_override: 'language',\n  //   textIndexVersion: 3\n  // }\n  if (dbIndex.textIndexVersion != null) {\n    delete dbIndex.key._fts;\n    delete dbIndex.key._ftsx;\n    const weights = {\n      ...dbIndex.weights,\n      ...dbIndex.key\n    };\n    if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {\n      return false;\n    }\n    for (const prop of Object.keys(weights)) {\n      if (!(prop in schemaIndexKeysObject)) {\n        return false;\n      }\n      const weight = weights[prop];\n      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {\n        return false;\n      }\n    }\n    if (options['default_language'] !== dbIndex['default_language']) {\n      return dbIndex['default_language'] === 'english' && options['default_language'] == null;\n    }\n    return true;\n  }\n  const optionKeys = ['unique', 'partialFilterExpression', 'sparse', 'expireAfterSeconds', 'collation'];\n  for (const key of optionKeys) {\n    if (!(key in options) && !(key in dbIndex)) {\n      continue;\n    }\n    if (key === 'collation') {\n      if (options[key] == null || dbIndex[key] == null) {\n        return options[key] == null && dbIndex[key] == null;\n      }\n      const definedKeys = Object.keys(options.collation);\n      const schemaCollation = options.collation;\n      const dbCollation = dbIndex.collation;\n      for (const opt of definedKeys) {\n        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {\n          return false;\n        }\n      }\n    } else if (!utils.deepEqual(options[key], dbIndex[key])) {\n      return false;\n    }\n  }\n  const schemaIndexKeys = Object.keys(schemaIndexKeysObject);\n  const dbIndexKeys = Object.keys(dbIndex.key);\n  if (schemaIndexKeys.length !== dbIndexKeys.length) {\n    return false;\n  }\n  for (let i = 0; i < schemaIndexKeys.length; ++i) {\n    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {\n      return false;\n    }\n    if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {\n      return false;\n    }\n  }\n  return true;\n};","map":{"version":3,"names":["get","require","utils","module","exports","isIndexEqual","schemaIndexKeysObject","options","dbIndex","textIndexVersion","key","_fts","_ftsx","weights","Object","keys","length","prop","weight","optionKeys","definedKeys","collation","schemaCollation","dbCollation","opt","deepEqual","schemaIndexKeys","dbIndexKeys","i"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst utils = require('../../utils');\n/**\n * Given a Mongoose index definition (key + options objects) and a MongoDB server\n * index definition, determine if the two indexes are equal.\n *\n * @param {Object} schemaIndexKeysObject the Mongoose index spec\n * @param {Object} options the Mongoose index definition's options\n * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`\n * @api private\n */\n\nmodule.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {\n  // Special case: text indexes have a special format in the db. For example,\n  // `{ name: 'text' }` becomes:\n  // {\n  //   v: 2,\n  //   key: { _fts: 'text', _ftsx: 1 },\n  //   name: 'name_text',\n  //   ns: 'test.tests',\n  //   weights: { name: 1 },\n  //   default_language: 'english',\n  //   language_override: 'language',\n  //   textIndexVersion: 3\n  // }\n  if (dbIndex.textIndexVersion != null) {\n    delete dbIndex.key._fts;\n    delete dbIndex.key._ftsx;\n    const weights = { ...dbIndex.weights, ...dbIndex.key };\n    if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {\n      return false;\n    }\n    for (const prop of Object.keys(weights)) {\n      if (!(prop in schemaIndexKeysObject)) {\n        return false;\n      }\n      const weight = weights[prop];\n      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {\n        return false;\n      }\n    }\n\n    if (options['default_language'] !== dbIndex['default_language']) {\n      return dbIndex['default_language'] === 'english' && options['default_language'] == null;\n    }\n\n    return true;\n  }\n\n  const optionKeys = [\n    'unique',\n    'partialFilterExpression',\n    'sparse',\n    'expireAfterSeconds',\n    'collation'\n  ];\n  for (const key of optionKeys) {\n    if (!(key in options) && !(key in dbIndex)) {\n      continue;\n    }\n    if (key === 'collation') {\n      if (options[key] == null || dbIndex[key] == null) {\n        return options[key] == null && dbIndex[key] == null;\n      }\n      const definedKeys = Object.keys(options.collation);\n      const schemaCollation = options.collation;\n      const dbCollation = dbIndex.collation;\n      for (const opt of definedKeys) {\n        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {\n          return false;\n        }\n      }\n    } else if (!utils.deepEqual(options[key], dbIndex[key])) {\n      return false;\n    }\n  }\n\n  const schemaIndexKeys = Object.keys(schemaIndexKeysObject);\n  const dbIndexKeys = Object.keys(dbIndex.key);\n  if (schemaIndexKeys.length !== dbIndexKeys.length) {\n    return false;\n  }\n  for (let i = 0; i < schemaIndexKeys.length; ++i) {\n    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {\n      return false;\n    }\n    if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}