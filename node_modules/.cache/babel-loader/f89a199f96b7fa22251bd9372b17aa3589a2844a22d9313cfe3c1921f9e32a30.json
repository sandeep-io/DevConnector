{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CursorTimeoutContext = exports.AbstractCursor = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst sessions_1 = require(\"../sessions\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\nfunction removeActiveCursor() {\n  this.client.s.activeCursors.delete(this);\n}\n/**\n * @public\n * @experimental\n * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n * `cursor.next()`.\n * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n *\n * Depending on the type of cursor being used, this option has different default values.\n * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n * definition can have an arbitrarily long lifetime.\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n * for await (const doc of cursor) {\n *  // process doc\n *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n * }\n * ```\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n * ```\n */\nexports.CursorTimeoutMode = Object.freeze({\n  ITERATION: 'iteration',\n  LIFETIME: 'cursorLifetime'\n});\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @event */\n  static {\n    this.CLOSE = 'close';\n  }\n  /** @internal */\n  constructor(client, namespace, options = {}) {\n    super();\n    /** @internal */\n    this.documents = null;\n    /** @internal */\n    this.hasEmittedClose = false;\n    this.on('error', utils_1.noop);\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options),\n      timeoutMS: options?.timeoutContext?.csotEnabled() ? options.timeoutContext.timeoutMS : options.timeoutMS,\n      tailable: options.tailable,\n      awaitData: options.awaitData\n    };\n    if (this.cursorOptions.timeoutMS != null) {\n      if (options.timeoutMode == null) {\n        if (options.tailable) {\n          if (options.awaitData) {\n            if (options.maxAwaitTimeMS != null && options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS) throw new error_1.MongoInvalidArgumentError('Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor');\n          }\n          this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.ITERATION;\n        } else {\n          this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.LIFETIME;\n        }\n      } else {\n        if (options.tailable && options.timeoutMode === exports.CursorTimeoutMode.LIFETIME) {\n          throw new error_1.MongoInvalidArgumentError(\"Cannot set tailable cursor's timeoutMode to LIFETIME\");\n        }\n        this.cursorOptions.timeoutMode = options.timeoutMode;\n      }\n    } else {\n      if (options.timeoutMode != null) throw new error_1.MongoInvalidArgumentError('Cannot set timeoutMode without setting timeoutMS');\n    }\n    // Set for initial command\n    this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null && (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && !this.cursorOptions.tailable || this.cursorOptions.tailable && !this.cursorOptions.awaitData);\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n    this.cursorSession = options.session ?? null;\n    this.deserializationOptions = {\n      ...this.cursorOptions,\n      validation: {\n        utf8: options?.enableUtf8Validation === false ? false : true\n      }\n    };\n    this.timeoutContext = options.timeoutContext;\n    this.signal = options.signal;\n    this.abortListener = (0, utils_1.addAbortListener)(this.signal, () => void this.close().then(undefined, utils_1.squashError));\n    this.trackCursor();\n  }\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id() {\n    return this.cursorId ?? undefined;\n  }\n  /** @internal */\n  get isDead() {\n    return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;\n  }\n  /** @internal */\n  get client() {\n    return this.cursorClient;\n  }\n  /** @internal */\n  get server() {\n    return this.selectedServer;\n  }\n  get namespace() {\n    return this.cursorNamespace;\n  }\n  get readPreference() {\n    return this.cursorOptions.readPreference;\n  }\n  get readConcern() {\n    return this.cursorOptions.readConcern;\n  }\n  /** @internal */\n  get session() {\n    return this.cursorSession;\n  }\n  set session(clientSession) {\n    this.cursorSession = clientSession;\n  }\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed() {\n    return this.isClosed && (this.documents?.length ?? 0) === 0;\n  }\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed() {\n    return this.isKilled;\n  }\n  get loadBalanced() {\n    return !!this.cursorClient.topology?.loadBalanced;\n  }\n  /**\n   * @experimental\n   * An alias for {@link AbstractCursor.close|AbstractCursor.close()}.\n   */\n  async [Symbol.asyncDispose]() {\n    await this.close();\n  }\n  /** Adds cursor to client's tracking so it will be closed by MongoClient.close() */\n  trackCursor() {\n    this.cursorClient.s.activeCursors.add(this);\n    if (!this.listeners('close').includes(removeActiveCursor)) {\n      this.once('close', removeActiveCursor);\n    }\n  }\n  /** Returns current buffered documents length */\n  bufferedCount() {\n    return this.documents?.length ?? 0;\n  }\n  /** Returns current buffered documents */\n  readBufferedDocuments(number) {\n    const bufferedDocs = [];\n    const documentsToRead = Math.min(number ?? this.documents?.length ?? 0, this.documents?.length ?? 0);\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this.documents?.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n    return bufferedDocs;\n  }\n  async *[Symbol.asyncIterator]() {\n    this.signal?.throwIfAborted();\n    if (this.closed) {\n      return;\n    }\n    try {\n      while (true) {\n        if (this.isKilled) {\n          return;\n        }\n        if (this.closed) {\n          return;\n        }\n        if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {\n          return;\n        }\n        const document = await this.next();\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          return;\n        }\n        yield document;\n        this.signal?.throwIfAborted();\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.isClosed) {\n        try {\n          await this.close();\n        } catch (error) {\n          (0, utils_1.squashError)(error);\n        }\n      }\n    }\n  }\n  stream() {\n    const readable = new ReadableCursorStream(this);\n    const abortListener = (0, utils_1.addAbortListener)(this.signal, function () {\n      readable.destroy(this.reason);\n    });\n    readable.once('end', () => {\n      abortListener?.[utils_1.kDispose]();\n    });\n    return readable;\n  }\n  async hasNext() {\n    this.signal?.throwIfAborted();\n    if (this.cursorId === bson_1.Long.ZERO) {\n      return false;\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        if ((this.documents?.length ?? 0) !== 0) {\n          return true;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n    return false;\n  }\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next() {\n    this.signal?.throwIfAborted();\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        const doc = this.documents?.shift(this.deserializationOptions);\n        if (doc != null) {\n          if (this.transform != null) return await this.transformDocument(doc);\n          return doc;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n    return null;\n  }\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext() {\n    this.signal?.throwIfAborted();\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      let doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n      await this.fetchBatch();\n      doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n    return null;\n  }\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator) {\n    this.signal?.throwIfAborted();\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close(options) {\n    await this.cleanup(options?.timeoutMS);\n  }\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray() {\n    this.signal?.throwIfAborted();\n    const array = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    for await (const document of this) {\n      array.push(document);\n      const docs = this.readBufferedDocuments();\n      if (this.transform != null) {\n        for (const doc of docs) {\n          array.push(await this.transformDocument(doc));\n        }\n      } else {\n        // Note: previous versions of this logic used `array.push(...)`, which adds each item\n        // to the callstack.  For large arrays, this can exceed the maximum call size.\n        for (const doc of docs) {\n          array.push(doc);\n        }\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag, value) {\n    this.throwIfInitialized();\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map(transform) {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference) {\n    this.throwIfInitialized();\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern) {\n    this.throwIfInitialized();\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value) {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value) {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind() {\n    if (this.timeoutContext && this.timeoutContext.owner !== this) {\n      throw new error_1.MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);\n    }\n    if (!this.initialized) {\n      return;\n    }\n    this.cursorId = null;\n    this.documents?.clear();\n    this.timeoutContext?.clear();\n    this.timeoutContext = undefined;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n    this.hasEmittedClose = false;\n    this.trackCursor();\n    // We only want to end this session if we created it, and it hasn't ended yet\n    if (this.cursorSession?.explicit === false) {\n      if (!this.cursorSession.hasEnded) {\n        this.cursorSession.endSession().then(undefined, utils_1.squashError);\n      }\n      this.cursorSession = null;\n    }\n  }\n  /** @internal */\n  async getMore() {\n    if (this.cursorId == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null cursor id. A cursor creating command should have set this');\n    }\n    if (this.selectedServer == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null selectedServer. A cursor creating command should have set this');\n    }\n    if (this.cursorSession == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null session. A cursor creating command should have set this');\n    }\n    const getMoreOptions = {\n      ...this.cursorOptions,\n      session: this.cursorSession,\n      batchSize: this.cursorOptions.batchSize\n    };\n    const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, getMoreOptions);\n    return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation, this.timeoutContext);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  async cursorInit() {\n    if (this.cursorOptions.timeoutMS != null) {\n      this.timeoutContext ??= new CursorTimeoutContext(timeout_1.TimeoutContext.create({\n        serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n        timeoutMS: this.cursorOptions.timeoutMS\n      }), this);\n    }\n    try {\n      this.cursorSession ??= this.cursorClient.startSession({\n        owner: this,\n        explicit: false\n      });\n      const state = await this._initialize(this.cursorSession);\n      // Set omitMaxTimeMS to the value needed for subsequent getMore calls\n      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = response.ns ?? this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(undefined, error);\n      throw error;\n    }\n    if (this.isDead) {\n      await this.cleanup();\n    }\n    return;\n  }\n  /** @internal Attempt to obtain more documents */\n  async fetchBatch() {\n    if (this.isClosed) {\n      return;\n    }\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n    if (this.cursorId == null) {\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if ((this.documents?.length ?? 0) !== 0 || this.isDead) return;\n    }\n    // Otherwise, run a getMore\n    try {\n      const response = await this.getMore();\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(undefined, error);\n      } catch (cleanupError) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        (0, utils_1.squashError)(cleanupError);\n      }\n      throw error;\n    }\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n  /** @internal */\n  async cleanup(timeoutMS, error) {\n    this.abortListener?.[utils_1.kDispose]();\n    this.isClosed = true;\n    const timeoutContextForKillCursors = () => {\n      if (timeoutMS != null) {\n        this.timeoutContext?.clear();\n        return new CursorTimeoutContext(timeout_1.TimeoutContext.create({\n          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n          timeoutMS\n        }), this);\n      } else {\n        return this.timeoutContext?.refreshed();\n      }\n    };\n    const withEmitClose = async fn => {\n      try {\n        await fn();\n      } finally {\n        this.emitClose();\n      }\n    };\n    const close = async () => {\n      // if no session has been defined on the cursor, the cursor was never initialized\n      // or the cursor was re-wound and never re-iterated.  In either case, we\n      //   1. do not need to end the session (there is no session after all)\n      //   2. do not need to kill the cursor server-side\n      const session = this.cursorSession;\n      if (!session) return;\n      try {\n        if (!this.isKilled && this.cursorId && !this.cursorId.isZero() && this.cursorNamespace && this.selectedServer && !session.hasEnded) {\n          this.isKilled = true;\n          const cursorId = this.cursorId;\n          this.cursorId = bson_1.Long.ZERO;\n          await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n            session\n          }), timeoutContextForKillCursors());\n        }\n      } catch (error) {\n        (0, utils_1.squashError)(error);\n      } finally {\n        if (session.owner === this) {\n          await session.endSession({\n            error\n          });\n        }\n        if (!session.inTransaction()) {\n          (0, sessions_1.maybeClearPinnedConnection)(session, {\n            error\n          });\n        }\n      }\n    };\n    await withEmitClose(close);\n  }\n  /** @internal */\n  emitClose() {\n    try {\n      if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n  /** @internal */\n  async transformDocument(document) {\n    if (this.transform == null) return document;\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        (0, utils_1.squashError)(closeError);\n      }\n      throw transformError;\n    }\n  }\n  /** @internal */\n  throwIfInitialized() {\n    if (this.initialized) throw new error_1.MongoCursorInUseError();\n  }\n}\nexports.AbstractCursor = AbstractCursor;\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n  _destroy(error, callback) {\n    this._cursor.close().then(() => callback(error), closeError => callback(closeError));\n  }\n  _readNext() {\n    if (this._cursor.id === bson_1.Long.ZERO) {\n      this.push(null);\n      return;\n    }\n    this._cursor.next().then(\n    // result from next()\n    result => {\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n        this._readInProgress = false;\n      }\n    },\n    // error from next()\n    err => {\n      // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n      //       desired behavior is that a stream ends cleanly when a user explicitly closes\n      //       a client during iteration. Alternatively, we could do the \"right\" thing and\n      //       propagate the error message by removing this special case.\n      if (err.message.match(/server is closed/)) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n        return this.push(null);\n      }\n      // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n      //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n      //       active getMore in-flight. This used to check if the cursor was killed but once\n      //       that changed to happen in cleanup legitimate errors would not destroy the\n      //       stream. There are change streams test specifically test these cases.\n      if (err.message.match(/operation was interrupted/)) {\n        return this.push(null);\n      }\n      // NOTE: The two above checks on the message of the error will cause a null to be pushed\n      //       to the stream, thus closing the stream before the destroy call happens. This means\n      //       that either of those error messages on a change stream will not get a proper\n      //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n      //       relies on that error event to be emitted to create its new cursor and thus was not\n      //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n      //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n      //       See NODE-4475.\n      return this.destroy(err);\n    })\n    // if either of the above handlers throw\n    .catch(error => {\n      this._readInProgress = false;\n      this.destroy(error);\n    });\n  }\n}\n/**\n * @internal\n * The cursor timeout context is a wrapper around a timeout context\n * that keeps track of the \"owner\" of the cursor.  For timeout contexts\n * instantiated inside a cursor, the owner will be the cursor.\n *\n * All timeout behavior is exactly the same as the wrapped timeout context's.\n */\nclass CursorTimeoutContext extends timeout_1.TimeoutContext {\n  constructor(timeoutContext, owner) {\n    super();\n    this.timeoutContext = timeoutContext;\n    this.owner = owner;\n  }\n  get serverSelectionTimeout() {\n    return this.timeoutContext.serverSelectionTimeout;\n  }\n  get connectionCheckoutTimeout() {\n    return this.timeoutContext.connectionCheckoutTimeout;\n  }\n  get clearServerSelectionTimeout() {\n    return this.timeoutContext.clearServerSelectionTimeout;\n  }\n  get timeoutForSocketWrite() {\n    return this.timeoutContext.timeoutForSocketWrite;\n  }\n  get timeoutForSocketRead() {\n    return this.timeoutContext.timeoutForSocketRead;\n  }\n  csotEnabled() {\n    return this.timeoutContext.csotEnabled();\n  }\n  refresh() {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.refresh();\n  }\n  clear() {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.clear();\n  }\n  get maxTimeMS() {\n    return this.timeoutContext.maxTimeMS;\n  }\n  get timeoutMS() {\n    return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;\n  }\n  refreshed() {\n    return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);\n  }\n  addMaxTimeMSToCommand(command, options) {\n    this.timeoutContext.addMaxTimeMSToCommand(command, options);\n  }\n  getSocketTimeoutMS() {\n    return this.timeoutContext.getSocketTimeoutMS();\n  }\n}\nexports.CursorTimeoutContext = CursorTimeoutContext;","map":{"version":3,"names":["stream_1","require","bson_1","error_1","mongo_types_1","execute_operation_1","get_more_1","kill_cursors_1","read_concern_1","read_preference_1","sessions_1","timeout_1","utils_1","exports","CURSOR_FLAGS","removeActiveCursor","client","s","activeCursors","delete","CursorTimeoutMode","Object","freeze","ITERATION","LIFETIME","AbstractCursor","TypedEventEmitter","CLOSE","constructor","namespace","options","documents","hasEmittedClose","on","noop","isMongoClient","MongoRuntimeError","cursorClient","cursorNamespace","cursorId","initialized","isClosed","isKilled","cursorOptions","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","timeoutMS","timeoutContext","csotEnabled","tailable","awaitData","timeoutMode","maxAwaitTimeMS","MongoInvalidArgumentError","omitMaxTimeMS","readConcern","ReadConcern","fromOptions","batchSize","comment","undefined","maxTimeMS","cursorSession","session","deserializationOptions","validation","utf8","enableUtf8Validation","signal","abortListener","addAbortListener","close","then","squashError","trackCursor","id","isDead","isZero","server","selectedServer","clientSession","closed","length","killed","loadBalanced","topology","Symbol","asyncDispose","add","listeners","includes","once","bufferedCount","readBufferedDocuments","number","bufferedDocs","documentsToRead","Math","min","count","document","shift","push","asyncIterator","throwIfAborted","next","error","stream","readable","ReadableCursorStream","destroy","reason","kDispose","hasNext","Long","ZERO","refresh","fetchBatch","clear","MongoCursorExhaustedError","doc","transform","transformDocument","tryNext","forEach","iterator","result","cleanup","toArray","array","docs","addCursorFlag","flag","value","throwIfInitialized","map","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","MongoTailableCursorError","rewind","owner","MongoAPIError","explicit","hasEnded","endSession","getMore","getMoreOptions","getMoreOperation","GetMoreOperation","executeOperation","cursorInit","CursorTimeoutContext","TimeoutContext","create","serverSelectionTimeoutMS","startSession","state","_initialize","response","ns","cleanupError","timeoutContextForKillCursors","refreshed","withEmitClose","fn","emitClose","KillCursorsOperation","inTransaction","maybeClearPinnedConnection","emit","transformedDocument","TRANSFORM_TO_NULL_ERROR","transformError","closeError","MongoCursorInUseError","Readable","cursor","objectMode","autoDestroy","highWaterMark","_readInProgress","_cursor","_read","size","_readNext","_destroy","callback","destroyed","err","message","match","catch","serverSelectionTimeout","connectionCheckoutTimeout","clearServerSelectionTimeout","timeoutForSocketWrite","timeoutForSocketRead","addMaxTimeMSToCommand","command","getSocketTimeoutMS"],"sources":["C:\\DEVC\\node_modules\\mongodb\\src\\cursor\\abstract_cursor.ts"],"sourcesContent":["import { Readable } from 'stream';\n\nimport { type BSONSerializeOptions, type Document, Long, pluckBSONSerializeOptions } from '../bson';\nimport { type OnDemandDocumentDeserializeOptions } from '../cmap/wire_protocol/on_demand/document';\nimport { type CursorResponse } from '../cmap/wire_protocol/responses';\nimport {\n  MongoAPIError,\n  MongoCursorExhaustedError,\n  MongoCursorInUseError,\n  MongoInvalidArgumentError,\n  MongoRuntimeError,\n  MongoTailableCursorError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { type Abortable, TypedEventEmitter } from '../mongo_types';\nimport { executeOperation } from '../operations/execute_operation';\nimport { GetMoreOperation } from '../operations/get_more';\nimport { KillCursorsOperation } from '../operations/kill_cursors';\nimport { ReadConcern, type ReadConcernLike } from '../read_concern';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport { type ClientSession, maybeClearPinnedConnection } from '../sessions';\nimport { type CSOTTimeoutContext, type Timeout, TimeoutContext } from '../timeout';\nimport {\n  addAbortListener,\n  type Disposable,\n  kDispose,\n  type MongoDBNamespace,\n  noop,\n  squashError\n} from '../utils';\n\n/**\n * @internal\n * TODO(NODE-2882): A cursor's getMore commands must be run on the same server it was started on\n * and the same session must be used for the lifetime of the cursor. This object serves to get the\n * server and session (along with the response) out of executeOperation back to the AbstractCursor.\n *\n * There may be a better design for communicating these values back to the cursor, currently an operation\n * MUST store the selected server on itself so it can be read after executeOperation has returned.\n */\nexport interface InitialCursorResponse {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: CursorResponse;\n}\n\n/** @public */\nexport const CURSOR_FLAGS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'exhaust',\n  'partial'\n] as const;\n\n/** @public */\nexport type CursorFlag = (typeof CURSOR_FLAGS)[number];\n\nfunction removeActiveCursor(this: AbstractCursor) {\n  this.client.s.activeCursors.delete(this);\n}\n\n/**\n * @public\n * @experimental\n * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n * `cursor.next()`.\n * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n *\n * Depending on the type of cursor being used, this option has different default values.\n * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n * definition can have an arbitrarily long lifetime.\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n * for await (const doc of cursor) {\n *  // process doc\n *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n * }\n * ```\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n * ```\n */\nexport const CursorTimeoutMode = Object.freeze({\n  ITERATION: 'iteration',\n  LIFETIME: 'cursorLifetime'\n} as const);\n\n/**\n * @public\n * @experimental\n */\nexport type CursorTimeoutMode = (typeof CursorTimeoutMode)[keyof typeof CursorTimeoutMode];\n\n/** @public */\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  /**\n   * Specifies the number of documents to return in each response from MongoDB\n   */\n  batchSize?: number;\n  /**\n   * When applicable `maxTimeMS` controls the amount of time the initial command\n   * that constructs a cursor should take. (ex. find, aggregate, listCollections)\n   */\n  maxTimeMS?: number;\n  /**\n   * When applicable `maxAwaitTimeMS` controls the amount of time subsequent getMores\n   * that a cursor uses to fetch more data should take. (ex. cursor.next())\n   */\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /**\n   * By default, MongoDB will automatically close a cursor when the\n   * client has exhausted all results in the cursor. However, for [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections)\n   * you may use a Tailable Cursor that remains open after the client exhausts\n   * the results in the initial cursor.\n   */\n  tailable?: boolean;\n  /**\n   * If awaitData is set to true, when the cursor reaches the end of the capped collection,\n   * MongoDB blocks the query thread for a period of time waiting for new data to arrive.\n   * When new data is inserted into the capped collection, the blocked thread is signaled\n   * to wake up and return the next batch to the client.\n   */\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** Specifies the time an operation will run until it throws a timeout error. See {@link AbstractCursorOptions.timeoutMode} for more details on how this option applies to cursors. */\n  timeoutMS?: number;\n  /**\n   * @public\n   * @experimental\n   * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n   * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n   * `cursor.next()`.\n   * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n   *\n   * Depending on the type of cursor being used, this option has different default values.\n   * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n   * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n   * definition can have an arbitrarily long lifetime.\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n   * for await (const doc of cursor) {\n   *  // process doc\n   *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n   *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n   * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n   * ```\n   */\n  timeoutMode?: CursorTimeoutMode;\n\n  /**\n   * @internal\n   *\n   * A timeout context to govern the total time the cursor can live.  If provided, the cursor\n   * cannot be used in ITERATION mode.\n   */\n  timeoutContext?: CursorTimeoutContext;\n}\n\n/** @internal */\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\n  // resolved\n  readPreference: ReadPreference;\n  readConcern?: ReadConcern;\n\n  // cursor flags, some are deprecated\n  oplogReplay?: boolean;\n  exhaust?: boolean;\n  partial?: boolean;\n\n  omitMaxTimeMS?: boolean;\n};\n\n/** @public */\nexport type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\nexport abstract class AbstractCursor<\n    TSchema = any,\n    CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\n  >\n  extends TypedEventEmitter<CursorEvents>\n  implements AsyncDisposable\n{\n  /** @internal */\n  private cursorId: Long | null;\n  /** @internal */\n  private cursorSession: ClientSession | null;\n  /** @internal */\n  private selectedServer?: Server;\n  /** @internal */\n  private cursorNamespace: MongoDBNamespace;\n  /** @internal */\n  private documents: CursorResponse | null = null;\n  /** @internal */\n  private cursorClient: MongoClient;\n  /** @internal */\n  private transform?: (doc: TSchema) => any;\n  /**\n   * @internal\n   * This is true whether or not the first command fails. It only indicates whether or not the first\n   * command has been run.\n   */\n  private initialized: boolean;\n  /** @internal */\n  private isClosed: boolean;\n  /** @internal */\n  private isKilled: boolean;\n  /** @internal */\n  protected readonly cursorOptions: InternalAbstractCursorOptions;\n  /** @internal */\n  protected timeoutContext?: CursorTimeoutContext;\n\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n\n  /** @internal */\n  protected deserializationOptions: OnDemandDocumentDeserializeOptions;\n  protected signal: AbortSignal | undefined;\n  private abortListener: Disposable | undefined;\n\n  /** @internal */\n  protected constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    options: AbstractCursorOptions & Abortable = {}\n  ) {\n    super();\n    this.on('error', noop);\n\n    if (!client.s.isMongoClient) {\n      throw new MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = {\n      readPreference:\n        options.readPreference && options.readPreference instanceof ReadPreference\n          ? options.readPreference\n          : ReadPreference.primary,\n      ...pluckBSONSerializeOptions(options),\n      timeoutMS: options?.timeoutContext?.csotEnabled()\n        ? options.timeoutContext.timeoutMS\n        : options.timeoutMS,\n      tailable: options.tailable,\n      awaitData: options.awaitData\n    };\n\n    if (this.cursorOptions.timeoutMS != null) {\n      if (options.timeoutMode == null) {\n        if (options.tailable) {\n          if (options.awaitData) {\n            if (\n              options.maxAwaitTimeMS != null &&\n              options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS\n            )\n              throw new MongoInvalidArgumentError(\n                'Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor'\n              );\n          }\n\n          this.cursorOptions.timeoutMode = CursorTimeoutMode.ITERATION;\n        } else {\n          this.cursorOptions.timeoutMode = CursorTimeoutMode.LIFETIME;\n        }\n      } else {\n        if (options.tailable && options.timeoutMode === CursorTimeoutMode.LIFETIME) {\n          throw new MongoInvalidArgumentError(\n            \"Cannot set tailable cursor's timeoutMode to LIFETIME\"\n          );\n        }\n        this.cursorOptions.timeoutMode = options.timeoutMode;\n      }\n    } else {\n      if (options.timeoutMode != null)\n        throw new MongoInvalidArgumentError('Cannot set timeoutMode without setting timeoutMS');\n    }\n\n    // Set for initial command\n    this.cursorOptions.omitMaxTimeMS =\n      this.cursorOptions.timeoutMS != null &&\n      ((this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&\n        !this.cursorOptions.tailable) ||\n        (this.cursorOptions.tailable && !this.cursorOptions.awaitData));\n\n    const readConcern = ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n\n    this.cursorSession = options.session ?? null;\n\n    this.deserializationOptions = {\n      ...this.cursorOptions,\n      validation: {\n        utf8: options?.enableUtf8Validation === false ? false : true\n      }\n    };\n\n    this.timeoutContext = options.timeoutContext;\n    this.signal = options.signal;\n    this.abortListener = addAbortListener(\n      this.signal,\n      () => void this.close().then(undefined, squashError)\n    );\n    this.trackCursor();\n  }\n\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id(): Long | undefined {\n    return this.cursorId ?? undefined;\n  }\n\n  /** @internal */\n  get isDead() {\n    return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;\n  }\n\n  /** @internal */\n  get client(): MongoClient {\n    return this.cursorClient;\n  }\n\n  /** @internal */\n  get server(): Server | undefined {\n    return this.selectedServer;\n  }\n\n  get namespace(): MongoDBNamespace {\n    return this.cursorNamespace;\n  }\n\n  get readPreference(): ReadPreference {\n    return this.cursorOptions.readPreference;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this.cursorOptions.readConcern;\n  }\n\n  /** @internal */\n  get session(): ClientSession | null {\n    return this.cursorSession;\n  }\n\n  set session(clientSession: ClientSession) {\n    this.cursorSession = clientSession;\n  }\n\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed(): boolean {\n    return this.isClosed && (this.documents?.length ?? 0) === 0;\n  }\n\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed(): boolean {\n    return this.isKilled;\n  }\n\n  get loadBalanced(): boolean {\n    return !!this.cursorClient.topology?.loadBalanced;\n  }\n\n  /**\n   * @experimental\n   * An alias for {@link AbstractCursor.close|AbstractCursor.close()}.\n   */\n  async [Symbol.asyncDispose]() {\n    await this.close();\n  }\n\n  /** Adds cursor to client's tracking so it will be closed by MongoClient.close() */\n  private trackCursor() {\n    this.cursorClient.s.activeCursors.add(this);\n    if (!this.listeners('close').includes(removeActiveCursor)) {\n      this.once('close', removeActiveCursor);\n    }\n  }\n\n  /** Returns current buffered documents length */\n  bufferedCount(): number {\n    return this.documents?.length ?? 0;\n  }\n\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): NonNullable<TSchema>[] {\n    const bufferedDocs: NonNullable<TSchema>[] = [];\n    const documentsToRead = Math.min(\n      number ?? this.documents?.length ?? 0,\n      this.documents?.length ?? 0\n    );\n\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this.documents?.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n\n    return bufferedDocs;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void> {\n    this.signal?.throwIfAborted();\n\n    if (this.closed) {\n      return;\n    }\n\n    try {\n      while (true) {\n        if (this.isKilled) {\n          return;\n        }\n\n        if (this.closed) {\n          return;\n        }\n\n        if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {\n          return;\n        }\n\n        const document = await this.next();\n\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          return;\n        }\n\n        yield document;\n\n        this.signal?.throwIfAborted();\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.isClosed) {\n        try {\n          await this.close();\n        } catch (error) {\n          squashError(error);\n        }\n      }\n    }\n  }\n\n  stream(): Readable & AsyncIterable<TSchema> {\n    const readable = new ReadableCursorStream(this);\n    const abortListener = addAbortListener(this.signal, function () {\n      readable.destroy(this.reason);\n    });\n    readable.once('end', () => {\n      abortListener?.[kDispose]();\n    });\n\n    return readable;\n  }\n\n  async hasNext(): Promise<boolean> {\n    this.signal?.throwIfAborted();\n\n    if (this.cursorId === Long.ZERO) {\n      return false;\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        if ((this.documents?.length ?? 0) !== 0) {\n          return true;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return false;\n  }\n\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next(): Promise<TSchema | null> {\n    this.signal?.throwIfAborted();\n\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n\n    try {\n      do {\n        const doc = this.documents?.shift(this.deserializationOptions);\n        if (doc != null) {\n          if (this.transform != null) return await this.transformDocument(doc);\n          return doc;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext(): Promise<TSchema | null> {\n    this.signal?.throwIfAborted();\n\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      let doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n\n      await this.fetchBatch();\n\n      doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator: (doc: TSchema) => boolean | void): Promise<void> {\n    this.signal?.throwIfAborted();\n\n    if (typeof iterator !== 'function') {\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close(options?: { timeoutMS?: number }): Promise<void> {\n    await this.cleanup(options?.timeoutMS);\n  }\n\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray(): Promise<TSchema[]> {\n    this.signal?.throwIfAborted();\n\n    const array: TSchema[] = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    for await (const document of this) {\n      array.push(document);\n      const docs = this.readBufferedDocuments();\n      if (this.transform != null) {\n        for (const doc of docs) {\n          array.push(await this.transformDocument(doc));\n        }\n      } else {\n        // Note: previous versions of this logic used `array.push(...)`, which adds each item\n        // to the callstack.  For large arrays, this can exceed the maximum call size.\n        for (const doc of docs) {\n          array.push(doc);\n        }\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\n    this.throwIfInitialized();\n    if (!CURSOR_FLAGS.includes(flag)) {\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n\n    return this as unknown as AbstractCursor<T>;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this {\n    this.throwIfInitialized();\n    if (readPreference instanceof ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = ReadPreference.fromString(readPreference);\n    } else {\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this {\n    this.throwIfInitialized();\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void {\n    if (this.timeoutContext && this.timeoutContext.owner !== this) {\n      throw new MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);\n    }\n    if (!this.initialized) {\n      return;\n    }\n\n    this.cursorId = null;\n    this.documents?.clear();\n    this.timeoutContext?.clear();\n    this.timeoutContext = undefined;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n    this.hasEmittedClose = false;\n    this.trackCursor();\n\n    // We only want to end this session if we created it, and it hasn't ended yet\n    if (this.cursorSession?.explicit === false) {\n      if (!this.cursorSession.hasEnded) {\n        this.cursorSession.endSession().then(undefined, squashError);\n      }\n\n      this.cursorSession = null;\n    }\n  }\n\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n\n  /** @internal */\n  protected abstract _initialize(\n    session: ClientSession | undefined\n  ): Promise<InitialCursorResponse>;\n\n  /** @internal */\n  async getMore(): Promise<CursorResponse> {\n    if (this.cursorId == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null cursor id. A cursor creating command should have set this'\n      );\n    }\n    if (this.selectedServer == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null selectedServer. A cursor creating command should have set this'\n      );\n    }\n\n    if (this.cursorSession == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null session. A cursor creating command should have set this'\n      );\n    }\n    const getMoreOptions = {\n      ...this.cursorOptions,\n      session: this.cursorSession,\n      batchSize: this.cursorOptions.batchSize\n    };\n\n    const getMoreOperation = new GetMoreOperation(\n      this.cursorNamespace,\n      this.cursorId,\n      this.selectedServer,\n      getMoreOptions\n    );\n\n    return await executeOperation(this.cursorClient, getMoreOperation, this.timeoutContext);\n  }\n\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  private async cursorInit(): Promise<void> {\n    if (this.cursorOptions.timeoutMS != null) {\n      this.timeoutContext ??= new CursorTimeoutContext(\n        TimeoutContext.create({\n          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n          timeoutMS: this.cursorOptions.timeoutMS\n        }),\n        this\n      );\n    }\n    try {\n      this.cursorSession ??= this.cursorClient.startSession({ owner: this, explicit: false });\n      const state = await this._initialize(this.cursorSession);\n      // Set omitMaxTimeMS to the value needed for subsequent getMore calls\n      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = response.ns ?? this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(undefined, error);\n      throw error;\n    }\n\n    if (this.isDead) {\n      await this.cleanup();\n    }\n\n    return;\n  }\n\n  /** @internal Attempt to obtain more documents */\n  private async fetchBatch(): Promise<void> {\n    if (this.isClosed) {\n      return;\n    }\n\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n\n    if (this.cursorId == null) {\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if ((this.documents?.length ?? 0) !== 0 || this.isDead) return;\n    }\n\n    // Otherwise, run a getMore\n    try {\n      const response = await this.getMore();\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(undefined, error);\n      } catch (cleanupError) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        squashError(cleanupError);\n      }\n      throw error;\n    }\n\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n\n  /** @internal */\n  private async cleanup(timeoutMS?: number, error?: Error) {\n    this.abortListener?.[kDispose]();\n    this.isClosed = true;\n    const timeoutContextForKillCursors = (): CursorTimeoutContext | undefined => {\n      if (timeoutMS != null) {\n        this.timeoutContext?.clear();\n        return new CursorTimeoutContext(\n          TimeoutContext.create({\n            serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n            timeoutMS\n          }),\n          this\n        );\n      } else {\n        return this.timeoutContext?.refreshed();\n      }\n    };\n\n    const withEmitClose = async (fn: () => Promise<void>) => {\n      try {\n        await fn();\n      } finally {\n        this.emitClose();\n      }\n    };\n\n    const close = async () => {\n      // if no session has been defined on the cursor, the cursor was never initialized\n      // or the cursor was re-wound and never re-iterated.  In either case, we\n      //   1. do not need to end the session (there is no session after all)\n      //   2. do not need to kill the cursor server-side\n      const session = this.cursorSession;\n      if (!session) return;\n\n      try {\n        if (\n          !this.isKilled &&\n          this.cursorId &&\n          !this.cursorId.isZero() &&\n          this.cursorNamespace &&\n          this.selectedServer &&\n          !session.hasEnded\n        ) {\n          this.isKilled = true;\n          const cursorId = this.cursorId;\n          this.cursorId = Long.ZERO;\n\n          await executeOperation(\n            this.cursorClient,\n            new KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n              session\n            }),\n            timeoutContextForKillCursors()\n          );\n        }\n      } catch (error) {\n        squashError(error);\n      } finally {\n        if (session.owner === this) {\n          await session.endSession({ error });\n        }\n        if (!session.inTransaction()) {\n          maybeClearPinnedConnection(session, { error });\n        }\n      }\n    };\n\n    await withEmitClose(close);\n  }\n\n  /** @internal */\n  private hasEmittedClose = false;\n  /** @internal */\n  private emitClose() {\n    try {\n      if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n\n  /** @internal */\n  private async transformDocument(document: NonNullable<TSchema>): Promise<NonNullable<TSchema>> {\n    if (this.transform == null) return document;\n\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR =\n          'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        squashError(closeError);\n      }\n      throw transformError;\n    }\n  }\n\n  /** @internal */\n  protected throwIfInitialized() {\n    if (this.initialized) throw new MongoCursorInUseError();\n  }\n}\n\nclass ReadableCursorStream extends Readable {\n  private _cursor: AbstractCursor;\n  private _readInProgress = false;\n\n  constructor(cursor: AbstractCursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._cursor = cursor;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override _read(size: number): void {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n\n  override _destroy(error: Error | null, callback: (error?: Error | null) => void): void {\n    this._cursor.close().then(\n      () => callback(error),\n      closeError => callback(closeError)\n    );\n  }\n\n  private _readNext() {\n    if (this._cursor.id === Long.ZERO) {\n      this.push(null);\n      return;\n    }\n\n    this._cursor\n      .next()\n      .then(\n        // result from next()\n        result => {\n          if (result == null) {\n            this.push(null);\n          } else if (this.destroyed) {\n            this._cursor.close().then(undefined, squashError);\n          } else {\n            if (this.push(result)) {\n              return this._readNext();\n            }\n\n            this._readInProgress = false;\n          }\n        },\n        // error from next()\n        err => {\n          // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n          //       desired behavior is that a stream ends cleanly when a user explicitly closes\n          //       a client during iteration. Alternatively, we could do the \"right\" thing and\n          //       propagate the error message by removing this special case.\n          if (err.message.match(/server is closed/)) {\n            this._cursor.close().then(undefined, squashError);\n            return this.push(null);\n          }\n\n          // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n          //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n          //       active getMore in-flight. This used to check if the cursor was killed but once\n          //       that changed to happen in cleanup legitimate errors would not destroy the\n          //       stream. There are change streams test specifically test these cases.\n          if (err.message.match(/operation was interrupted/)) {\n            return this.push(null);\n          }\n\n          // NOTE: The two above checks on the message of the error will cause a null to be pushed\n          //       to the stream, thus closing the stream before the destroy call happens. This means\n          //       that either of those error messages on a change stream will not get a proper\n          //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n          //       relies on that error event to be emitted to create its new cursor and thus was not\n          //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n          //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n          //       See NODE-4475.\n          return this.destroy(err);\n        }\n      )\n      // if either of the above handlers throw\n      .catch(error => {\n        this._readInProgress = false;\n        this.destroy(error);\n      });\n  }\n}\n\n/**\n * @internal\n * The cursor timeout context is a wrapper around a timeout context\n * that keeps track of the \"owner\" of the cursor.  For timeout contexts\n * instantiated inside a cursor, the owner will be the cursor.\n *\n * All timeout behavior is exactly the same as the wrapped timeout context's.\n */\nexport class CursorTimeoutContext extends TimeoutContext {\n  timeoutContext: TimeoutContext;\n  owner: symbol | AbstractCursor;\n\n  constructor(timeoutContext: TimeoutContext, owner: symbol | AbstractCursor) {\n    super();\n    this.timeoutContext = timeoutContext;\n    this.owner = owner;\n  }\n  override get serverSelectionTimeout(): Timeout | null {\n    return this.timeoutContext.serverSelectionTimeout;\n  }\n  override get connectionCheckoutTimeout(): Timeout | null {\n    return this.timeoutContext.connectionCheckoutTimeout;\n  }\n  override get clearServerSelectionTimeout(): boolean {\n    return this.timeoutContext.clearServerSelectionTimeout;\n  }\n  override get timeoutForSocketWrite(): Timeout | null {\n    return this.timeoutContext.timeoutForSocketWrite;\n  }\n  override get timeoutForSocketRead(): Timeout | null {\n    return this.timeoutContext.timeoutForSocketRead;\n  }\n  override csotEnabled(): this is CSOTTimeoutContext {\n    return this.timeoutContext.csotEnabled();\n  }\n  override refresh(): void {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.refresh();\n  }\n  override clear(): void {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.clear();\n  }\n  override get maxTimeMS(): number | null {\n    return this.timeoutContext.maxTimeMS;\n  }\n  get timeoutMS(): number | null {\n    return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;\n  }\n  override refreshed(): CursorTimeoutContext {\n    return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);\n  }\n  override addMaxTimeMSToCommand(command: Document, options: { omitMaxTimeMS?: boolean }): void {\n    this.timeoutContext.addMaxTimeMSToCommand(command, options);\n  }\n  override getSocketTimeoutMS(): number | undefined {\n    return this.timeoutContext.getSocketTimeoutMS();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}