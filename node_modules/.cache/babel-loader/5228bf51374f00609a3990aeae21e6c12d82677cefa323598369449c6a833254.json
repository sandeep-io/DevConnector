{"ast":null,"code":"/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/mongooseError');\nconst Readable = require('stream').Readable;\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst immediate = require('../helpers/immediate');\nconst kareem = require('kareem');\nconst util = require('util');\n\n/**\n * An AggregationCursor is a concurrency primitive for processing aggregation\n * results one document at a time. It is analogous to QueryCursor.\n *\n * An AggregationCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\n * but **not** the model's post aggregate hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Aggregate#cursor()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor()) instead.\n *\n * @param {Aggregate} agg\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction AggregationCursor(agg) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, {\n    autoDestroy: true,\n    objectMode: true\n  });\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const connection = agg._connection;\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n  if (connection) {\n    this.cursor = connection.db.aggregate(agg._pipeline, agg.options || {});\n    setImmediate(() => this.emit('cursor', this.cursor));\n  } else {\n    _init(model, this, agg);\n  }\n}\nutil.inherits(AggregationCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg).then(() => onPreComplete(null), err => onPreComplete(err));\n  } else {\n    model.collection.emitter.once('queue', function () {\n      model.hooks.execPre('aggregate', agg).then(() => onPreComplete(null), err => onPreComplete(err));\n    });\n  }\n  function onPreComplete(err) {\n    if (err != null) {\n      _handlePreHookError(c, err);\n      return;\n    }\n    if (typeof agg.options?.cursor?.transform === 'function') {\n      c._transforms.push(agg.options.cursor.transform);\n    }\n    c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n    c.emit('cursor', c.cursor);\n  }\n}\n\n/**\n* Handles error emitted from pre middleware. In particular, checks for `skipWrappedFunction`, which allows skipping\n* the actual aggregation and overwriting the function's return value. Because aggregation cursors don't return a value,\n* we need to make sure the user doesn't accidentally set a value in skipWrappedFunction.\n*\n* @param {QueryCursor} queryCursor\n* @param {Error} err\n* @returns\n*/\n\nfunction _handlePreHookError(queryCursor, err) {\n  if (err instanceof kareem.skipWrappedFunction) {\n    const resultValue = err.args[0];\n    if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {\n      const err = new MongooseError('Cannot `skipMiddlewareFunction()` with a value when using ' + '`.aggregate().cursor()`, value must be nullish or empty array, got \"' + util.inspect(resultValue) + '\".');\n      queryCursor._markError(err);\n      queryCursor.listeners('error').length > 0 && queryCursor.emit('error', err);\n      return;\n    }\n    queryCursor.emit('cursor', null);\n    return;\n  }\n  queryCursor._markError(err);\n  queryCursor.listeners('error').length > 0 && queryCursor.emit('error', err);\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf AggregationCursor\n * @instance\n * @api private\n */\n\nAggregationCursor.prototype._read = function () {\n  const _this = this;\n  _next(this, function (error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function (error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\nif (Symbol.asyncIterator != null) {\n  const msg = 'Mongoose does not support using async iterators with an ' + 'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\n  AggregationCursor.prototype[Symbol.asyncIterator] = function () {\n    throw new MongooseError(msg);\n  };\n}\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {AggregationCursor}\n * @memberOf AggregationCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(AggregationCursor.prototype, 'map', {\n  value: function (fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @instance\n * @memberOf AggregationCursor\n * @api private\n */\n\nAggregationCursor.prototype._markError = function (error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {Promise}\n * @api public\n * @method close\n * @emits \"close\"\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nAggregationCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n  this.emit('close');\n};\n\n/**\n * Marks this cursor as destroyed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {this}\n * @api private\n * @method _destroy\n */\n\nAggregationCursor.prototype._destroy = function _destroy(_err, callback) {\n  let waitForCursor = null;\n  if (!this.cursor) {\n    waitForCursor = new Promise(resolve => {\n      this.once('cursor', resolve);\n    });\n  } else {\n    waitForCursor = Promise.resolve();\n  }\n  waitForCursor.then(() => this.cursor.close()).then(() => {\n    this._closed = true;\n    callback();\n  }).catch(error => {\n    callback(error);\n  });\n  return this;\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nAggregationCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nAggregationCursor.prototype.eachAsync = function (fn, opts) {\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.eachAsync() no longer accepts a callback');\n  }\n  const _this = this;\n  if (typeof opts === 'function') {\n    opts = {};\n  }\n  opts = opts || {};\n  return eachAsync(function (cb) {\n    return _next(_this, cb);\n  }, fn, opts);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\n *     // creates an AggregationCursor instance internally.\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n *     // You can also use an AggregationCursor instance for async iteration\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\n *     for await (const doc of cursor) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf AggregationCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  AggregationCursor.prototype[Symbol.asyncIterator] = function () {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype._transformForAsyncIterator = function () {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype.transformNull = function (val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? {\n    done: true\n  } : {\n    value: doc,\n    done: false\n  };\n}\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nAggregationCursor.prototype.addCursorFlag = function (flag, value) {\n  const _this = this;\n  _waitForCursor(this, function () {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function () {\n    cb();\n  });\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function (err, doc) {\n      if (err || doc === null && !ctx._mongooseOptions.transformNull) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function (doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n  if (ctx._error) {\n    return immediate(function () {\n      callback(ctx._error);\n    });\n  }\n  if (ctx.cursor) {\n    return ctx.cursor.next().then(doc => {\n      if (!doc) {\n        return callback(null, null);\n      }\n      callback(null, doc);\n    }, err => callback(err));\n  } else {\n    ctx.once('error', cb);\n    ctx.once('cursor', function () {\n      _next(ctx, cb);\n    });\n  }\n}\nmodule.exports = AggregationCursor;","map":{"version":3,"names":["MongooseError","require","Readable","eachAsync","immediate","kareem","util","AggregationCursor","agg","call","autoDestroy","objectMode","cursor","_transforms","connection","_connection","model","_model","options","useMongooseAggCursor","_mongooseOptions","db","aggregate","_pipeline","setImmediate","emit","_init","inherits","c","collection","buffer","hooks","execPre","then","onPreComplete","err","emitter","once","_handlePreHookError","transform","push","queryCursor","skipWrappedFunction","resultValue","args","Array","isArray","length","inspect","_markError","listeners","prototype","_read","_this","_next","error","doc","close","Symbol","asyncIterator","msg","Object","defineProperty","value","fn","enumerable","configurable","writable","_error","arguments","_destroy","_err","callback","waitForCursor","Promise","resolve","_closed","catch","next","reject","res","opts","cb","transformNull","_transformForAsyncIterator","indexOf","map","val","done","addCursorFlag","flag","_waitForCursor","ctx","reduce","module","exports"],"sources":["C:/DEVC/node_modules/mongoose/lib/cursor/aggregationCursor.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/mongooseError');\nconst Readable = require('stream').Readable;\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst immediate = require('../helpers/immediate');\nconst kareem = require('kareem');\nconst util = require('util');\n\n/**\n * An AggregationCursor is a concurrency primitive for processing aggregation\n * results one document at a time. It is analogous to QueryCursor.\n *\n * An AggregationCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\n * but **not** the model's post aggregate hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Aggregate#cursor()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor()) instead.\n *\n * @param {Aggregate} agg\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction AggregationCursor(agg) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const connection = agg._connection;\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n\n  if (connection) {\n    this.cursor = connection.db.aggregate(agg._pipeline, agg.options || {});\n    setImmediate(() => this.emit('cursor', this.cursor));\n  } else {\n    _init(model, this, agg);\n  }\n}\n\nutil.inherits(AggregationCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg).then(() => onPreComplete(null), err => onPreComplete(err));\n  } else {\n    model.collection.emitter.once('queue', function() {\n      model.hooks.execPre('aggregate', agg).then(() => onPreComplete(null), err => onPreComplete(err));\n    });\n  }\n\n  function onPreComplete(err) {\n    if (err != null) {\n      _handlePreHookError(c, err);\n      return;\n    }\n    if (typeof agg.options?.cursor?.transform === 'function') {\n      c._transforms.push(agg.options.cursor.transform);\n    }\n\n    c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n    c.emit('cursor', c.cursor);\n  }\n}\n\n/**\n* Handles error emitted from pre middleware. In particular, checks for `skipWrappedFunction`, which allows skipping\n* the actual aggregation and overwriting the function's return value. Because aggregation cursors don't return a value,\n* we need to make sure the user doesn't accidentally set a value in skipWrappedFunction.\n*\n* @param {QueryCursor} queryCursor\n* @param {Error} err\n* @returns\n*/\n\nfunction _handlePreHookError(queryCursor, err) {\n  if (err instanceof kareem.skipWrappedFunction) {\n    const resultValue = err.args[0];\n    if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {\n      const err = new MongooseError(\n        'Cannot `skipMiddlewareFunction()` with a value when using ' +\n        '`.aggregate().cursor()`, value must be nullish or empty array, got \"' +\n        util.inspect(resultValue) +\n        '\".'\n      );\n      queryCursor._markError(err);\n      queryCursor.listeners('error').length > 0 && queryCursor.emit('error', err);\n      return;\n    }\n    queryCursor.emit('cursor', null);\n    return;\n  }\n  queryCursor._markError(err);\n  queryCursor.listeners('error').length > 0 && queryCursor.emit('error', err);\n}\n\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf AggregationCursor\n * @instance\n * @api private\n */\n\nAggregationCursor.prototype._read = function() {\n  const _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\nif (Symbol.asyncIterator != null) {\n  const msg = 'Mongoose does not support using async iterators with an ' +\n    'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\n\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    throw new MongooseError(msg);\n  };\n}\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {AggregationCursor}\n * @memberOf AggregationCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(AggregationCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @instance\n * @memberOf AggregationCursor\n * @api private\n */\n\nAggregationCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {Promise}\n * @api public\n * @method close\n * @emits \"close\"\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nAggregationCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n  this.emit('close');\n};\n\n/**\n * Marks this cursor as destroyed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {this}\n * @api private\n * @method _destroy\n */\n\nAggregationCursor.prototype._destroy = function _destroy(_err, callback) {\n  let waitForCursor = null;\n  if (!this.cursor) {\n    waitForCursor = new Promise((resolve) => {\n      this.once('cursor', resolve);\n    });\n  } else {\n    waitForCursor = Promise.resolve();\n  }\n\n  waitForCursor\n    .then(() => this.cursor.close())\n    .then(() => {\n      this._closed = true;\n      callback();\n    })\n    .catch(error => {\n      callback(error);\n    });\n  return this;\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nAggregationCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nAggregationCursor.prototype.eachAsync = function(fn, opts) {\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.eachAsync() no longer accepts a callback');\n  }\n  const _this = this;\n  if (typeof opts === 'function') {\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\n *     // creates an AggregationCursor instance internally.\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n *     // You can also use an AggregationCursor instance for async iteration\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\n *     for await (const doc of cursor) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf AggregationCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nAggregationCursor.prototype.addCursorFlag = function(flag, value) {\n  const _this = this;\n  _waitForCursor(this, function() {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function() {\n    cb();\n  });\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next().then(\n      doc => {\n        if (!doc) {\n          return callback(null, null);\n        }\n\n        callback(null, doc);\n      },\n      err => callback(err)\n    );\n  } else {\n    ctx.once('error', cb);\n    ctx.once('cursor', function() {\n      _next(ctx, cb);\n    });\n  }\n}\n\nmodule.exports = AggregationCursor;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}