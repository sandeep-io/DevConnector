{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst SchemaString = require('../../schema/string');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\nconst {\n  internalToObjectOptions\n} = require('../../options');\nconst mongodbUpdateOperators = new Set(['$currentDate', '$inc', '$min', '$max', '$mul', '$rename', '$set', '$setOnInsert', '$unset', '$addToSet', '$pop', '$pull', '$push', '$pullAll', '$bit']);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n  if (schema != null && filter != null && utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== 'object' && schema.discriminators != null) {\n    const discriminatorValue = filter[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] || byValue?.schema || schema;\n  } else if (schema != null && options.overwriteDiscriminatorKey && utils.hasUserDefinedProperty(obj, schema.options.discriminatorKey) && schema.discriminators != null) {\n    const discriminatorValue = obj[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] || byValue?.schema || schema;\n  } else if (schema != null && options.overwriteDiscriminatorKey && obj.$set != null && utils.hasUserDefinedProperty(obj.$set, schema.options.discriminatorKey) && schema.discriminators != null) {\n    const discriminatorValue = obj.$set[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] || byValue?.schema || schema;\n  }\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val?.$__) {\n      val = val.toObject(internalToObjectOptions);\n      ret[op] = val;\n    }\n    if (val && typeof val === 'object' && !Buffer.isBuffer(val) && mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. ' + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n  if (utils.hasOwnKeys(ret) === false && options.upsert && utils.hasOwnKeys(filter)) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return {\n      $setOnInsert: {\n        ...filter\n      }\n    };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' + ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, prefix) {\n  const strict = options.strict;\n  prefix = prefix ? prefix + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n  let aggregatedError = null;\n  const strictMode = strict ?? schema.options.strict;\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (schematype?.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n    const discriminatorKey = prefix ? prefix + key : key;\n    if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && schema.discriminatorMapping.value !== obj[key] && !options.overwriteDiscriminatorKey) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n      if (schematype && (schematype.embeddedSchemaType || schematype.Constructor) && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype?.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, {\n                strict: _strict\n              });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n          hasKeys = true;\n        }\n      } else if (op === '$currentDate' || op in castOps && schematype) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      } else if (op === '$rename') {\n        const schematype = new SchemaString(`${prefix}${key}.$rename`);\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      } else {\n        const pathToCheck = prefix + key;\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v?.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && utils.hasOwnKeys(val) === false;\n      }\n    } else {\n      const isModifier = key === '$each' || key === '$or' || key === '$and' || key === '$in';\n      if (isModifier && !prefix) {\n        throw new MongooseError('Invalid update: Unexpected modifier \"' + key + '\" as a key in operator. ' + 'Did you mean something like { $addToSet: { fieldName: { $each: [...] } } }? ' + 'Modifiers such as \"$each\", \"$or\", \"$and\", \"$in\" must appear under a valid field path.');\n      }\n      const checkPath = isModifier ? prefix : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n      let isStrict = strict;\n      if (pathDetails?.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n      const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        if (op === '$rename') {\n          if (obj[key] == null) {\n            throw new CastError('String', obj[key], `${prefix}${key}.$rename`);\n          }\n          const schematype = new SchemaString(`${prefix}${key}.$rename`, null, null, schema);\n          obj[key] = schematype.castForQuery(null, obj[key], context);\n          continue;\n        }\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype && schematype.embeddedSchemaType && !schematype.embeddedSchemaType.$isMongooseArray && !schematype.embeddedSchemaType[schemaMixedSymbol]) {\n            obj[key] = {\n              $each: obj[key]\n            };\n          }\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      }\n    }\n  }\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n  const cond = schema.$isMongooseArray && op in castOps && (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.embeddedSchemaType;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(null, val, context);\n    }\n    try {\n      return castNumber(val);\n    } catch {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return {\n        $type: val.$type\n      };\n    }\n    return Boolean(val);\n  }\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery($conditional, val, context);\n  }\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(null, val, context);\n  }\n  return schema.castForQuery(null, val, context);\n}","map":{"version":3,"names":["CastError","require","MongooseError","SchemaString","StrictModeError","ValidationError","castNumber","cast","getConstructorName","getDiscriminatorByValue","getEmbeddedDiscriminatorPath","handleImmutable","moveImmutableProperties","schemaMixedSymbol","setDottedPath","utils","internalToObjectOptions","mongodbUpdateOperators","Set","module","exports","castUpdate","schema","obj","options","context","filter","undefined","Array","isArray","len","length","i","ops","Object","keys","op","castPipelineOperator","hasUserDefinedProperty","discriminatorKey","discriminators","discriminatorValue","byValue","model","overwriteDiscriminatorKey","$set","upsert","ret","val","hasDollarKey","has","splice","indexOf","push","startsWith","$__","toObject","Buffer","isBuffer","walkUpdatePath","msg","Error","isEmptyObject","hasOwnKeys","$setOnInsert","find","v","prefix","strict","hasKeys","schematype","key","aggregatedError","strictMode","_getSchema","_res","discriminatorMapping","value","err","_appendError","embeddedSchemaType","Constructor","castOps","$each","castUpdateVal","error","$slice","$sort","$position","$isSingleNested","_strict","castForQuery","pathToCheck","_getPathType","pathType","isObject","isModifier","checkPath","pathDetails","type","isStrict","skip","test","virtuals","$isMongooseArray","query","multipleCastError","addError","numberOps","$pop","$inc","noCastOps","$unset","$push","$addToSet","overwriteOps","$conditional","path","cond","schemaArrayDepth","cur","arrayDepth","_val","additionalNesting","tmp","applySetters","$type","Boolean","skipQueryCastForUpdate","$fullPath","match"],"sources":["C:/DEVC/node_modules/mongoose/lib/helpers/query/castUpdate.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst SchemaString = require('../../schema/string');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\nconst { internalToObjectOptions } = require('../../options');\n\nconst mongodbUpdateOperators = new Set([\n  '$currentDate',\n  '$inc',\n  '$min',\n  '$max',\n  '$mul',\n  '$rename',\n  '$set',\n  '$setOnInsert',\n  '$unset',\n  '$addToSet',\n  '$pop',\n  '$pull',\n  '$push',\n  '$pullAll',\n  '$bit'\n]);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (schema != null &&\n      filter != null &&\n      utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) &&\n      typeof filter[schema.options.discriminatorKey] !== 'object' &&\n      schema.discriminators != null) {\n    const discriminatorValue = filter[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      byValue?.schema ||\n      schema;\n  } else if (schema != null &&\n      options.overwriteDiscriminatorKey &&\n      utils.hasUserDefinedProperty(obj, schema.options.discriminatorKey) &&\n      schema.discriminators != null) {\n    const discriminatorValue = obj[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      byValue?.schema ||\n      schema;\n  } else if (schema != null &&\n      options.overwriteDiscriminatorKey &&\n      obj.$set != null &&\n      utils.hasUserDefinedProperty(obj.$set, schema.options.discriminatorKey) &&\n      schema.discriminators != null) {\n    const discriminatorValue = obj.$set[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      byValue?.schema ||\n      schema;\n  }\n\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val?.$__) {\n      val = val.toObject(internalToObjectOptions);\n      ret[op] = val;\n    }\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (utils.hasOwnKeys(ret) === false &&\n      options.upsert &&\n      utils.hasOwnKeys(filter)) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return { $setOnInsert: { ...filter } };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, prefix) {\n  const strict = options.strict;\n  prefix = prefix ? prefix + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  const strictMode = strict ?? schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (schematype?.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    const discriminatorKey = (prefix ? prefix + key : key);\n    if (\n      schema.discriminatorMapping != null &&\n      discriminatorKey === schema.options.discriminatorKey &&\n      schema.discriminatorMapping.value !== obj[key] &&\n      !options.overwriteDiscriminatorKey\n    ) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n\n      if (schematype && (schematype.embeddedSchemaType || schematype.Constructor) && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype?.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else if (op === '$rename') {\n        const schematype = new SchemaString(`${prefix}${key}.$rename`);\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v?.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && utils.hasOwnKeys(val) === false);\n      }\n    } else {\n      const isModifier = (key === '$each' || key === '$or' || key === '$and' || key === '$in');\n      if (isModifier && !prefix) {\n        throw new MongooseError('Invalid update: Unexpected modifier \"' + key + '\" as a key in operator. '\n          + 'Did you mean something like { $addToSet: { fieldName: { $each: [...] } } }? '\n          + 'Modifiers such as \"$each\", \"$or\", \"$and\", \"$in\" must appear under a valid field path.');\n      }\n      const checkPath = isModifier ? prefix : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (pathDetails?.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        if (op === '$rename') {\n          if (obj[key] == null) {\n            throw new CastError('String', obj[key], `${prefix}${key}.$rename`);\n          }\n          const schematype = new SchemaString(`${prefix}${key}.$rename`, null, null, schema);\n          obj[key] = schematype.castForQuery(null, obj[key], context);\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype &&\n              schematype.embeddedSchemaType &&\n              !schematype.embeddedSchemaType.$isMongooseArray &&\n              !schematype.embeddedSchemaType[schemaMixedSymbol]) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  const cond = schema.$isMongooseArray\n    && op in castOps\n    && (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.embeddedSchemaType;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(\n        null,\n        val,\n        context\n      );\n    }\n    try {\n      return castNumber(val);\n    } catch {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery(\n      $conditional,\n      val,\n      context\n    );\n  }\n\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null\n      && schema.$isMongooseArray\n      && schema.$fullPath != null\n      && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(\n      null,\n      val,\n      context\n    );\n  }\n\n  return schema.castForQuery(null, val, context);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}